"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/cheerio";
exports.ids = ["vendor-chunks/cheerio"];
exports.modules = {

/***/ "(rsc)/./node_modules/cheerio/dist/commonjs/api/attributes.js":
/*!**************************************************************!*\
  !*** ./node_modules/cheerio/dist/commonjs/api/attributes.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Methods for getting and modifying attributes.\n *\n * @module cheerio/attributes\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.attr = attr;\nexports.prop = prop;\nexports.data = data;\nexports.val = val;\nexports.removeAttr = removeAttr;\nexports.hasClass = hasClass;\nexports.addClass = addClass;\nexports.removeClass = removeClass;\nexports.toggleClass = toggleClass;\nconst static_js_1 = __webpack_require__(/*! ../static.js */ \"(rsc)/./node_modules/cheerio/dist/commonjs/static.js\");\nconst utils_js_1 = __webpack_require__(/*! ../utils.js */ \"(rsc)/./node_modules/cheerio/dist/commonjs/utils.js\");\nconst domhandler_1 = __webpack_require__(/*! domhandler */ \"(rsc)/./node_modules/domhandler/lib/index.js\");\nconst domutils_1 = __webpack_require__(/*! domutils */ \"(rsc)/./node_modules/domutils/lib/index.js\");\nconst hasOwn = Object.prototype.hasOwnProperty;\nconst rspace = /\\s+/;\nconst dataAttrPrefix = 'data-';\n// Attributes that are booleans\nconst rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i;\n// Matches strings that look like JSON objects or arrays\nconst rbrace = /^{[^]*}$|^\\[[^]*]$/;\nfunction getAttr(elem, name, xmlMode) {\n    var _a;\n    if (!elem || !(0, domhandler_1.isTag)(elem))\n        return undefined;\n    (_a = elem.attribs) !== null && _a !== void 0 ? _a : (elem.attribs = {});\n    // Return the entire attribs object if no attribute specified\n    if (!name) {\n        return elem.attribs;\n    }\n    if (hasOwn.call(elem.attribs, name)) {\n        // Get the (decoded) attribute\n        return !xmlMode && rboolean.test(name) ? name : elem.attribs[name];\n    }\n    // Mimic the DOM and return text content as value for `option's`\n    if (elem.name === 'option' && name === 'value') {\n        return (0, static_js_1.text)(elem.children);\n    }\n    // Mimic DOM with default value for radios/checkboxes\n    if (elem.name === 'input' &&\n        (elem.attribs['type'] === 'radio' || elem.attribs['type'] === 'checkbox') &&\n        name === 'value') {\n        return 'on';\n    }\n    return undefined;\n}\n/**\n * Sets the value of an attribute. The attribute will be deleted if the value is\n * `null`.\n *\n * @private\n * @param el - The element to set the attribute on.\n * @param name - The attribute's name.\n * @param value - The attribute's value.\n */\nfunction setAttr(el, name, value) {\n    if (value === null) {\n        removeAttribute(el, name);\n    }\n    else {\n        el.attribs[name] = `${value}`;\n    }\n}\nfunction attr(name, value) {\n    // Set the value (with attr map support)\n    if (typeof name === 'object' || value !== undefined) {\n        if (typeof value === 'function') {\n            if (typeof name !== 'string') {\n                {\n                    throw new Error('Bad combination of arguments.');\n                }\n            }\n            return (0, utils_js_1.domEach)(this, (el, i) => {\n                if ((0, domhandler_1.isTag)(el))\n                    setAttr(el, name, value.call(el, i, el.attribs[name]));\n            });\n        }\n        return (0, utils_js_1.domEach)(this, (el) => {\n            if (!(0, domhandler_1.isTag)(el))\n                return;\n            if (typeof name === 'object') {\n                for (const objName of Object.keys(name)) {\n                    const objValue = name[objName];\n                    setAttr(el, objName, objValue);\n                }\n            }\n            else {\n                setAttr(el, name, value);\n            }\n        });\n    }\n    return arguments.length > 1\n        ? this\n        : getAttr(this[0], name, this.options.xmlMode);\n}\n/**\n * Gets a node's prop.\n *\n * @private\n * @category Attributes\n * @param el - Element to get the prop of.\n * @param name - Name of the prop.\n * @param xmlMode - Disable handling of special HTML attributes.\n * @returns The prop's value.\n */\nfunction getProp(el, name, xmlMode) {\n    return name in el\n        ? // @ts-expect-error TS doesn't like us accessing the value directly here.\n            el[name]\n        : !xmlMode && rboolean.test(name)\n            ? getAttr(el, name, false) !== undefined\n            : getAttr(el, name, xmlMode);\n}\n/**\n * Sets the value of a prop.\n *\n * @private\n * @param el - The element to set the prop on.\n * @param name - The prop's name.\n * @param value - The prop's value.\n * @param xmlMode - Disable handling of special HTML attributes.\n */\nfunction setProp(el, name, value, xmlMode) {\n    if (name in el) {\n        // @ts-expect-error Overriding value\n        el[name] = value;\n    }\n    else {\n        setAttr(el, name, !xmlMode && rboolean.test(name) ? (value ? '' : null) : `${value}`);\n    }\n}\nfunction prop(name, value) {\n    var _a;\n    if (typeof name === 'string' && value === undefined) {\n        const el = this[0];\n        if (!el || !(0, domhandler_1.isTag)(el))\n            return undefined;\n        switch (name) {\n            case 'style': {\n                const property = this.css();\n                const keys = Object.keys(property);\n                for (let i = 0; i < keys.length; i++) {\n                    property[i] = keys[i];\n                }\n                property.length = keys.length;\n                return property;\n            }\n            case 'tagName':\n            case 'nodeName': {\n                return el.name.toUpperCase();\n            }\n            case 'href':\n            case 'src': {\n                const prop = (_a = el.attribs) === null || _a === void 0 ? void 0 : _a[name];\n                if (typeof URL !== 'undefined' &&\n                    ((name === 'href' && (el.tagName === 'a' || el.tagName === 'link')) ||\n                        (name === 'src' &&\n                            (el.tagName === 'img' ||\n                                el.tagName === 'iframe' ||\n                                el.tagName === 'audio' ||\n                                el.tagName === 'video' ||\n                                el.tagName === 'source'))) &&\n                    prop !== undefined &&\n                    this.options.baseURI) {\n                    return new URL(prop, this.options.baseURI).href;\n                }\n                return prop;\n            }\n            case 'innerText': {\n                return (0, domutils_1.innerText)(el);\n            }\n            case 'textContent': {\n                return (0, domutils_1.textContent)(el);\n            }\n            case 'outerHTML': {\n                return this.clone().wrap('<container />').parent().html();\n            }\n            case 'innerHTML': {\n                return this.html();\n            }\n            default: {\n                return getProp(el, name, this.options.xmlMode);\n            }\n        }\n    }\n    if (typeof name === 'object' || value !== undefined) {\n        if (typeof value === 'function') {\n            if (typeof name === 'object') {\n                throw new TypeError('Bad combination of arguments.');\n            }\n            return (0, utils_js_1.domEach)(this, (el, i) => {\n                if ((0, domhandler_1.isTag)(el)) {\n                    setProp(el, name, value.call(el, i, getProp(el, name, this.options.xmlMode)), this.options.xmlMode);\n                }\n            });\n        }\n        return (0, utils_js_1.domEach)(this, (el) => {\n            if (!(0, domhandler_1.isTag)(el))\n                return;\n            if (typeof name === 'object') {\n                for (const key of Object.keys(name)) {\n                    const val = name[key];\n                    setProp(el, key, val, this.options.xmlMode);\n                }\n            }\n            else {\n                setProp(el, name, value, this.options.xmlMode);\n            }\n        });\n    }\n    return undefined;\n}\n/**\n * Sets the value of a data attribute.\n *\n * @private\n * @param elem - The element to set the data attribute on.\n * @param name - The data attribute's name.\n * @param value - The data attribute's value.\n */\nfunction setData(elem, name, value) {\n    var _a;\n    (_a = elem.data) !== null && _a !== void 0 ? _a : (elem.data = {});\n    if (typeof name === 'object')\n        Object.assign(elem.data, name);\n    else if (typeof name === 'string' && value !== undefined) {\n        elem.data[name] = value;\n    }\n}\n/**\n * Read _all_ HTML5 `data-*` attributes from the equivalent HTML5 `data-*`\n * attribute, and cache the value in the node's internal data store.\n *\n * @private\n * @category Attributes\n * @param el - Element to get the data attribute of.\n * @returns A map with all of the data attributes.\n */\nfunction readAllData(el) {\n    for (const domName of Object.keys(el.attribs)) {\n        if (!domName.startsWith(dataAttrPrefix)) {\n            continue;\n        }\n        const jsName = (0, utils_js_1.camelCase)(domName.slice(dataAttrPrefix.length));\n        if (!hasOwn.call(el.data, jsName)) {\n            el.data[jsName] = parseDataValue(el.attribs[domName]);\n        }\n    }\n    return el.data;\n}\n/**\n * Read the specified attribute from the equivalent HTML5 `data-*` attribute,\n * and (if present) cache the value in the node's internal data store.\n *\n * @private\n * @category Attributes\n * @param el - Element to get the data attribute of.\n * @param name - Name of the data attribute.\n * @returns The data attribute's value.\n */\nfunction readData(el, name) {\n    const domName = dataAttrPrefix + (0, utils_js_1.cssCase)(name);\n    const data = el.data;\n    if (hasOwn.call(data, name)) {\n        return data[name];\n    }\n    if (hasOwn.call(el.attribs, domName)) {\n        return (data[name] = parseDataValue(el.attribs[domName]));\n    }\n    return undefined;\n}\n/**\n * Coerce string data-* attributes to their corresponding JavaScript primitives.\n *\n * @private\n * @category Attributes\n * @param value - The value to parse.\n * @returns The parsed value.\n */\nfunction parseDataValue(value) {\n    if (value === 'null')\n        return null;\n    if (value === 'true')\n        return true;\n    if (value === 'false')\n        return false;\n    const num = Number(value);\n    if (value === String(num))\n        return num;\n    if (rbrace.test(value)) {\n        try {\n            return JSON.parse(value);\n        }\n        catch {\n            /* Ignore */\n        }\n    }\n    return value;\n}\nfunction data(name, value) {\n    var _a;\n    const elem = this[0];\n    if (!elem || !(0, domhandler_1.isTag)(elem))\n        return;\n    const dataEl = elem;\n    (_a = dataEl.data) !== null && _a !== void 0 ? _a : (dataEl.data = {});\n    // Return the entire data object if no data specified\n    if (name == null) {\n        return readAllData(dataEl);\n    }\n    // Set the value (with attr map support)\n    if (typeof name === 'object' || value !== undefined) {\n        (0, utils_js_1.domEach)(this, (el) => {\n            if ((0, domhandler_1.isTag)(el)) {\n                if (typeof name === 'object')\n                    setData(el, name);\n                else\n                    setData(el, name, value);\n            }\n        });\n        return this;\n    }\n    return readData(dataEl, name);\n}\nfunction val(value) {\n    const querying = arguments.length === 0;\n    const element = this[0];\n    if (!element || !(0, domhandler_1.isTag)(element))\n        return querying ? undefined : this;\n    switch (element.name) {\n        case 'textarea': {\n            return this.text(value);\n        }\n        case 'select': {\n            const option = this.find('option:selected');\n            if (!querying) {\n                if (this.attr('multiple') == null && typeof value === 'object') {\n                    return this;\n                }\n                this.find('option').removeAttr('selected');\n                const values = typeof value === 'object' ? value : [value];\n                for (const val of values) {\n                    this.find(`option[value=\"${val}\"]`).attr('selected', '');\n                }\n                return this;\n            }\n            return this.attr('multiple')\n                ? option.toArray().map((el) => (0, static_js_1.text)(el.children))\n                : option.attr('value');\n        }\n        case 'input':\n        case 'option': {\n            return querying\n                ? this.attr('value')\n                : this.attr('value', value);\n        }\n    }\n    return undefined;\n}\n/**\n * Remove an attribute.\n *\n * @private\n * @param elem - Node to remove attribute from.\n * @param name - Name of the attribute to remove.\n */\nfunction removeAttribute(elem, name) {\n    if (!elem.attribs || !hasOwn.call(elem.attribs, name))\n        return;\n    delete elem.attribs[name];\n}\n/**\n * Splits a space-separated list of names to individual names.\n *\n * @category Attributes\n * @param names - Names to split.\n * @returns - Split names.\n */\nfunction splitNames(names) {\n    return names ? names.trim().split(rspace) : [];\n}\n/**\n * Method for removing attributes by `name`.\n *\n * @category Attributes\n * @example\n *\n * ```js\n * $('.pear').removeAttr('class').html();\n * //=> <li>Pear</li>\n *\n * $('.apple').attr('id', 'favorite');\n * $('.apple').removeAttr('id class').html();\n * //=> <li>Apple</li>\n * ```\n *\n * @param name - Name of the attribute.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/removeAttr/}\n */\nfunction removeAttr(name) {\n    const attrNames = splitNames(name);\n    for (const attrName of attrNames) {\n        (0, utils_js_1.domEach)(this, (elem) => {\n            if ((0, domhandler_1.isTag)(elem))\n                removeAttribute(elem, attrName);\n        });\n    }\n    return this;\n}\n/**\n * Check to see if _any_ of the matched elements have the given `className`.\n *\n * @category Attributes\n * @example\n *\n * ```js\n * $('.pear').hasClass('pear');\n * //=> true\n *\n * $('apple').hasClass('fruit');\n * //=> false\n *\n * $('li').hasClass('pear');\n * //=> true\n * ```\n *\n * @param className - Name of the class.\n * @returns Indicates if an element has the given `className`.\n * @see {@link https://api.jquery.com/hasClass/}\n */\nfunction hasClass(className) {\n    return this.toArray().some((elem) => {\n        const clazz = (0, domhandler_1.isTag)(elem) && elem.attribs['class'];\n        let idx = -1;\n        if (clazz && className.length > 0) {\n            while ((idx = clazz.indexOf(className, idx + 1)) > -1) {\n                const end = idx + className.length;\n                if ((idx === 0 || rspace.test(clazz[idx - 1])) &&\n                    (end === clazz.length || rspace.test(clazz[end]))) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    });\n}\n/**\n * Adds class(es) to all of the matched elements. Also accepts a `function`.\n *\n * @category Attributes\n * @example\n *\n * ```js\n * $('.pear').addClass('fruit').html();\n * //=> <li class=\"pear fruit\">Pear</li>\n *\n * $('.apple').addClass('fruit red').html();\n * //=> <li class=\"apple fruit red\">Apple</li>\n * ```\n *\n * @param value - Name of new class.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/addClass/}\n */\nfunction addClass(value) {\n    // Support functions\n    if (typeof value === 'function') {\n        return (0, utils_js_1.domEach)(this, (el, i) => {\n            if ((0, domhandler_1.isTag)(el)) {\n                const className = el.attribs['class'] || '';\n                addClass.call([el], value.call(el, i, className));\n            }\n        });\n    }\n    // Return if no value or not a string or function\n    if (!value || typeof value !== 'string')\n        return this;\n    const classNames = value.split(rspace);\n    const numElements = this.length;\n    for (let i = 0; i < numElements; i++) {\n        const el = this[i];\n        // If selected element isn't a tag, move on\n        if (!(0, domhandler_1.isTag)(el))\n            continue;\n        // If we don't already have classes â€” always set xmlMode to false here, as it doesn't matter for classes\n        const className = getAttr(el, 'class', false);\n        if (className) {\n            let setClass = ` ${className} `;\n            // Check if class already exists\n            for (const cn of classNames) {\n                const appendClass = `${cn} `;\n                if (!setClass.includes(` ${appendClass}`))\n                    setClass += appendClass;\n            }\n            setAttr(el, 'class', setClass.trim());\n        }\n        else {\n            setAttr(el, 'class', classNames.join(' ').trim());\n        }\n    }\n    return this;\n}\n/**\n * Removes one or more space-separated classes from the selected elements. If no\n * `className` is defined, all classes will be removed. Also accepts a\n * `function`.\n *\n * @category Attributes\n * @example\n *\n * ```js\n * $('.pear').removeClass('pear').html();\n * //=> <li class=\"\">Pear</li>\n *\n * $('.apple').addClass('red').removeClass().html();\n * //=> <li class=\"\">Apple</li>\n * ```\n *\n * @param name - Name of the class. If not specified, removes all elements.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/removeClass/}\n */\nfunction removeClass(name) {\n    // Handle if value is a function\n    if (typeof name === 'function') {\n        return (0, utils_js_1.domEach)(this, (el, i) => {\n            if ((0, domhandler_1.isTag)(el)) {\n                removeClass.call([el], name.call(el, i, el.attribs['class'] || ''));\n            }\n        });\n    }\n    const classes = splitNames(name);\n    const numClasses = classes.length;\n    const removeAll = arguments.length === 0;\n    return (0, utils_js_1.domEach)(this, (el) => {\n        if (!(0, domhandler_1.isTag)(el))\n            return;\n        if (removeAll) {\n            // Short circuit the remove all case as this is the nice one\n            el.attribs['class'] = '';\n        }\n        else {\n            const elClasses = splitNames(el.attribs['class']);\n            let changed = false;\n            for (let j = 0; j < numClasses; j++) {\n                const index = elClasses.indexOf(classes[j]);\n                if (index >= 0) {\n                    elClasses.splice(index, 1);\n                    changed = true;\n                    /*\n                     * We have to do another pass to ensure that there are not duplicate\n                     * classes listed\n                     */\n                    j--;\n                }\n            }\n            if (changed) {\n                el.attribs['class'] = elClasses.join(' ');\n            }\n        }\n    });\n}\n/**\n * Add or remove class(es) from the matched elements, depending on either the\n * class's presence or the value of the switch argument. Also accepts a\n * `function`.\n *\n * @category Attributes\n * @example\n *\n * ```js\n * $('.apple.green').toggleClass('fruit green red').html();\n * //=> <li class=\"apple fruit red\">Apple</li>\n *\n * $('.apple.green').toggleClass('fruit green red', true).html();\n * //=> <li class=\"apple green fruit red\">Apple</li>\n * ```\n *\n * @param value - Name of the class. Can also be a function.\n * @param stateVal - If specified the state of the class.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/toggleClass/}\n */\nfunction toggleClass(value, stateVal) {\n    // Support functions\n    if (typeof value === 'function') {\n        return (0, utils_js_1.domEach)(this, (el, i) => {\n            if ((0, domhandler_1.isTag)(el)) {\n                toggleClass.call([el], value.call(el, i, el.attribs['class'] || '', stateVal), stateVal);\n            }\n        });\n    }\n    // Return if no value or not a string or function\n    if (!value || typeof value !== 'string')\n        return this;\n    const classNames = value.split(rspace);\n    const numClasses = classNames.length;\n    const state = typeof stateVal === 'boolean' ? (stateVal ? 1 : -1) : 0;\n    const numElements = this.length;\n    for (let i = 0; i < numElements; i++) {\n        const el = this[i];\n        // If selected element isn't a tag, move on\n        if (!(0, domhandler_1.isTag)(el))\n            continue;\n        const elementClasses = splitNames(el.attribs['class']);\n        // Check if class already exists\n        for (let j = 0; j < numClasses; j++) {\n            // Check if the class name is currently defined\n            const index = elementClasses.indexOf(classNames[j]);\n            // Add if stateValue === true or we are toggling and there is no value\n            if (state >= 0 && index < 0) {\n                elementClasses.push(classNames[j]);\n            }\n            else if (state <= 0 && index >= 0) {\n                // Otherwise remove but only if the item exists\n                elementClasses.splice(index, 1);\n            }\n        }\n        el.attribs['class'] = elementClasses.join(' ');\n    }\n    return this;\n}\n//# sourceMappingURL=attributes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2hlZXJpby9kaXN0L2NvbW1vbmpzL2FwaS9hdHRyaWJ1dGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZO0FBQ1osWUFBWTtBQUNaLFlBQVk7QUFDWixXQUFXO0FBQ1gsa0JBQWtCO0FBQ2xCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixvQkFBb0IsbUJBQU8sQ0FBQywwRUFBYztBQUMxQyxtQkFBbUIsbUJBQU8sQ0FBQyx3RUFBYTtBQUN4QyxxQkFBcUIsbUJBQU8sQ0FBQyxnRUFBWTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyw0REFBVTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsS0FBSztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixNQUFNO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixNQUFNO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpQkFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsSUFBSTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixXQUFXO0FBQzFDO0FBQ0E7QUFDQSx1Q0FBdUMsSUFBSTtBQUMzQywyQ0FBMkMsWUFBWTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvaW10aXlhei9EZXNrdG9wL1N1cGVyTGVhcm4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2NoZWVyaW8vZGlzdC9jb21tb25qcy9hcGkvYXR0cmlidXRlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogTWV0aG9kcyBmb3IgZ2V0dGluZyBhbmQgbW9kaWZ5aW5nIGF0dHJpYnV0ZXMuXG4gKlxuICogQG1vZHVsZSBjaGVlcmlvL2F0dHJpYnV0ZXNcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hdHRyID0gYXR0cjtcbmV4cG9ydHMucHJvcCA9IHByb3A7XG5leHBvcnRzLmRhdGEgPSBkYXRhO1xuZXhwb3J0cy52YWwgPSB2YWw7XG5leHBvcnRzLnJlbW92ZUF0dHIgPSByZW1vdmVBdHRyO1xuZXhwb3J0cy5oYXNDbGFzcyA9IGhhc0NsYXNzO1xuZXhwb3J0cy5hZGRDbGFzcyA9IGFkZENsYXNzO1xuZXhwb3J0cy5yZW1vdmVDbGFzcyA9IHJlbW92ZUNsYXNzO1xuZXhwb3J0cy50b2dnbGVDbGFzcyA9IHRvZ2dsZUNsYXNzO1xuY29uc3Qgc3RhdGljX2pzXzEgPSByZXF1aXJlKFwiLi4vc3RhdGljLmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy5qc1wiKTtcbmNvbnN0IGRvbWhhbmRsZXJfMSA9IHJlcXVpcmUoXCJkb21oYW5kbGVyXCIpO1xuY29uc3QgZG9tdXRpbHNfMSA9IHJlcXVpcmUoXCJkb211dGlsc1wiKTtcbmNvbnN0IGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5jb25zdCByc3BhY2UgPSAvXFxzKy87XG5jb25zdCBkYXRhQXR0clByZWZpeCA9ICdkYXRhLSc7XG4vLyBBdHRyaWJ1dGVzIHRoYXQgYXJlIGJvb2xlYW5zXG5jb25zdCByYm9vbGVhbiA9IC9eKD86YXV0b2ZvY3VzfGF1dG9wbGF5fGFzeW5jfGNoZWNrZWR8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWR8c2VsZWN0ZWQpJC9pO1xuLy8gTWF0Y2hlcyBzdHJpbmdzIHRoYXQgbG9vayBsaWtlIEpTT04gb2JqZWN0cyBvciBhcnJheXNcbmNvbnN0IHJicmFjZSA9IC9ee1teXSp9JHxeXFxbW15dKl0kLztcbmZ1bmN0aW9uIGdldEF0dHIoZWxlbSwgbmFtZSwgeG1sTW9kZSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIWVsZW0gfHwgISgwLCBkb21oYW5kbGVyXzEuaXNUYWcpKGVsZW0pKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIChfYSA9IGVsZW0uYXR0cmlicykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKGVsZW0uYXR0cmlicyA9IHt9KTtcbiAgICAvLyBSZXR1cm4gdGhlIGVudGlyZSBhdHRyaWJzIG9iamVjdCBpZiBubyBhdHRyaWJ1dGUgc3BlY2lmaWVkXG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIHJldHVybiBlbGVtLmF0dHJpYnM7XG4gICAgfVxuICAgIGlmIChoYXNPd24uY2FsbChlbGVtLmF0dHJpYnMsIG5hbWUpKSB7XG4gICAgICAgIC8vIEdldCB0aGUgKGRlY29kZWQpIGF0dHJpYnV0ZVxuICAgICAgICByZXR1cm4gIXhtbE1vZGUgJiYgcmJvb2xlYW4udGVzdChuYW1lKSA/IG5hbWUgOiBlbGVtLmF0dHJpYnNbbmFtZV07XG4gICAgfVxuICAgIC8vIE1pbWljIHRoZSBET00gYW5kIHJldHVybiB0ZXh0IGNvbnRlbnQgYXMgdmFsdWUgZm9yIGBvcHRpb24nc2BcbiAgICBpZiAoZWxlbS5uYW1lID09PSAnb3B0aW9uJyAmJiBuYW1lID09PSAndmFsdWUnKSB7XG4gICAgICAgIHJldHVybiAoMCwgc3RhdGljX2pzXzEudGV4dCkoZWxlbS5jaGlsZHJlbik7XG4gICAgfVxuICAgIC8vIE1pbWljIERPTSB3aXRoIGRlZmF1bHQgdmFsdWUgZm9yIHJhZGlvcy9jaGVja2JveGVzXG4gICAgaWYgKGVsZW0ubmFtZSA9PT0gJ2lucHV0JyAmJlxuICAgICAgICAoZWxlbS5hdHRyaWJzWyd0eXBlJ10gPT09ICdyYWRpbycgfHwgZWxlbS5hdHRyaWJzWyd0eXBlJ10gPT09ICdjaGVja2JveCcpICYmXG4gICAgICAgIG5hbWUgPT09ICd2YWx1ZScpIHtcbiAgICAgICAgcmV0dXJuICdvbic7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZS4gVGhlIGF0dHJpYnV0ZSB3aWxsIGJlIGRlbGV0ZWQgaWYgdGhlIHZhbHVlIGlzXG4gKiBgbnVsbGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSBlbCAtIFRoZSBlbGVtZW50IHRvIHNldCB0aGUgYXR0cmlidXRlIG9uLlxuICogQHBhcmFtIG5hbWUgLSBUaGUgYXR0cmlidXRlJ3MgbmFtZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBhdHRyaWJ1dGUncyB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc2V0QXR0cihlbCwgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmVtb3ZlQXR0cmlidXRlKGVsLCBuYW1lKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVsLmF0dHJpYnNbbmFtZV0gPSBgJHt2YWx1ZX1gO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGF0dHIobmFtZSwgdmFsdWUpIHtcbiAgICAvLyBTZXQgdGhlIHZhbHVlICh3aXRoIGF0dHIgbWFwIHN1cHBvcnQpXG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0JyB8fCB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQmFkIGNvbWJpbmF0aW9uIG9mIGFyZ3VtZW50cy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzX2pzXzEuZG9tRWFjaCkodGhpcywgKGVsLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBkb21oYW5kbGVyXzEuaXNUYWcpKGVsKSlcbiAgICAgICAgICAgICAgICAgICAgc2V0QXR0cihlbCwgbmFtZSwgdmFsdWUuY2FsbChlbCwgaSwgZWwuYXR0cmlic1tuYW1lXSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc19qc18xLmRvbUVhY2gpKHRoaXMsIChlbCkgPT4ge1xuICAgICAgICAgICAgaWYgKCEoMCwgZG9taGFuZGxlcl8xLmlzVGFnKShlbCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgb2JqTmFtZSBvZiBPYmplY3Qua2V5cyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvYmpWYWx1ZSA9IG5hbWVbb2JqTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIHNldEF0dHIoZWwsIG9iak5hbWUsIG9ialZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRBdHRyKGVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDFcbiAgICAgICAgPyB0aGlzXG4gICAgICAgIDogZ2V0QXR0cih0aGlzWzBdLCBuYW1lLCB0aGlzLm9wdGlvbnMueG1sTW9kZSk7XG59XG4vKipcbiAqIEdldHMgYSBub2RlJ3MgcHJvcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNhdGVnb3J5IEF0dHJpYnV0ZXNcbiAqIEBwYXJhbSBlbCAtIEVsZW1lbnQgdG8gZ2V0IHRoZSBwcm9wIG9mLlxuICogQHBhcmFtIG5hbWUgLSBOYW1lIG9mIHRoZSBwcm9wLlxuICogQHBhcmFtIHhtbE1vZGUgLSBEaXNhYmxlIGhhbmRsaW5nIG9mIHNwZWNpYWwgSFRNTCBhdHRyaWJ1dGVzLlxuICogQHJldHVybnMgVGhlIHByb3AncyB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvcChlbCwgbmFtZSwgeG1sTW9kZSkge1xuICAgIHJldHVybiBuYW1lIGluIGVsXG4gICAgICAgID8gLy8gQHRzLWV4cGVjdC1lcnJvciBUUyBkb2Vzbid0IGxpa2UgdXMgYWNjZXNzaW5nIHRoZSB2YWx1ZSBkaXJlY3RseSBoZXJlLlxuICAgICAgICAgICAgZWxbbmFtZV1cbiAgICAgICAgOiAheG1sTW9kZSAmJiByYm9vbGVhbi50ZXN0KG5hbWUpXG4gICAgICAgICAgICA/IGdldEF0dHIoZWwsIG5hbWUsIGZhbHNlKSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA6IGdldEF0dHIoZWwsIG5hbWUsIHhtbE1vZGUpO1xufVxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBvZiBhIHByb3AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSBlbCAtIFRoZSBlbGVtZW50IHRvIHNldCB0aGUgcHJvcCBvbi5cbiAqIEBwYXJhbSBuYW1lIC0gVGhlIHByb3AncyBuYW1lLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHByb3AncyB2YWx1ZS5cbiAqIEBwYXJhbSB4bWxNb2RlIC0gRGlzYWJsZSBoYW5kbGluZyBvZiBzcGVjaWFsIEhUTUwgYXR0cmlidXRlcy5cbiAqL1xuZnVuY3Rpb24gc2V0UHJvcChlbCwgbmFtZSwgdmFsdWUsIHhtbE1vZGUpIHtcbiAgICBpZiAobmFtZSBpbiBlbCkge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIE92ZXJyaWRpbmcgdmFsdWVcbiAgICAgICAgZWxbbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNldEF0dHIoZWwsIG5hbWUsICF4bWxNb2RlICYmIHJib29sZWFuLnRlc3QobmFtZSkgPyAodmFsdWUgPyAnJyA6IG51bGwpIDogYCR7dmFsdWV9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcHJvcChuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgZWwgPSB0aGlzWzBdO1xuICAgICAgICBpZiAoIWVsIHx8ICEoMCwgZG9taGFuZGxlcl8xLmlzVGFnKShlbCkpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3N0eWxlJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5ID0gdGhpcy5jc3MoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydHkpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eVtpXSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByb3BlcnR5Lmxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3RhZ05hbWUnOlxuICAgICAgICAgICAgY2FzZSAnbm9kZU5hbWUnOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsLm5hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2hyZWYnOlxuICAgICAgICAgICAgY2FzZSAnc3JjJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3AgPSAoX2EgPSBlbC5hdHRyaWJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbbmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBVUkwgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgICAgICgobmFtZSA9PT0gJ2hyZWYnICYmIChlbC50YWdOYW1lID09PSAnYScgfHwgZWwudGFnTmFtZSA9PT0gJ2xpbmsnKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChuYW1lID09PSAnc3JjJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlbC50YWdOYW1lID09PSAnaW1nJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC50YWdOYW1lID09PSAnaWZyYW1lJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC50YWdOYW1lID09PSAnYXVkaW8nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLnRhZ05hbWUgPT09ICd2aWRlbycgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwudGFnTmFtZSA9PT0gJ3NvdXJjZScpKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgcHJvcCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5iYXNlVVJJKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVVJMKHByb3AsIHRoaXMub3B0aW9ucy5iYXNlVVJJKS5ocmVmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2lubmVyVGV4dCc6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGRvbXV0aWxzXzEuaW5uZXJUZXh0KShlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICd0ZXh0Q29udGVudCc6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGRvbXV0aWxzXzEudGV4dENvbnRlbnQpKGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ291dGVySFRNTCc6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLndyYXAoJzxjb250YWluZXIgLz4nKS5wYXJlbnQoKS5odG1sKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdpbm5lckhUTUwnOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaHRtbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRQcm9wKGVsLCBuYW1lLCB0aGlzLm9wdGlvbnMueG1sTW9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0JyB8fCB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCYWQgY29tYmluYXRpb24gb2YgYXJndW1lbnRzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc19qc18xLmRvbUVhY2gpKHRoaXMsIChlbCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICgoMCwgZG9taGFuZGxlcl8xLmlzVGFnKShlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0UHJvcChlbCwgbmFtZSwgdmFsdWUuY2FsbChlbCwgaSwgZ2V0UHJvcChlbCwgbmFtZSwgdGhpcy5vcHRpb25zLnhtbE1vZGUpKSwgdGhpcy5vcHRpb25zLnhtbE1vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgdXRpbHNfanNfMS5kb21FYWNoKSh0aGlzLCAoZWwpID0+IHtcbiAgICAgICAgICAgIGlmICghKDAsIGRvbWhhbmRsZXJfMS5pc1RhZykoZWwpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBuYW1lW2tleV07XG4gICAgICAgICAgICAgICAgICAgIHNldFByb3AoZWwsIGtleSwgdmFsLCB0aGlzLm9wdGlvbnMueG1sTW9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0UHJvcChlbCwgbmFtZSwgdmFsdWUsIHRoaXMub3B0aW9ucy54bWxNb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIG9mIGEgZGF0YSBhdHRyaWJ1dGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSBlbGVtIC0gVGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBkYXRhIGF0dHJpYnV0ZSBvbi5cbiAqIEBwYXJhbSBuYW1lIC0gVGhlIGRhdGEgYXR0cmlidXRlJ3MgbmFtZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBkYXRhIGF0dHJpYnV0ZSdzIHZhbHVlLlxuICovXG5mdW5jdGlvbiBzZXREYXRhKGVsZW0sIG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IGVsZW0uZGF0YSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKGVsZW0uZGF0YSA9IHt9KTtcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKVxuICAgICAgICBPYmplY3QuYXNzaWduKGVsZW0uZGF0YSwgbmFtZSk7XG4gICAgZWxzZSBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZWxlbS5kYXRhW25hbWVdID0gdmFsdWU7XG4gICAgfVxufVxuLyoqXG4gKiBSZWFkIF9hbGxfIEhUTUw1IGBkYXRhLSpgIGF0dHJpYnV0ZXMgZnJvbSB0aGUgZXF1aXZhbGVudCBIVE1MNSBgZGF0YS0qYFxuICogYXR0cmlidXRlLCBhbmQgY2FjaGUgdGhlIHZhbHVlIGluIHRoZSBub2RlJ3MgaW50ZXJuYWwgZGF0YSBzdG9yZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNhdGVnb3J5IEF0dHJpYnV0ZXNcbiAqIEBwYXJhbSBlbCAtIEVsZW1lbnQgdG8gZ2V0IHRoZSBkYXRhIGF0dHJpYnV0ZSBvZi5cbiAqIEByZXR1cm5zIEEgbWFwIHdpdGggYWxsIG9mIHRoZSBkYXRhIGF0dHJpYnV0ZXMuXG4gKi9cbmZ1bmN0aW9uIHJlYWRBbGxEYXRhKGVsKSB7XG4gICAgZm9yIChjb25zdCBkb21OYW1lIG9mIE9iamVjdC5rZXlzKGVsLmF0dHJpYnMpKSB7XG4gICAgICAgIGlmICghZG9tTmFtZS5zdGFydHNXaXRoKGRhdGFBdHRyUHJlZml4KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QganNOYW1lID0gKDAsIHV0aWxzX2pzXzEuY2FtZWxDYXNlKShkb21OYW1lLnNsaWNlKGRhdGFBdHRyUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICBpZiAoIWhhc093bi5jYWxsKGVsLmRhdGEsIGpzTmFtZSkpIHtcbiAgICAgICAgICAgIGVsLmRhdGFbanNOYW1lXSA9IHBhcnNlRGF0YVZhbHVlKGVsLmF0dHJpYnNbZG9tTmFtZV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbC5kYXRhO1xufVxuLyoqXG4gKiBSZWFkIHRoZSBzcGVjaWZpZWQgYXR0cmlidXRlIGZyb20gdGhlIGVxdWl2YWxlbnQgSFRNTDUgYGRhdGEtKmAgYXR0cmlidXRlLFxuICogYW5kIChpZiBwcmVzZW50KSBjYWNoZSB0aGUgdmFsdWUgaW4gdGhlIG5vZGUncyBpbnRlcm5hbCBkYXRhIHN0b3JlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY2F0ZWdvcnkgQXR0cmlidXRlc1xuICogQHBhcmFtIGVsIC0gRWxlbWVudCB0byBnZXQgdGhlIGRhdGEgYXR0cmlidXRlIG9mLlxuICogQHBhcmFtIG5hbWUgLSBOYW1lIG9mIHRoZSBkYXRhIGF0dHJpYnV0ZS5cbiAqIEByZXR1cm5zIFRoZSBkYXRhIGF0dHJpYnV0ZSdzIHZhbHVlLlxuICovXG5mdW5jdGlvbiByZWFkRGF0YShlbCwgbmFtZSkge1xuICAgIGNvbnN0IGRvbU5hbWUgPSBkYXRhQXR0clByZWZpeCArICgwLCB1dGlsc19qc18xLmNzc0Nhc2UpKG5hbWUpO1xuICAgIGNvbnN0IGRhdGEgPSBlbC5kYXRhO1xuICAgIGlmIChoYXNPd24uY2FsbChkYXRhLCBuYW1lKSkge1xuICAgICAgICByZXR1cm4gZGF0YVtuYW1lXTtcbiAgICB9XG4gICAgaWYgKGhhc093bi5jYWxsKGVsLmF0dHJpYnMsIGRvbU5hbWUpKSB7XG4gICAgICAgIHJldHVybiAoZGF0YVtuYW1lXSA9IHBhcnNlRGF0YVZhbHVlKGVsLmF0dHJpYnNbZG9tTmFtZV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8qKlxuICogQ29lcmNlIHN0cmluZyBkYXRhLSogYXR0cmlidXRlcyB0byB0aGVpciBjb3JyZXNwb25kaW5nIEphdmFTY3JpcHQgcHJpbWl0aXZlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNhdGVnb3J5IEF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBwYXJzZS5cbiAqIEByZXR1cm5zIFRoZSBwYXJzZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRGF0YVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSAnbnVsbCcpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmICh2YWx1ZSA9PT0gJ3RydWUnKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodmFsdWUgPT09ICdmYWxzZScpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBudW0gPSBOdW1iZXIodmFsdWUpO1xuICAgIGlmICh2YWx1ZSA9PT0gU3RyaW5nKG51bSkpXG4gICAgICAgIHJldHVybiBudW07XG4gICAgaWYgKHJicmFjZS50ZXN0KHZhbHVlKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIC8qIElnbm9yZSAqL1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGRhdGEobmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZWxlbSA9IHRoaXNbMF07XG4gICAgaWYgKCFlbGVtIHx8ICEoMCwgZG9taGFuZGxlcl8xLmlzVGFnKShlbGVtKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGRhdGFFbCA9IGVsZW07XG4gICAgKF9hID0gZGF0YUVsLmRhdGEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChkYXRhRWwuZGF0YSA9IHt9KTtcbiAgICAvLyBSZXR1cm4gdGhlIGVudGlyZSBkYXRhIG9iamVjdCBpZiBubyBkYXRhIHNwZWNpZmllZFxuICAgIGlmIChuYW1lID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRBbGxEYXRhKGRhdGFFbCk7XG4gICAgfVxuICAgIC8vIFNldCB0aGUgdmFsdWUgKHdpdGggYXR0ciBtYXAgc3VwcG9ydClcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnIHx8IHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgKDAsIHV0aWxzX2pzXzEuZG9tRWFjaCkodGhpcywgKGVsKSA9PiB7XG4gICAgICAgICAgICBpZiAoKDAsIGRvbWhhbmRsZXJfMS5pc1RhZykoZWwpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgICAgICAgICAgc2V0RGF0YShlbCwgbmFtZSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBzZXREYXRhKGVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHJlYWREYXRhKGRhdGFFbCwgbmFtZSk7XG59XG5mdW5jdGlvbiB2YWwodmFsdWUpIHtcbiAgICBjb25zdCBxdWVyeWluZyA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDA7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXNbMF07XG4gICAgaWYgKCFlbGVtZW50IHx8ICEoMCwgZG9taGFuZGxlcl8xLmlzVGFnKShlbGVtZW50KSlcbiAgICAgICAgcmV0dXJuIHF1ZXJ5aW5nID8gdW5kZWZpbmVkIDogdGhpcztcbiAgICBzd2l0Y2ggKGVsZW1lbnQubmFtZSkge1xuICAgICAgICBjYXNlICd0ZXh0YXJlYSc6IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3NlbGVjdCc6IHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbiA9IHRoaXMuZmluZCgnb3B0aW9uOnNlbGVjdGVkJyk7XG4gICAgICAgICAgICBpZiAoIXF1ZXJ5aW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cignbXVsdGlwbGUnKSA9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZmluZCgnb3B0aW9uJykucmVtb3ZlQXR0cignc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8gdmFsdWUgOiBbdmFsdWVdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdmFsIG9mIHZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmQoYG9wdGlvblt2YWx1ZT1cIiR7dmFsfVwiXWApLmF0dHIoJ3NlbGVjdGVkJywgJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ211bHRpcGxlJylcbiAgICAgICAgICAgICAgICA/IG9wdGlvbi50b0FycmF5KCkubWFwKChlbCkgPT4gKDAsIHN0YXRpY19qc18xLnRleHQpKGVsLmNoaWxkcmVuKSlcbiAgICAgICAgICAgICAgICA6IG9wdGlvbi5hdHRyKCd2YWx1ZScpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgY2FzZSAnb3B0aW9uJzoge1xuICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5aW5nXG4gICAgICAgICAgICAgICAgPyB0aGlzLmF0dHIoJ3ZhbHVlJylcbiAgICAgICAgICAgICAgICA6IHRoaXMuYXR0cigndmFsdWUnLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8qKlxuICogUmVtb3ZlIGFuIGF0dHJpYnV0ZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIGVsZW0gLSBOb2RlIHRvIHJlbW92ZSBhdHRyaWJ1dGUgZnJvbS5cbiAqIEBwYXJhbSBuYW1lIC0gTmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIHJlbW92ZS5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQXR0cmlidXRlKGVsZW0sIG5hbWUpIHtcbiAgICBpZiAoIWVsZW0uYXR0cmlicyB8fCAhaGFzT3duLmNhbGwoZWxlbS5hdHRyaWJzLCBuYW1lKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGRlbGV0ZSBlbGVtLmF0dHJpYnNbbmFtZV07XG59XG4vKipcbiAqIFNwbGl0cyBhIHNwYWNlLXNlcGFyYXRlZCBsaXN0IG9mIG5hbWVzIHRvIGluZGl2aWR1YWwgbmFtZXMuXG4gKlxuICogQGNhdGVnb3J5IEF0dHJpYnV0ZXNcbiAqIEBwYXJhbSBuYW1lcyAtIE5hbWVzIHRvIHNwbGl0LlxuICogQHJldHVybnMgLSBTcGxpdCBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gc3BsaXROYW1lcyhuYW1lcykge1xuICAgIHJldHVybiBuYW1lcyA/IG5hbWVzLnRyaW0oKS5zcGxpdChyc3BhY2UpIDogW107XG59XG4vKipcbiAqIE1ldGhvZCBmb3IgcmVtb3ZpbmcgYXR0cmlidXRlcyBieSBgbmFtZWAuXG4gKlxuICogQGNhdGVnb3J5IEF0dHJpYnV0ZXNcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqICQoJy5wZWFyJykucmVtb3ZlQXR0cignY2xhc3MnKS5odG1sKCk7XG4gKiAvLz0+IDxsaT5QZWFyPC9saT5cbiAqXG4gKiAkKCcuYXBwbGUnKS5hdHRyKCdpZCcsICdmYXZvcml0ZScpO1xuICogJCgnLmFwcGxlJykucmVtb3ZlQXR0cignaWQgY2xhc3MnKS5odG1sKCk7XG4gKiAvLz0+IDxsaT5BcHBsZTwvbGk+XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gbmFtZSAtIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZS5cbiAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gKiBAc2VlIHtAbGluayBodHRwczovL2FwaS5qcXVlcnkuY29tL3JlbW92ZUF0dHIvfVxuICovXG5mdW5jdGlvbiByZW1vdmVBdHRyKG5hbWUpIHtcbiAgICBjb25zdCBhdHRyTmFtZXMgPSBzcGxpdE5hbWVzKG5hbWUpO1xuICAgIGZvciAoY29uc3QgYXR0ck5hbWUgb2YgYXR0ck5hbWVzKSB7XG4gICAgICAgICgwLCB1dGlsc19qc18xLmRvbUVhY2gpKHRoaXMsIChlbGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoKDAsIGRvbWhhbmRsZXJfMS5pc1RhZykoZWxlbSkpXG4gICAgICAgICAgICAgICAgcmVtb3ZlQXR0cmlidXRlKGVsZW0sIGF0dHJOYW1lKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufVxuLyoqXG4gKiBDaGVjayB0byBzZWUgaWYgX2FueV8gb2YgdGhlIG1hdGNoZWQgZWxlbWVudHMgaGF2ZSB0aGUgZ2l2ZW4gYGNsYXNzTmFtZWAuXG4gKlxuICogQGNhdGVnb3J5IEF0dHJpYnV0ZXNcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqICQoJy5wZWFyJykuaGFzQ2xhc3MoJ3BlYXInKTtcbiAqIC8vPT4gdHJ1ZVxuICpcbiAqICQoJ2FwcGxlJykuaGFzQ2xhc3MoJ2ZydWl0Jyk7XG4gKiAvLz0+IGZhbHNlXG4gKlxuICogJCgnbGknKS5oYXNDbGFzcygncGVhcicpO1xuICogLy89PiB0cnVlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gY2xhc3NOYW1lIC0gTmFtZSBvZiB0aGUgY2xhc3MuXG4gKiBAcmV0dXJucyBJbmRpY2F0ZXMgaWYgYW4gZWxlbWVudCBoYXMgdGhlIGdpdmVuIGBjbGFzc05hbWVgLlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9hcGkuanF1ZXJ5LmNvbS9oYXNDbGFzcy99XG4gKi9cbmZ1bmN0aW9uIGhhc0NsYXNzKGNsYXNzTmFtZSkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5zb21lKChlbGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsYXp6ID0gKDAsIGRvbWhhbmRsZXJfMS5pc1RhZykoZWxlbSkgJiYgZWxlbS5hdHRyaWJzWydjbGFzcyddO1xuICAgICAgICBsZXQgaWR4ID0gLTE7XG4gICAgICAgIGlmIChjbGF6eiAmJiBjbGFzc05hbWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgd2hpbGUgKChpZHggPSBjbGF6ei5pbmRleE9mKGNsYXNzTmFtZSwgaWR4ICsgMSkpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSBpZHggKyBjbGFzc05hbWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmICgoaWR4ID09PSAwIHx8IHJzcGFjZS50ZXN0KGNsYXp6W2lkeCAtIDFdKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKGVuZCA9PT0gY2xhenoubGVuZ3RoIHx8IHJzcGFjZS50ZXN0KGNsYXp6W2VuZF0pKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xufVxuLyoqXG4gKiBBZGRzIGNsYXNzKGVzKSB0byBhbGwgb2YgdGhlIG1hdGNoZWQgZWxlbWVudHMuIEFsc28gYWNjZXB0cyBhIGBmdW5jdGlvbmAuXG4gKlxuICogQGNhdGVnb3J5IEF0dHJpYnV0ZXNcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqICQoJy5wZWFyJykuYWRkQ2xhc3MoJ2ZydWl0JykuaHRtbCgpO1xuICogLy89PiA8bGkgY2xhc3M9XCJwZWFyIGZydWl0XCI+UGVhcjwvbGk+XG4gKlxuICogJCgnLmFwcGxlJykuYWRkQ2xhc3MoJ2ZydWl0IHJlZCcpLmh0bWwoKTtcbiAqIC8vPT4gPGxpIGNsYXNzPVwiYXBwbGUgZnJ1aXQgcmVkXCI+QXBwbGU8L2xpPlxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gTmFtZSBvZiBuZXcgY2xhc3MuXG4gKiBAcmV0dXJucyBUaGUgaW5zdGFuY2UgaXRzZWxmLlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9hcGkuanF1ZXJ5LmNvbS9hZGRDbGFzcy99XG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzKHZhbHVlKSB7XG4gICAgLy8gU3VwcG9ydCBmdW5jdGlvbnNcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiAoMCwgdXRpbHNfanNfMS5kb21FYWNoKSh0aGlzLCAoZWwsIGkpID0+IHtcbiAgICAgICAgICAgIGlmICgoMCwgZG9taGFuZGxlcl8xLmlzVGFnKShlbCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBlbC5hdHRyaWJzWydjbGFzcyddIHx8ICcnO1xuICAgICAgICAgICAgICAgIGFkZENsYXNzLmNhbGwoW2VsXSwgdmFsdWUuY2FsbChlbCwgaSwgY2xhc3NOYW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBSZXR1cm4gaWYgbm8gdmFsdWUgb3Igbm90IGEgc3RyaW5nIG9yIGZ1bmN0aW9uXG4gICAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICBjb25zdCBjbGFzc05hbWVzID0gdmFsdWUuc3BsaXQocnNwYWNlKTtcbiAgICBjb25zdCBudW1FbGVtZW50cyA9IHRoaXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtRWxlbWVudHM7IGkrKykge1xuICAgICAgICBjb25zdCBlbCA9IHRoaXNbaV07XG4gICAgICAgIC8vIElmIHNlbGVjdGVkIGVsZW1lbnQgaXNuJ3QgYSB0YWcsIG1vdmUgb25cbiAgICAgICAgaWYgKCEoMCwgZG9taGFuZGxlcl8xLmlzVGFnKShlbCkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgYWxyZWFkeSBoYXZlIGNsYXNzZXMg4oCUIGFsd2F5cyBzZXQgeG1sTW9kZSB0byBmYWxzZSBoZXJlLCBhcyBpdCBkb2Vzbid0IG1hdHRlciBmb3IgY2xhc3Nlc1xuICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBnZXRBdHRyKGVsLCAnY2xhc3MnLCBmYWxzZSk7XG4gICAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIGxldCBzZXRDbGFzcyA9IGAgJHtjbGFzc05hbWV9IGA7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBjbGFzcyBhbHJlYWR5IGV4aXN0c1xuICAgICAgICAgICAgZm9yIChjb25zdCBjbiBvZiBjbGFzc05hbWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXBwZW5kQ2xhc3MgPSBgJHtjbn0gYDtcbiAgICAgICAgICAgICAgICBpZiAoIXNldENsYXNzLmluY2x1ZGVzKGAgJHthcHBlbmRDbGFzc31gKSlcbiAgICAgICAgICAgICAgICAgICAgc2V0Q2xhc3MgKz0gYXBwZW5kQ2xhc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRBdHRyKGVsLCAnY2xhc3MnLCBzZXRDbGFzcy50cmltKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0QXR0cihlbCwgJ2NsYXNzJywgY2xhc3NOYW1lcy5qb2luKCcgJykudHJpbSgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cbi8qKlxuICogUmVtb3ZlcyBvbmUgb3IgbW9yZSBzcGFjZS1zZXBhcmF0ZWQgY2xhc3NlcyBmcm9tIHRoZSBzZWxlY3RlZCBlbGVtZW50cy4gSWYgbm9cbiAqIGBjbGFzc05hbWVgIGlzIGRlZmluZWQsIGFsbCBjbGFzc2VzIHdpbGwgYmUgcmVtb3ZlZC4gQWxzbyBhY2NlcHRzIGFcbiAqIGBmdW5jdGlvbmAuXG4gKlxuICogQGNhdGVnb3J5IEF0dHJpYnV0ZXNcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqICQoJy5wZWFyJykucmVtb3ZlQ2xhc3MoJ3BlYXInKS5odG1sKCk7XG4gKiAvLz0+IDxsaSBjbGFzcz1cIlwiPlBlYXI8L2xpPlxuICpcbiAqICQoJy5hcHBsZScpLmFkZENsYXNzKCdyZWQnKS5yZW1vdmVDbGFzcygpLmh0bWwoKTtcbiAqIC8vPT4gPGxpIGNsYXNzPVwiXCI+QXBwbGU8L2xpPlxuICogYGBgXG4gKlxuICogQHBhcmFtIG5hbWUgLSBOYW1lIG9mIHRoZSBjbGFzcy4gSWYgbm90IHNwZWNpZmllZCwgcmVtb3ZlcyBhbGwgZWxlbWVudHMuXG4gKiBAcmV0dXJucyBUaGUgaW5zdGFuY2UgaXRzZWxmLlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9hcGkuanF1ZXJ5LmNvbS9yZW1vdmVDbGFzcy99XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzKG5hbWUpIHtcbiAgICAvLyBIYW5kbGUgaWYgdmFsdWUgaXMgYSBmdW5jdGlvblxuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gKDAsIHV0aWxzX2pzXzEuZG9tRWFjaCkodGhpcywgKGVsLCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAoKDAsIGRvbWhhbmRsZXJfMS5pc1RhZykoZWwpKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MuY2FsbChbZWxdLCBuYW1lLmNhbGwoZWwsIGksIGVsLmF0dHJpYnNbJ2NsYXNzJ10gfHwgJycpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGNsYXNzZXMgPSBzcGxpdE5hbWVzKG5hbWUpO1xuICAgIGNvbnN0IG51bUNsYXNzZXMgPSBjbGFzc2VzLmxlbmd0aDtcbiAgICBjb25zdCByZW1vdmVBbGwgPSBhcmd1bWVudHMubGVuZ3RoID09PSAwO1xuICAgIHJldHVybiAoMCwgdXRpbHNfanNfMS5kb21FYWNoKSh0aGlzLCAoZWwpID0+IHtcbiAgICAgICAgaWYgKCEoMCwgZG9taGFuZGxlcl8xLmlzVGFnKShlbCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChyZW1vdmVBbGwpIHtcbiAgICAgICAgICAgIC8vIFNob3J0IGNpcmN1aXQgdGhlIHJlbW92ZSBhbGwgY2FzZSBhcyB0aGlzIGlzIHRoZSBuaWNlIG9uZVxuICAgICAgICAgICAgZWwuYXR0cmlic1snY2xhc3MnXSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZWxDbGFzc2VzID0gc3BsaXROYW1lcyhlbC5hdHRyaWJzWydjbGFzcyddKTtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bUNsYXNzZXM7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZWxDbGFzc2VzLmluZGV4T2YoY2xhc3Nlc1tqXSk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZWxDbGFzc2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgKiBXZSBoYXZlIHRvIGRvIGFub3RoZXIgcGFzcyB0byBlbnN1cmUgdGhhdCB0aGVyZSBhcmUgbm90IGR1cGxpY2F0ZVxuICAgICAgICAgICAgICAgICAgICAgKiBjbGFzc2VzIGxpc3RlZFxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgZWwuYXR0cmlic1snY2xhc3MnXSA9IGVsQ2xhc3Nlcy5qb2luKCcgJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKlxuICogQWRkIG9yIHJlbW92ZSBjbGFzcyhlcykgZnJvbSB0aGUgbWF0Y2hlZCBlbGVtZW50cywgZGVwZW5kaW5nIG9uIGVpdGhlciB0aGVcbiAqIGNsYXNzJ3MgcHJlc2VuY2Ugb3IgdGhlIHZhbHVlIG9mIHRoZSBzd2l0Y2ggYXJndW1lbnQuIEFsc28gYWNjZXB0cyBhXG4gKiBgZnVuY3Rpb25gLlxuICpcbiAqIEBjYXRlZ29yeSBBdHRyaWJ1dGVzXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAkKCcuYXBwbGUuZ3JlZW4nKS50b2dnbGVDbGFzcygnZnJ1aXQgZ3JlZW4gcmVkJykuaHRtbCgpO1xuICogLy89PiA8bGkgY2xhc3M9XCJhcHBsZSBmcnVpdCByZWRcIj5BcHBsZTwvbGk+XG4gKlxuICogJCgnLmFwcGxlLmdyZWVuJykudG9nZ2xlQ2xhc3MoJ2ZydWl0IGdyZWVuIHJlZCcsIHRydWUpLmh0bWwoKTtcbiAqIC8vPT4gPGxpIGNsYXNzPVwiYXBwbGUgZ3JlZW4gZnJ1aXQgcmVkXCI+QXBwbGU8L2xpPlxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gTmFtZSBvZiB0aGUgY2xhc3MuIENhbiBhbHNvIGJlIGEgZnVuY3Rpb24uXG4gKiBAcGFyYW0gc3RhdGVWYWwgLSBJZiBzcGVjaWZpZWQgdGhlIHN0YXRlIG9mIHRoZSBjbGFzcy5cbiAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gKiBAc2VlIHtAbGluayBodHRwczovL2FwaS5qcXVlcnkuY29tL3RvZ2dsZUNsYXNzL31cbiAqL1xuZnVuY3Rpb24gdG9nZ2xlQ2xhc3ModmFsdWUsIHN0YXRlVmFsKSB7XG4gICAgLy8gU3VwcG9ydCBmdW5jdGlvbnNcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiAoMCwgdXRpbHNfanNfMS5kb21FYWNoKSh0aGlzLCAoZWwsIGkpID0+IHtcbiAgICAgICAgICAgIGlmICgoMCwgZG9taGFuZGxlcl8xLmlzVGFnKShlbCkpIHtcbiAgICAgICAgICAgICAgICB0b2dnbGVDbGFzcy5jYWxsKFtlbF0sIHZhbHVlLmNhbGwoZWwsIGksIGVsLmF0dHJpYnNbJ2NsYXNzJ10gfHwgJycsIHN0YXRlVmFsKSwgc3RhdGVWYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gUmV0dXJuIGlmIG5vIHZhbHVlIG9yIG5vdCBhIHN0cmluZyBvciBmdW5jdGlvblxuICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IHZhbHVlLnNwbGl0KHJzcGFjZSk7XG4gICAgY29uc3QgbnVtQ2xhc3NlcyA9IGNsYXNzTmFtZXMubGVuZ3RoO1xuICAgIGNvbnN0IHN0YXRlID0gdHlwZW9mIHN0YXRlVmFsID09PSAnYm9vbGVhbicgPyAoc3RhdGVWYWwgPyAxIDogLTEpIDogMDtcbiAgICBjb25zdCBudW1FbGVtZW50cyA9IHRoaXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtRWxlbWVudHM7IGkrKykge1xuICAgICAgICBjb25zdCBlbCA9IHRoaXNbaV07XG4gICAgICAgIC8vIElmIHNlbGVjdGVkIGVsZW1lbnQgaXNuJ3QgYSB0YWcsIG1vdmUgb25cbiAgICAgICAgaWYgKCEoMCwgZG9taGFuZGxlcl8xLmlzVGFnKShlbCkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgZWxlbWVudENsYXNzZXMgPSBzcGxpdE5hbWVzKGVsLmF0dHJpYnNbJ2NsYXNzJ10pO1xuICAgICAgICAvLyBDaGVjayBpZiBjbGFzcyBhbHJlYWR5IGV4aXN0c1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bUNsYXNzZXM7IGorKykge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNsYXNzIG5hbWUgaXMgY3VycmVudGx5IGRlZmluZWRcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZWxlbWVudENsYXNzZXMuaW5kZXhPZihjbGFzc05hbWVzW2pdKTtcbiAgICAgICAgICAgIC8vIEFkZCBpZiBzdGF0ZVZhbHVlID09PSB0cnVlIG9yIHdlIGFyZSB0b2dnbGluZyBhbmQgdGhlcmUgaXMgbm8gdmFsdWVcbiAgICAgICAgICAgIGlmIChzdGF0ZSA+PSAwICYmIGluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRDbGFzc2VzLnB1c2goY2xhc3NOYW1lc1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdGF0ZSA8PSAwICYmIGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgcmVtb3ZlIGJ1dCBvbmx5IGlmIHRoZSBpdGVtIGV4aXN0c1xuICAgICAgICAgICAgICAgIGVsZW1lbnRDbGFzc2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWwuYXR0cmlic1snY2xhc3MnXSA9IGVsZW1lbnRDbGFzc2VzLmpvaW4oJyAnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdHRyaWJ1dGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/cheerio/dist/commonjs/api/attributes.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/cheerio/dist/commonjs/api/css.js":
/*!*******************************************************!*\
  !*** ./node_modules/cheerio/dist/commonjs/api/css.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.css = css;\nconst utils_js_1 = __webpack_require__(/*! ../utils.js */ \"(rsc)/./node_modules/cheerio/dist/commonjs/utils.js\");\nconst domhandler_1 = __webpack_require__(/*! domhandler */ \"(rsc)/./node_modules/domhandler/lib/index.js\");\n/**\n * Set multiple CSS properties for every matched element.\n *\n * @category CSS\n * @param prop - The names of the properties.\n * @param val - The new values.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/css/}\n */\nfunction css(prop, val) {\n    if ((prop != null && val != null) ||\n        // When `prop` is a \"plain\" object\n        (typeof prop === 'object' && !Array.isArray(prop))) {\n        return (0, utils_js_1.domEach)(this, (el, i) => {\n            if ((0, domhandler_1.isTag)(el)) {\n                // `prop` can't be an array here anymore.\n                setCss(el, prop, val, i);\n            }\n        });\n    }\n    if (this.length === 0) {\n        return undefined;\n    }\n    return getCss(this[0], prop);\n}\n/**\n * Set styles of all elements.\n *\n * @private\n * @param el - Element to set style of.\n * @param prop - Name of property.\n * @param value - Value to set property to.\n * @param idx - Optional index within the selection.\n */\nfunction setCss(el, prop, value, idx) {\n    if (typeof prop === 'string') {\n        const styles = getCss(el);\n        const val = typeof value === 'function' ? value.call(el, idx, styles[prop]) : value;\n        if (val === '') {\n            delete styles[prop];\n        }\n        else if (val != null) {\n            styles[prop] = val;\n        }\n        el.attribs['style'] = stringify(styles);\n    }\n    else if (typeof prop === 'object') {\n        const keys = Object.keys(prop);\n        for (let i = 0; i < keys.length; i++) {\n            const k = keys[i];\n            setCss(el, k, prop[k], i);\n        }\n    }\n}\nfunction getCss(el, prop) {\n    if (!el || !(0, domhandler_1.isTag)(el))\n        return;\n    const styles = parse(el.attribs['style']);\n    if (typeof prop === 'string') {\n        return styles[prop];\n    }\n    if (Array.isArray(prop)) {\n        const newStyles = {};\n        for (const item of prop) {\n            if (styles[item] != null) {\n                newStyles[item] = styles[item];\n            }\n        }\n        return newStyles;\n    }\n    return styles;\n}\n/**\n * Stringify `obj` to styles.\n *\n * @private\n * @category CSS\n * @param obj - Object to stringify.\n * @returns The serialized styles.\n */\nfunction stringify(obj) {\n    return Object.keys(obj).reduce((str, prop) => `${str}${str ? ' ' : ''}${prop}: ${obj[prop]};`, '');\n}\n/**\n * Parse `styles`.\n *\n * @private\n * @category CSS\n * @param styles - Styles to be parsed.\n * @returns The parsed styles.\n */\nfunction parse(styles) {\n    styles = (styles || '').trim();\n    if (!styles)\n        return {};\n    const obj = {};\n    let key;\n    for (const str of styles.split(';')) {\n        const n = str.indexOf(':');\n        // If there is no :, or if it is the first/last character, add to the previous item's value\n        if (n < 1 || n === str.length - 1) {\n            const trimmed = str.trimEnd();\n            if (trimmed.length > 0 && key !== undefined) {\n                obj[key] += `;${trimmed}`;\n            }\n        }\n        else {\n            key = str.slice(0, n).trim();\n            obj[key] = str.slice(n + 1).trim();\n        }\n    }\n    return obj;\n}\n//# sourceMappingURL=css.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2hlZXJpby9kaXN0L2NvbW1vbmpzL2FwaS9jc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsV0FBVztBQUNYLG1CQUFtQixtQkFBTyxDQUFDLHdFQUFhO0FBQ3hDLHFCQUFxQixtQkFBTyxDQUFDLGdFQUFZO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsSUFBSSxFQUFFLGVBQWUsRUFBRSxLQUFLLElBQUksV0FBVztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixFQUFFLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2ltdGl5YXovRGVza3RvcC9TdXBlckxlYXJuL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9jaGVlcmlvL2Rpc3QvY29tbW9uanMvYXBpL2Nzcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3NzID0gY3NzO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy5qc1wiKTtcbmNvbnN0IGRvbWhhbmRsZXJfMSA9IHJlcXVpcmUoXCJkb21oYW5kbGVyXCIpO1xuLyoqXG4gKiBTZXQgbXVsdGlwbGUgQ1NTIHByb3BlcnRpZXMgZm9yIGV2ZXJ5IG1hdGNoZWQgZWxlbWVudC5cbiAqXG4gKiBAY2F0ZWdvcnkgQ1NTXG4gKiBAcGFyYW0gcHJvcCAtIFRoZSBuYW1lcyBvZiB0aGUgcHJvcGVydGllcy5cbiAqIEBwYXJhbSB2YWwgLSBUaGUgbmV3IHZhbHVlcy5cbiAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gKiBAc2VlIHtAbGluayBodHRwczovL2FwaS5qcXVlcnkuY29tL2Nzcy99XG4gKi9cbmZ1bmN0aW9uIGNzcyhwcm9wLCB2YWwpIHtcbiAgICBpZiAoKHByb3AgIT0gbnVsbCAmJiB2YWwgIT0gbnVsbCkgfHxcbiAgICAgICAgLy8gV2hlbiBgcHJvcGAgaXMgYSBcInBsYWluXCIgb2JqZWN0XG4gICAgICAgICh0eXBlb2YgcHJvcCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocHJvcCkpKSB7XG4gICAgICAgIHJldHVybiAoMCwgdXRpbHNfanNfMS5kb21FYWNoKSh0aGlzLCAoZWwsIGkpID0+IHtcbiAgICAgICAgICAgIGlmICgoMCwgZG9taGFuZGxlcl8xLmlzVGFnKShlbCkpIHtcbiAgICAgICAgICAgICAgICAvLyBgcHJvcGAgY2FuJ3QgYmUgYW4gYXJyYXkgaGVyZSBhbnltb3JlLlxuICAgICAgICAgICAgICAgIHNldENzcyhlbCwgcHJvcCwgdmFsLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0Q3NzKHRoaXNbMF0sIHByb3ApO1xufVxuLyoqXG4gKiBTZXQgc3R5bGVzIG9mIGFsbCBlbGVtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIGVsIC0gRWxlbWVudCB0byBzZXQgc3R5bGUgb2YuXG4gKiBAcGFyYW0gcHJvcCAtIE5hbWUgb2YgcHJvcGVydHkuXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBzZXQgcHJvcGVydHkgdG8uXG4gKiBAcGFyYW0gaWR4IC0gT3B0aW9uYWwgaW5kZXggd2l0aGluIHRoZSBzZWxlY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHNldENzcyhlbCwgcHJvcCwgdmFsdWUsIGlkeCkge1xuICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3Qgc3R5bGVzID0gZ2V0Q3NzKGVsKTtcbiAgICAgICAgY29uc3QgdmFsID0gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gdmFsdWUuY2FsbChlbCwgaWR4LCBzdHlsZXNbcHJvcF0pIDogdmFsdWU7XG4gICAgICAgIGlmICh2YWwgPT09ICcnKSB7XG4gICAgICAgICAgICBkZWxldGUgc3R5bGVzW3Byb3BdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzdHlsZXNbcHJvcF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgZWwuYXR0cmlic1snc3R5bGUnXSA9IHN0cmluZ2lmeShzdHlsZXMpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgcHJvcCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb3ApO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGsgPSBrZXlzW2ldO1xuICAgICAgICAgICAgc2V0Q3NzKGVsLCBrLCBwcm9wW2tdLCBpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdldENzcyhlbCwgcHJvcCkge1xuICAgIGlmICghZWwgfHwgISgwLCBkb21oYW5kbGVyXzEuaXNUYWcpKGVsKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHN0eWxlcyA9IHBhcnNlKGVsLmF0dHJpYnNbJ3N0eWxlJ10pO1xuICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlc1twcm9wXTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcCkpIHtcbiAgICAgICAgY29uc3QgbmV3U3R5bGVzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBwcm9wKSB7XG4gICAgICAgICAgICBpZiAoc3R5bGVzW2l0ZW1dICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBuZXdTdHlsZXNbaXRlbV0gPSBzdHlsZXNbaXRlbV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1N0eWxlcztcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlcztcbn1cbi8qKlxuICogU3RyaW5naWZ5IGBvYmpgIHRvIHN0eWxlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNhdGVnb3J5IENTU1xuICogQHBhcmFtIG9iaiAtIE9iamVjdCB0byBzdHJpbmdpZnkuXG4gKiBAcmV0dXJucyBUaGUgc2VyaWFsaXplZCBzdHlsZXMuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeShvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5yZWR1Y2UoKHN0ciwgcHJvcCkgPT4gYCR7c3RyfSR7c3RyID8gJyAnIDogJyd9JHtwcm9wfTogJHtvYmpbcHJvcF19O2AsICcnKTtcbn1cbi8qKlxuICogUGFyc2UgYHN0eWxlc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjYXRlZ29yeSBDU1NcbiAqIEBwYXJhbSBzdHlsZXMgLSBTdHlsZXMgdG8gYmUgcGFyc2VkLlxuICogQHJldHVybnMgVGhlIHBhcnNlZCBzdHlsZXMuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlKHN0eWxlcykge1xuICAgIHN0eWxlcyA9IChzdHlsZXMgfHwgJycpLnRyaW0oKTtcbiAgICBpZiAoIXN0eWxlcylcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgIGxldCBrZXk7XG4gICAgZm9yIChjb25zdCBzdHIgb2Ygc3R5bGVzLnNwbGl0KCc7JykpIHtcbiAgICAgICAgY29uc3QgbiA9IHN0ci5pbmRleE9mKCc6Jyk7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIDosIG9yIGlmIGl0IGlzIHRoZSBmaXJzdC9sYXN0IGNoYXJhY3RlciwgYWRkIHRvIHRoZSBwcmV2aW91cyBpdGVtJ3MgdmFsdWVcbiAgICAgICAgaWYgKG4gPCAxIHx8IG4gPT09IHN0ci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBjb25zdCB0cmltbWVkID0gc3RyLnRyaW1FbmQoKTtcbiAgICAgICAgICAgIGlmICh0cmltbWVkLmxlbmd0aCA+IDAgJiYga2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBvYmpba2V5XSArPSBgOyR7dHJpbW1lZH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAga2V5ID0gc3RyLnNsaWNlKDAsIG4pLnRyaW0oKTtcbiAgICAgICAgICAgIG9ialtrZXldID0gc3RyLnNsaWNlKG4gKyAxKS50cmltKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/cheerio/dist/commonjs/api/css.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/cheerio/dist/commonjs/api/extract.js":
/*!***********************************************************!*\
  !*** ./node_modules/cheerio/dist/commonjs/api/extract.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.extract = extract;\nfunction getExtractDescr(descr) {\n    var _a;\n    if (typeof descr === 'string') {\n        return { selector: descr, value: 'textContent' };\n    }\n    return {\n        selector: descr.selector,\n        value: (_a = descr.value) !== null && _a !== void 0 ? _a : 'textContent',\n    };\n}\n/**\n * Extract multiple values from a document, and store them in an object.\n *\n * @param map - An object containing key-value pairs. The keys are the names of\n *   the properties to be created on the object, and the values are the\n *   selectors to be used to extract the values.\n * @returns An object containing the extracted values.\n */\nfunction extract(map) {\n    const ret = {};\n    for (const key in map) {\n        const descr = map[key];\n        const isArray = Array.isArray(descr);\n        const { selector, value } = getExtractDescr(isArray ? descr[0] : descr);\n        const fn = typeof value === 'function'\n            ? value\n            : typeof value === 'string'\n                ? (el) => this._make(el).prop(value)\n                : (el) => this._make(el).extract(value);\n        if (isArray) {\n            ret[key] = this._findBySelector(selector, Number.POSITIVE_INFINITY)\n                .map((_, el) => fn(el, key, ret))\n                .get();\n        }\n        else {\n            const $ = this._findBySelector(selector, 1);\n            ret[key] = $.length > 0 ? fn($[0], key, ret) : undefined;\n        }\n    }\n    return ret;\n}\n//# sourceMappingURL=extract.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2hlZXJpby9kaXN0L2NvbW1vbmpzL2FwaS9leHRyYWN0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvaW10aXlhei9EZXNrdG9wL1N1cGVyTGVhcm4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2NoZWVyaW8vZGlzdC9jb21tb25qcy9hcGkvZXh0cmFjdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXh0cmFjdCA9IGV4dHJhY3Q7XG5mdW5jdGlvbiBnZXRFeHRyYWN0RGVzY3IoZGVzY3IpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHR5cGVvZiBkZXNjciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHsgc2VsZWN0b3I6IGRlc2NyLCB2YWx1ZTogJ3RleHRDb250ZW50JyB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzZWxlY3RvcjogZGVzY3Iuc2VsZWN0b3IsXG4gICAgICAgIHZhbHVlOiAoX2EgPSBkZXNjci52YWx1ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ3RleHRDb250ZW50JyxcbiAgICB9O1xufVxuLyoqXG4gKiBFeHRyYWN0IG11bHRpcGxlIHZhbHVlcyBmcm9tIGEgZG9jdW1lbnQsIGFuZCBzdG9yZSB0aGVtIGluIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gbWFwIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcga2V5LXZhbHVlIHBhaXJzLiBUaGUga2V5cyBhcmUgdGhlIG5hbWVzIG9mXG4gKiAgIHRoZSBwcm9wZXJ0aWVzIHRvIGJlIGNyZWF0ZWQgb24gdGhlIG9iamVjdCwgYW5kIHRoZSB2YWx1ZXMgYXJlIHRoZVxuICogICBzZWxlY3RvcnMgdG8gYmUgdXNlZCB0byBleHRyYWN0IHRoZSB2YWx1ZXMuXG4gKiBAcmV0dXJucyBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgZXh0cmFjdGVkIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdChtYXApIHtcbiAgICBjb25zdCByZXQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBtYXApIHtcbiAgICAgICAgY29uc3QgZGVzY3IgPSBtYXBba2V5XTtcbiAgICAgICAgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoZGVzY3IpO1xuICAgICAgICBjb25zdCB7IHNlbGVjdG9yLCB2YWx1ZSB9ID0gZ2V0RXh0cmFjdERlc2NyKGlzQXJyYXkgPyBkZXNjclswXSA6IGRlc2NyKTtcbiAgICAgICAgY29uc3QgZm4gPSB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gdmFsdWVcbiAgICAgICAgICAgIDogdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgID8gKGVsKSA9PiB0aGlzLl9tYWtlKGVsKS5wcm9wKHZhbHVlKVxuICAgICAgICAgICAgICAgIDogKGVsKSA9PiB0aGlzLl9tYWtlKGVsKS5leHRyYWN0KHZhbHVlKTtcbiAgICAgICAgaWYgKGlzQXJyYXkpIHtcbiAgICAgICAgICAgIHJldFtrZXldID0gdGhpcy5fZmluZEJ5U2VsZWN0b3Ioc2VsZWN0b3IsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSlcbiAgICAgICAgICAgICAgICAubWFwKChfLCBlbCkgPT4gZm4oZWwsIGtleSwgcmV0KSlcbiAgICAgICAgICAgICAgICAuZ2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCAkID0gdGhpcy5fZmluZEJ5U2VsZWN0b3Ioc2VsZWN0b3IsIDEpO1xuICAgICAgICAgICAgcmV0W2tleV0gPSAkLmxlbmd0aCA+IDAgPyBmbigkWzBdLCBrZXksIHJldCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dHJhY3QuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/cheerio/dist/commonjs/api/extract.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/cheerio/dist/commonjs/api/forms.js":
/*!*********************************************************!*\
  !*** ./node_modules/cheerio/dist/commonjs/api/forms.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.serialize = serialize;\nexports.serializeArray = serializeArray;\nconst domhandler_1 = __webpack_require__(/*! domhandler */ \"(rsc)/./node_modules/domhandler/lib/index.js\");\n/*\n * https://github.com/jquery/jquery/blob/2.1.3/src/manipulation/var/rcheckableType.js\n * https://github.com/jquery/jquery/blob/2.1.3/src/serialize.js\n */\nconst submittableSelector = 'input,select,textarea,keygen';\nconst r20 = /%20/g;\nconst rCRLF = /\\r?\\n/g;\n/**\n * Encode a set of form elements as a string for submission.\n *\n * @category Forms\n * @example\n *\n * ```js\n * $('<form><input name=\"foo\" value=\"bar\" /></form>').serialize();\n * //=> 'foo=bar'\n * ```\n *\n * @returns The serialized form.\n * @see {@link https://api.jquery.com/serialize/}\n */\nfunction serialize() {\n    // Convert form elements into name/value objects\n    const arr = this.serializeArray();\n    // Serialize each element into a key/value string\n    const retArr = arr.map((data) => `${encodeURIComponent(data.name)}=${encodeURIComponent(data.value)}`);\n    // Return the resulting serialization\n    return retArr.join('&').replace(r20, '+');\n}\n/**\n * Encode a set of form elements as an array of names and values.\n *\n * @category Forms\n * @example\n *\n * ```js\n * $('<form><input name=\"foo\" value=\"bar\" /></form>').serializeArray();\n * //=> [ { name: 'foo', value: 'bar' } ]\n * ```\n *\n * @returns The serialized form.\n * @see {@link https://api.jquery.com/serializeArray/}\n */\nfunction serializeArray() {\n    // Resolve all form elements from either forms or collections of form elements\n    return this.map((_, elem) => {\n        const $elem = this._make(elem);\n        if ((0, domhandler_1.isTag)(elem) && elem.name === 'form') {\n            return $elem.find(submittableSelector).toArray();\n        }\n        return $elem.filter(submittableSelector).toArray();\n    })\n        .filter(\n    // Verify elements have a name (`attr.name`) and are not disabled (`:enabled`)\n    '[name!=\"\"]:enabled' +\n        // And cannot be clicked (`[type=submit]`) or are used in `x-www-form-urlencoded` (`[type=file]`)\n        ':not(:submit, :button, :image, :reset, :file)' +\n        // And are either checked/don't have a checkable state\n        ':matches([checked], :not(:checkbox, :radio))')\n        .map((_, elem) => {\n        var _a;\n        const $elem = this._make(elem);\n        const name = $elem.attr('name'); // We have filtered for elements with a name before.\n        // If there is no value set (e.g. `undefined`, `null`), then default value to empty\n        const value = (_a = $elem.val()) !== null && _a !== void 0 ? _a : '';\n        // If we have an array of values (e.g. `<select multiple>`), return an array of key/value pairs\n        if (Array.isArray(value)) {\n            return value.map((val) => \n            /*\n             * We trim replace any line endings (e.g. `\\r` or `\\r\\n` with `\\r\\n`) to guarantee consistency across platforms\n             * These can occur inside of `<textarea>'s`\n             */\n            ({ name, value: val.replace(rCRLF, '\\r\\n') }));\n        }\n        // Otherwise (e.g. `<input type=\"text\">`, return only one key/value pair\n        return { name, value: value.replace(rCRLF, '\\r\\n') };\n    })\n        .toArray();\n}\n//# sourceMappingURL=forms.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2hlZXJpby9kaXN0L2NvbW1vbmpzL2FwaS9mb3Jtcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsc0JBQXNCO0FBQ3RCLHFCQUFxQixtQkFBTyxDQUFDLGdFQUFZO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsOEJBQThCLEdBQUcsK0JBQStCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRCQUE0QjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUNBQXlDO0FBQ3hEO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvaW10aXlhei9EZXNrdG9wL1N1cGVyTGVhcm4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2NoZWVyaW8vZGlzdC9jb21tb25qcy9hcGkvZm9ybXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNlcmlhbGl6ZSA9IHNlcmlhbGl6ZTtcbmV4cG9ydHMuc2VyaWFsaXplQXJyYXkgPSBzZXJpYWxpemVBcnJheTtcbmNvbnN0IGRvbWhhbmRsZXJfMSA9IHJlcXVpcmUoXCJkb21oYW5kbGVyXCIpO1xuLypcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L2Jsb2IvMi4xLjMvc3JjL21hbmlwdWxhdGlvbi92YXIvcmNoZWNrYWJsZVR5cGUuanNcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L2Jsb2IvMi4xLjMvc3JjL3NlcmlhbGl6ZS5qc1xuICovXG5jb25zdCBzdWJtaXR0YWJsZVNlbGVjdG9yID0gJ2lucHV0LHNlbGVjdCx0ZXh0YXJlYSxrZXlnZW4nO1xuY29uc3QgcjIwID0gLyUyMC9nO1xuY29uc3QgckNSTEYgPSAvXFxyP1xcbi9nO1xuLyoqXG4gKiBFbmNvZGUgYSBzZXQgb2YgZm9ybSBlbGVtZW50cyBhcyBhIHN0cmluZyBmb3Igc3VibWlzc2lvbi5cbiAqXG4gKiBAY2F0ZWdvcnkgRm9ybXNcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqICQoJzxmb3JtPjxpbnB1dCBuYW1lPVwiZm9vXCIgdmFsdWU9XCJiYXJcIiAvPjwvZm9ybT4nKS5zZXJpYWxpemUoKTtcbiAqIC8vPT4gJ2Zvbz1iYXInXG4gKiBgYGBcbiAqXG4gKiBAcmV0dXJucyBUaGUgc2VyaWFsaXplZCBmb3JtLlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9hcGkuanF1ZXJ5LmNvbS9zZXJpYWxpemUvfVxuICovXG5mdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgLy8gQ29udmVydCBmb3JtIGVsZW1lbnRzIGludG8gbmFtZS92YWx1ZSBvYmplY3RzXG4gICAgY29uc3QgYXJyID0gdGhpcy5zZXJpYWxpemVBcnJheSgpO1xuICAgIC8vIFNlcmlhbGl6ZSBlYWNoIGVsZW1lbnQgaW50byBhIGtleS92YWx1ZSBzdHJpbmdcbiAgICBjb25zdCByZXRBcnIgPSBhcnIubWFwKChkYXRhKSA9PiBgJHtlbmNvZGVVUklDb21wb25lbnQoZGF0YS5uYW1lKX09JHtlbmNvZGVVUklDb21wb25lbnQoZGF0YS52YWx1ZSl9YCk7XG4gICAgLy8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuICAgIHJldHVybiByZXRBcnIuam9pbignJicpLnJlcGxhY2UocjIwLCAnKycpO1xufVxuLyoqXG4gKiBFbmNvZGUgYSBzZXQgb2YgZm9ybSBlbGVtZW50cyBhcyBhbiBhcnJheSBvZiBuYW1lcyBhbmQgdmFsdWVzLlxuICpcbiAqIEBjYXRlZ29yeSBGb3Jtc1xuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogJCgnPGZvcm0+PGlucHV0IG5hbWU9XCJmb29cIiB2YWx1ZT1cImJhclwiIC8+PC9mb3JtPicpLnNlcmlhbGl6ZUFycmF5KCk7XG4gKiAvLz0+IFsgeyBuYW1lOiAnZm9vJywgdmFsdWU6ICdiYXInIH0gXVxuICogYGBgXG4gKlxuICogQHJldHVybnMgVGhlIHNlcmlhbGl6ZWQgZm9ybS5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vYXBpLmpxdWVyeS5jb20vc2VyaWFsaXplQXJyYXkvfVxuICovXG5mdW5jdGlvbiBzZXJpYWxpemVBcnJheSgpIHtcbiAgICAvLyBSZXNvbHZlIGFsbCBmb3JtIGVsZW1lbnRzIGZyb20gZWl0aGVyIGZvcm1zIG9yIGNvbGxlY3Rpb25zIG9mIGZvcm0gZWxlbWVudHNcbiAgICByZXR1cm4gdGhpcy5tYXAoKF8sIGVsZW0pID0+IHtcbiAgICAgICAgY29uc3QgJGVsZW0gPSB0aGlzLl9tYWtlKGVsZW0pO1xuICAgICAgICBpZiAoKDAsIGRvbWhhbmRsZXJfMS5pc1RhZykoZWxlbSkgJiYgZWxlbS5uYW1lID09PSAnZm9ybScpIHtcbiAgICAgICAgICAgIHJldHVybiAkZWxlbS5maW5kKHN1Ym1pdHRhYmxlU2VsZWN0b3IpLnRvQXJyYXkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJGVsZW0uZmlsdGVyKHN1Ym1pdHRhYmxlU2VsZWN0b3IpLnRvQXJyYXkoKTtcbiAgICB9KVxuICAgICAgICAuZmlsdGVyKFxuICAgIC8vIFZlcmlmeSBlbGVtZW50cyBoYXZlIGEgbmFtZSAoYGF0dHIubmFtZWApIGFuZCBhcmUgbm90IGRpc2FibGVkIChgOmVuYWJsZWRgKVxuICAgICdbbmFtZSE9XCJcIl06ZW5hYmxlZCcgK1xuICAgICAgICAvLyBBbmQgY2Fubm90IGJlIGNsaWNrZWQgKGBbdHlwZT1zdWJtaXRdYCkgb3IgYXJlIHVzZWQgaW4gYHgtd3d3LWZvcm0tdXJsZW5jb2RlZGAgKGBbdHlwZT1maWxlXWApXG4gICAgICAgICc6bm90KDpzdWJtaXQsIDpidXR0b24sIDppbWFnZSwgOnJlc2V0LCA6ZmlsZSknICtcbiAgICAgICAgLy8gQW5kIGFyZSBlaXRoZXIgY2hlY2tlZC9kb24ndCBoYXZlIGEgY2hlY2thYmxlIHN0YXRlXG4gICAgICAgICc6bWF0Y2hlcyhbY2hlY2tlZF0sIDpub3QoOmNoZWNrYm94LCA6cmFkaW8pKScpXG4gICAgICAgIC5tYXAoKF8sIGVsZW0pID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCAkZWxlbSA9IHRoaXMuX21ha2UoZWxlbSk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSAkZWxlbS5hdHRyKCduYW1lJyk7IC8vIFdlIGhhdmUgZmlsdGVyZWQgZm9yIGVsZW1lbnRzIHdpdGggYSBuYW1lIGJlZm9yZS5cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gdmFsdWUgc2V0IChlLmcuIGB1bmRlZmluZWRgLCBgbnVsbGApLCB0aGVuIGRlZmF1bHQgdmFsdWUgdG8gZW1wdHlcbiAgICAgICAgY29uc3QgdmFsdWUgPSAoX2EgPSAkZWxlbS52YWwoKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJyc7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYW4gYXJyYXkgb2YgdmFsdWVzIChlLmcuIGA8c2VsZWN0IG11bHRpcGxlPmApLCByZXR1cm4gYW4gYXJyYXkgb2Yga2V5L3ZhbHVlIHBhaXJzXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodmFsKSA9PiBcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBXZSB0cmltIHJlcGxhY2UgYW55IGxpbmUgZW5kaW5ncyAoZS5nLiBgXFxyYCBvciBgXFxyXFxuYCB3aXRoIGBcXHJcXG5gKSB0byBndWFyYW50ZWUgY29uc2lzdGVuY3kgYWNyb3NzIHBsYXRmb3Jtc1xuICAgICAgICAgICAgICogVGhlc2UgY2FuIG9jY3VyIGluc2lkZSBvZiBgPHRleHRhcmVhPidzYFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAoeyBuYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UockNSTEYsICdcXHJcXG4nKSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlIChlLmcuIGA8aW5wdXQgdHlwZT1cInRleHRcIj5gLCByZXR1cm4gb25seSBvbmUga2V5L3ZhbHVlIHBhaXJcbiAgICAgICAgcmV0dXJuIHsgbmFtZSwgdmFsdWU6IHZhbHVlLnJlcGxhY2UockNSTEYsICdcXHJcXG4nKSB9O1xuICAgIH0pXG4gICAgICAgIC50b0FycmF5KCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3Jtcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/cheerio/dist/commonjs/api/forms.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/cheerio/dist/commonjs/api/manipulation.js":
/*!****************************************************************!*\
  !*** ./node_modules/cheerio/dist/commonjs/api/manipulation.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Methods for modifying the DOM structure.\n *\n * @module cheerio/manipulation\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.wrapInner = exports.wrap = exports.prepend = exports.append = void 0;\nexports._makeDomArray = _makeDomArray;\nexports.appendTo = appendTo;\nexports.prependTo = prependTo;\nexports.unwrap = unwrap;\nexports.wrapAll = wrapAll;\nexports.after = after;\nexports.insertAfter = insertAfter;\nexports.before = before;\nexports.insertBefore = insertBefore;\nexports.remove = remove;\nexports.replaceWith = replaceWith;\nexports.empty = empty;\nexports.html = html;\nexports.toString = toString;\nexports.text = text;\nexports.clone = clone;\nconst domhandler_1 = __webpack_require__(/*! domhandler */ \"(rsc)/./node_modules/domhandler/lib/index.js\");\nconst parse_js_1 = __webpack_require__(/*! ../parse.js */ \"(rsc)/./node_modules/cheerio/dist/commonjs/parse.js\");\nconst static_js_1 = __webpack_require__(/*! ../static.js */ \"(rsc)/./node_modules/cheerio/dist/commonjs/static.js\");\nconst utils_js_1 = __webpack_require__(/*! ../utils.js */ \"(rsc)/./node_modules/cheerio/dist/commonjs/utils.js\");\nconst domutils_1 = __webpack_require__(/*! domutils */ \"(rsc)/./node_modules/domutils/lib/index.js\");\n/**\n * Create an array of nodes, recursing into arrays and parsing strings if\n * necessary.\n *\n * @private\n * @category Manipulation\n * @param elem - Elements to make an array of.\n * @param clone - Optionally clone nodes.\n * @returns The array of nodes.\n */\nfunction _makeDomArray(elem, clone) {\n    if (elem == null) {\n        return [];\n    }\n    if (typeof elem === 'string') {\n        return this._parse(elem, this.options, false, null).children.slice(0);\n    }\n    if ('length' in elem) {\n        if (elem.length === 1) {\n            return this._makeDomArray(elem[0], clone);\n        }\n        const result = [];\n        for (let i = 0; i < elem.length; i++) {\n            const el = elem[i];\n            if (typeof el === 'object') {\n                if (el == null) {\n                    continue;\n                }\n                if (!('length' in el)) {\n                    result.push(clone ? (0, domhandler_1.cloneNode)(el, true) : el);\n                    continue;\n                }\n            }\n            result.push(...this._makeDomArray(el, clone));\n        }\n        return result;\n    }\n    return [clone ? (0, domhandler_1.cloneNode)(elem, true) : elem];\n}\nfunction _insert(concatenator) {\n    return function (...elems) {\n        const lastIdx = this.length - 1;\n        return (0, utils_js_1.domEach)(this, (el, i) => {\n            if (!(0, domhandler_1.hasChildren)(el))\n                return;\n            const domSrc = typeof elems[0] === 'function'\n                ? elems[0].call(el, i, this._render(el.children))\n                : elems;\n            const dom = this._makeDomArray(domSrc, i < lastIdx);\n            concatenator(dom, el.children, el);\n        });\n    };\n}\n/**\n * Modify an array in-place, removing some number of elements and adding new\n * elements directly following them.\n *\n * @private\n * @category Manipulation\n * @param array - Target array to splice.\n * @param spliceIdx - Index at which to begin changing the array.\n * @param spliceCount - Number of elements to remove from the array.\n * @param newElems - Elements to insert into the array.\n * @param parent - The parent of the node.\n * @returns The spliced array.\n */\nfunction uniqueSplice(array, spliceIdx, spliceCount, newElems, parent) {\n    var _a, _b;\n    const spliceArgs = [\n        spliceIdx,\n        spliceCount,\n        ...newElems,\n    ];\n    const prev = spliceIdx === 0 ? null : array[spliceIdx - 1];\n    const next = spliceIdx + spliceCount >= array.length\n        ? null\n        : array[spliceIdx + spliceCount];\n    /*\n     * Before splicing in new elements, ensure they do not already appear in the\n     * current array.\n     */\n    for (let idx = 0; idx < newElems.length; ++idx) {\n        const node = newElems[idx];\n        const oldParent = node.parent;\n        if (oldParent) {\n            const oldSiblings = oldParent.children;\n            const prevIdx = oldSiblings.indexOf(node);\n            if (prevIdx > -1) {\n                oldParent.children.splice(prevIdx, 1);\n                if (parent === oldParent && spliceIdx > prevIdx) {\n                    spliceArgs[0]--;\n                }\n            }\n        }\n        node.parent = parent;\n        if (node.prev) {\n            node.prev.next = (_a = node.next) !== null && _a !== void 0 ? _a : null;\n        }\n        if (node.next) {\n            node.next.prev = (_b = node.prev) !== null && _b !== void 0 ? _b : null;\n        }\n        node.prev = idx === 0 ? prev : newElems[idx - 1];\n        node.next = idx === newElems.length - 1 ? next : newElems[idx + 1];\n    }\n    if (prev) {\n        prev.next = newElems[0];\n    }\n    if (next) {\n        next.prev = newElems[newElems.length - 1];\n    }\n    return array.splice(...spliceArgs);\n}\n/**\n * Insert every element in the set of matched elements to the end of the target.\n *\n * @category Manipulation\n * @example\n *\n * ```js\n * $('<li class=\"plum\">Plum</li>').appendTo('#fruits');\n * $.html();\n * //=>  <ul id=\"fruits\">\n * //      <li class=\"apple\">Apple</li>\n * //      <li class=\"orange\">Orange</li>\n * //      <li class=\"pear\">Pear</li>\n * //      <li class=\"plum\">Plum</li>\n * //    </ul>\n * ```\n *\n * @param target - Element to append elements to.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/appendTo/}\n */\nfunction appendTo(target) {\n    const appendTarget = (0, utils_js_1.isCheerio)(target) ? target : this._make(target);\n    appendTarget.append(this);\n    return this;\n}\n/**\n * Insert every element in the set of matched elements to the beginning of the\n * target.\n *\n * @category Manipulation\n * @example\n *\n * ```js\n * $('<li class=\"plum\">Plum</li>').prependTo('#fruits');\n * $.html();\n * //=>  <ul id=\"fruits\">\n * //      <li class=\"plum\">Plum</li>\n * //      <li class=\"apple\">Apple</li>\n * //      <li class=\"orange\">Orange</li>\n * //      <li class=\"pear\">Pear</li>\n * //    </ul>\n * ```\n *\n * @param target - Element to prepend elements to.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/prependTo/}\n */\nfunction prependTo(target) {\n    const prependTarget = (0, utils_js_1.isCheerio)(target) ? target : this._make(target);\n    prependTarget.prepend(this);\n    return this;\n}\n/**\n * Inserts content as the _last_ child of each of the selected elements.\n *\n * @category Manipulation\n * @example\n *\n * ```js\n * $('ul').append('<li class=\"plum\">Plum</li>');\n * $.html();\n * //=>  <ul id=\"fruits\">\n * //      <li class=\"apple\">Apple</li>\n * //      <li class=\"orange\">Orange</li>\n * //      <li class=\"pear\">Pear</li>\n * //      <li class=\"plum\">Plum</li>\n * //    </ul>\n * ```\n *\n * @see {@link https://api.jquery.com/append/}\n */\nexports.append = _insert((dom, children, parent) => {\n    uniqueSplice(children, children.length, 0, dom, parent);\n});\n/**\n * Inserts content as the _first_ child of each of the selected elements.\n *\n * @category Manipulation\n * @example\n *\n * ```js\n * $('ul').prepend('<li class=\"plum\">Plum</li>');\n * $.html();\n * //=>  <ul id=\"fruits\">\n * //      <li class=\"plum\">Plum</li>\n * //      <li class=\"apple\">Apple</li>\n * //      <li class=\"orange\">Orange</li>\n * //      <li class=\"pear\">Pear</li>\n * //    </ul>\n * ```\n *\n * @see {@link https://api.jquery.com/prepend/}\n */\nexports.prepend = _insert((dom, children, parent) => {\n    uniqueSplice(children, 0, 0, dom, parent);\n});\nfunction _wrap(insert) {\n    return function (wrapper) {\n        const lastIdx = this.length - 1;\n        const lastParent = this.parents().last();\n        for (let i = 0; i < this.length; i++) {\n            const el = this[i];\n            const wrap = typeof wrapper === 'function'\n                ? wrapper.call(el, i, el)\n                : typeof wrapper === 'string' && !(0, utils_js_1.isHtml)(wrapper)\n                    ? lastParent.find(wrapper).clone()\n                    : wrapper;\n            const [wrapperDom] = this._makeDomArray(wrap, i < lastIdx);\n            if (!wrapperDom || !(0, domhandler_1.hasChildren)(wrapperDom))\n                continue;\n            let elInsertLocation = wrapperDom;\n            /*\n             * Find the deepest child. Only consider the first tag child of each node\n             * (ignore text); stop if no children are found.\n             */\n            let j = 0;\n            while (j < elInsertLocation.children.length) {\n                const child = elInsertLocation.children[j];\n                if ((0, domhandler_1.isTag)(child)) {\n                    elInsertLocation = child;\n                    j = 0;\n                }\n                else {\n                    j++;\n                }\n            }\n            insert(el, elInsertLocation, [wrapperDom]);\n        }\n        return this;\n    };\n}\n/**\n * The .wrap() function can take any string or object that could be passed to\n * the $() factory function to specify a DOM structure. This structure may be\n * nested several levels deep, but should contain only one inmost element. A\n * copy of this structure will be wrapped around each of the elements in the set\n * of matched elements. This method returns the original set of elements for\n * chaining purposes.\n *\n * @category Manipulation\n * @example\n *\n * ```js\n * const redFruit = $('<div class=\"red-fruit\"></div>');\n * $('.apple').wrap(redFruit);\n *\n * //=> <ul id=\"fruits\">\n * //     <div class=\"red-fruit\">\n * //      <li class=\"apple\">Apple</li>\n * //     </div>\n * //     <li class=\"orange\">Orange</li>\n * //     <li class=\"plum\">Plum</li>\n * //   </ul>\n *\n * const healthy = $('<div class=\"healthy\"></div>');\n * $('li').wrap(healthy);\n *\n * //=> <ul id=\"fruits\">\n * //     <div class=\"healthy\">\n * //       <li class=\"apple\">Apple</li>\n * //     </div>\n * //     <div class=\"healthy\">\n * //       <li class=\"orange\">Orange</li>\n * //     </div>\n * //     <div class=\"healthy\">\n * //        <li class=\"plum\">Plum</li>\n * //     </div>\n * //   </ul>\n * ```\n *\n * @param wrapper - The DOM structure to wrap around each element in the\n *   selection.\n * @see {@link https://api.jquery.com/wrap/}\n */\nexports.wrap = _wrap((el, elInsertLocation, wrapperDom) => {\n    const { parent } = el;\n    if (!parent)\n        return;\n    const siblings = parent.children;\n    const index = siblings.indexOf(el);\n    (0, parse_js_1.update)([el], elInsertLocation);\n    /*\n     * The previous operation removed the current element from the `siblings`\n     * array, so the `dom` array can be inserted without removing any\n     * additional elements.\n     */\n    uniqueSplice(siblings, index, 0, wrapperDom, parent);\n});\n/**\n * The .wrapInner() function can take any string or object that could be passed\n * to the $() factory function to specify a DOM structure. This structure may be\n * nested several levels deep, but should contain only one inmost element. The\n * structure will be wrapped around the content of each of the elements in the\n * set of matched elements.\n *\n * @category Manipulation\n * @example\n *\n * ```js\n * const redFruit = $('<div class=\"red-fruit\"></div>');\n * $('.apple').wrapInner(redFruit);\n *\n * //=> <ul id=\"fruits\">\n * //     <li class=\"apple\">\n * //       <div class=\"red-fruit\">Apple</div>\n * //     </li>\n * //     <li class=\"orange\">Orange</li>\n * //     <li class=\"pear\">Pear</li>\n * //   </ul>\n *\n * const healthy = $('<div class=\"healthy\"></div>');\n * $('li').wrapInner(healthy);\n *\n * //=> <ul id=\"fruits\">\n * //     <li class=\"apple\">\n * //       <div class=\"healthy\">Apple</div>\n * //     </li>\n * //     <li class=\"orange\">\n * //       <div class=\"healthy\">Orange</div>\n * //     </li>\n * //     <li class=\"pear\">\n * //       <div class=\"healthy\">Pear</div>\n * //     </li>\n * //   </ul>\n * ```\n *\n * @param wrapper - The DOM structure to wrap around the content of each element\n *   in the selection.\n * @returns The instance itself, for chaining.\n * @see {@link https://api.jquery.com/wrapInner/}\n */\nexports.wrapInner = _wrap((el, elInsertLocation, wrapperDom) => {\n    if (!(0, domhandler_1.hasChildren)(el))\n        return;\n    (0, parse_js_1.update)(el.children, elInsertLocation);\n    (0, parse_js_1.update)(wrapperDom, el);\n});\n/**\n * The .unwrap() function, removes the parents of the set of matched elements\n * from the DOM, leaving the matched elements in their place.\n *\n * @category Manipulation\n * @example <caption>without selector</caption>\n *\n * ```js\n * const $ = cheerio.load(\n *   '<div id=test>\\n  <div><p>Hello</p></div>\\n  <div><p>World</p></div>\\n</div>',\n * );\n * $('#test p').unwrap();\n *\n * //=> <div id=test>\n * //     <p>Hello</p>\n * //     <p>World</p>\n * //   </div>\n * ```\n *\n * @example <caption>with selector</caption>\n *\n * ```js\n * const $ = cheerio.load(\n *   '<div id=test>\\n  <p>Hello</p>\\n  <b><p>World</p></b>\\n</div>',\n * );\n * $('#test p').unwrap('b');\n *\n * //=> <div id=test>\n * //     <p>Hello</p>\n * //     <p>World</p>\n * //   </div>\n * ```\n *\n * @param selector - A selector to check the parent element against. If an\n *   element's parent does not match the selector, the element won't be\n *   unwrapped.\n * @returns The instance itself, for chaining.\n * @see {@link https://api.jquery.com/unwrap/}\n */\nfunction unwrap(selector) {\n    this.parent(selector)\n        .not('body')\n        .each((_, el) => {\n        this._make(el).replaceWith(el.children);\n    });\n    return this;\n}\n/**\n * The .wrapAll() function can take any string or object that could be passed to\n * the $() function to specify a DOM structure. This structure may be nested\n * several levels deep, but should contain only one inmost element. The\n * structure will be wrapped around all of the elements in the set of matched\n * elements, as a single group.\n *\n * @category Manipulation\n * @example <caption>With markup passed to `wrapAll`</caption>\n *\n * ```js\n * const $ = cheerio.load(\n *   '<div class=\"container\"><div class=\"inner\">First</div><div class=\"inner\">Second</div></div>',\n * );\n * $('.inner').wrapAll(\"<div class='new'></div>\");\n *\n * //=> <div class=\"container\">\n * //     <div class='new'>\n * //       <div class=\"inner\">First</div>\n * //       <div class=\"inner\">Second</div>\n * //     </div>\n * //   </div>\n * ```\n *\n * @example <caption>With an existing cheerio instance</caption>\n *\n * ```js\n * const $ = cheerio.load(\n *   '<span>Span 1</span><strong>Strong</strong><span>Span 2</span>',\n * );\n * const wrap = $('<div><p><em><b></b></em></p></div>');\n * $('span').wrapAll(wrap);\n *\n * //=> <div>\n * //     <p>\n * //       <em>\n * //         <b>\n * //           <span>Span 1</span>\n * //           <span>Span 2</span>\n * //         </b>\n * //       </em>\n * //     </p>\n * //   </div>\n * //   <strong>Strong</strong>\n * ```\n *\n * @param wrapper - The DOM structure to wrap around all matched elements in the\n *   selection.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/wrapAll/}\n */\nfunction wrapAll(wrapper) {\n    const el = this[0];\n    if (el) {\n        const wrap = this._make(typeof wrapper === 'function' ? wrapper.call(el, 0, el) : wrapper).insertBefore(el);\n        // If html is given as wrapper, wrap may contain text elements\n        let elInsertLocation;\n        for (let i = 0; i < wrap.length; i++) {\n            if (wrap[i].type === 'tag')\n                elInsertLocation = wrap[i];\n        }\n        let j = 0;\n        /*\n         * Find the deepest child. Only consider the first tag child of each node\n         * (ignore text); stop if no children are found.\n         */\n        while (elInsertLocation && j < elInsertLocation.children.length) {\n            const child = elInsertLocation.children[j];\n            if (child.type === 'tag') {\n                elInsertLocation = child;\n                j = 0;\n            }\n            else {\n                j++;\n            }\n        }\n        if (elInsertLocation)\n            this._make(elInsertLocation).append(this);\n    }\n    return this;\n}\n/**\n * Insert content next to each element in the set of matched elements.\n *\n * @category Manipulation\n * @example\n *\n * ```js\n * $('.apple').after('<li class=\"plum\">Plum</li>');\n * $.html();\n * //=>  <ul id=\"fruits\">\n * //      <li class=\"apple\">Apple</li>\n * //      <li class=\"plum\">Plum</li>\n * //      <li class=\"orange\">Orange</li>\n * //      <li class=\"pear\">Pear</li>\n * //    </ul>\n * ```\n *\n * @param elems - HTML string, DOM element, array of DOM elements or Cheerio to\n *   insert after each element in the set of matched elements.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/after/}\n */\nfunction after(...elems) {\n    const lastIdx = this.length - 1;\n    return (0, utils_js_1.domEach)(this, (el, i) => {\n        if (!(0, domhandler_1.hasChildren)(el) || !el.parent) {\n            return;\n        }\n        const siblings = el.parent.children;\n        const index = siblings.indexOf(el);\n        // If not found, move on\n        /* istanbul ignore next */\n        if (index < 0)\n            return;\n        const domSrc = typeof elems[0] === 'function'\n            ? elems[0].call(el, i, this._render(el.children))\n            : elems;\n        const dom = this._makeDomArray(domSrc, i < lastIdx);\n        // Add element after `this` element\n        uniqueSplice(siblings, index + 1, 0, dom, el.parent);\n    });\n}\n/**\n * Insert every element in the set of matched elements after the target.\n *\n * @category Manipulation\n * @example\n *\n * ```js\n * $('<li class=\"plum\">Plum</li>').insertAfter('.apple');\n * $.html();\n * //=>  <ul id=\"fruits\">\n * //      <li class=\"apple\">Apple</li>\n * //      <li class=\"plum\">Plum</li>\n * //      <li class=\"orange\">Orange</li>\n * //      <li class=\"pear\">Pear</li>\n * //    </ul>\n * ```\n *\n * @param target - Element to insert elements after.\n * @returns The set of newly inserted elements.\n * @see {@link https://api.jquery.com/insertAfter/}\n */\nfunction insertAfter(target) {\n    if (typeof target === 'string') {\n        target = this._make(target);\n    }\n    this.remove();\n    const clones = [];\n    for (const el of this._makeDomArray(target)) {\n        const clonedSelf = this.clone().toArray();\n        const { parent } = el;\n        if (!parent) {\n            continue;\n        }\n        const siblings = parent.children;\n        const index = siblings.indexOf(el);\n        // If not found, move on\n        /* istanbul ignore next */\n        if (index < 0)\n            continue;\n        // Add cloned `this` element(s) after target element\n        uniqueSplice(siblings, index + 1, 0, clonedSelf, parent);\n        clones.push(...clonedSelf);\n    }\n    return this._make(clones);\n}\n/**\n * Insert content previous to each element in the set of matched elements.\n *\n * @category Manipulation\n * @example\n *\n * ```js\n * $('.apple').before('<li class=\"plum\">Plum</li>');\n * $.html();\n * //=>  <ul id=\"fruits\">\n * //      <li class=\"plum\">Plum</li>\n * //      <li class=\"apple\">Apple</li>\n * //      <li class=\"orange\">Orange</li>\n * //      <li class=\"pear\">Pear</li>\n * //    </ul>\n * ```\n *\n * @param elems - HTML string, DOM element, array of DOM elements or Cheerio to\n *   insert before each element in the set of matched elements.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/before/}\n */\nfunction before(...elems) {\n    const lastIdx = this.length - 1;\n    return (0, utils_js_1.domEach)(this, (el, i) => {\n        if (!(0, domhandler_1.hasChildren)(el) || !el.parent) {\n            return;\n        }\n        const siblings = el.parent.children;\n        const index = siblings.indexOf(el);\n        // If not found, move on\n        /* istanbul ignore next */\n        if (index < 0)\n            return;\n        const domSrc = typeof elems[0] === 'function'\n            ? elems[0].call(el, i, this._render(el.children))\n            : elems;\n        const dom = this._makeDomArray(domSrc, i < lastIdx);\n        // Add element before `el` element\n        uniqueSplice(siblings, index, 0, dom, el.parent);\n    });\n}\n/**\n * Insert every element in the set of matched elements before the target.\n *\n * @category Manipulation\n * @example\n *\n * ```js\n * $('<li class=\"plum\">Plum</li>').insertBefore('.apple');\n * $.html();\n * //=>  <ul id=\"fruits\">\n * //      <li class=\"plum\">Plum</li>\n * //      <li class=\"apple\">Apple</li>\n * //      <li class=\"orange\">Orange</li>\n * //      <li class=\"pear\">Pear</li>\n * //    </ul>\n * ```\n *\n * @param target - Element to insert elements before.\n * @returns The set of newly inserted elements.\n * @see {@link https://api.jquery.com/insertBefore/}\n */\nfunction insertBefore(target) {\n    const targetArr = this._make(target);\n    this.remove();\n    const clones = [];\n    (0, utils_js_1.domEach)(targetArr, (el) => {\n        const clonedSelf = this.clone().toArray();\n        const { parent } = el;\n        if (!parent) {\n            return;\n        }\n        const siblings = parent.children;\n        const index = siblings.indexOf(el);\n        // If not found, move on\n        /* istanbul ignore next */\n        if (index < 0)\n            return;\n        // Add cloned `this` element(s) after target element\n        uniqueSplice(siblings, index, 0, clonedSelf, parent);\n        clones.push(...clonedSelf);\n    });\n    return this._make(clones);\n}\n/**\n * Removes the set of matched elements from the DOM and all their children.\n * `selector` filters the set of matched elements to be removed.\n *\n * @category Manipulation\n * @example\n *\n * ```js\n * $('.pear').remove();\n * $.html();\n * //=>  <ul id=\"fruits\">\n * //      <li class=\"apple\">Apple</li>\n * //      <li class=\"orange\">Orange</li>\n * //    </ul>\n * ```\n *\n * @param selector - Optional selector for elements to remove.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/remove/}\n */\nfunction remove(selector) {\n    // Filter if we have selector\n    const elems = selector ? this.filter(selector) : this;\n    (0, utils_js_1.domEach)(elems, (el) => {\n        (0, domutils_1.removeElement)(el);\n        el.prev = el.next = el.parent = null;\n    });\n    return this;\n}\n/**\n * Replaces matched elements with `content`.\n *\n * @category Manipulation\n * @example\n *\n * ```js\n * const plum = $('<li class=\"plum\">Plum</li>');\n * $('.pear').replaceWith(plum);\n * $.html();\n * //=> <ul id=\"fruits\">\n * //     <li class=\"apple\">Apple</li>\n * //     <li class=\"orange\">Orange</li>\n * //     <li class=\"plum\">Plum</li>\n * //   </ul>\n * ```\n *\n * @param content - Replacement for matched elements.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/replaceWith/}\n */\nfunction replaceWith(content) {\n    return (0, utils_js_1.domEach)(this, (el, i) => {\n        const { parent } = el;\n        if (!parent) {\n            return;\n        }\n        const siblings = parent.children;\n        const cont = typeof content === 'function' ? content.call(el, i, el) : content;\n        const dom = this._makeDomArray(cont);\n        /*\n         * In the case that `dom` contains nodes that already exist in other\n         * structures, ensure those nodes are properly removed.\n         */\n        (0, parse_js_1.update)(dom, null);\n        const index = siblings.indexOf(el);\n        // Completely remove old element\n        uniqueSplice(siblings, index, 1, dom, parent);\n        if (!dom.includes(el)) {\n            el.parent = el.prev = el.next = null;\n        }\n    });\n}\n/**\n * Removes all children from each item in the selection. Text nodes and comment\n * nodes are left as is.\n *\n * @category Manipulation\n * @example\n *\n * ```js\n * $('ul').empty();\n * $.html();\n * //=>  <ul id=\"fruits\"></ul>\n * ```\n *\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/empty/}\n */\nfunction empty() {\n    return (0, utils_js_1.domEach)(this, (el) => {\n        if (!(0, domhandler_1.hasChildren)(el))\n            return;\n        for (const child of el.children) {\n            child.next = child.prev = child.parent = null;\n        }\n        el.children.length = 0;\n    });\n}\nfunction html(str) {\n    if (str === undefined) {\n        const el = this[0];\n        if (!el || !(0, domhandler_1.hasChildren)(el))\n            return null;\n        return this._render(el.children);\n    }\n    return (0, utils_js_1.domEach)(this, (el) => {\n        if (!(0, domhandler_1.hasChildren)(el))\n            return;\n        for (const child of el.children) {\n            child.next = child.prev = child.parent = null;\n        }\n        const content = (0, utils_js_1.isCheerio)(str)\n            ? str.toArray()\n            : this._parse(`${str}`, this.options, false, el).children;\n        (0, parse_js_1.update)(content, el);\n    });\n}\n/**\n * Turns the collection to a string. Alias for `.html()`.\n *\n * @category Manipulation\n * @returns The rendered document.\n */\nfunction toString() {\n    return this._render(this);\n}\nfunction text(str) {\n    // If `str` is undefined, act as a \"getter\"\n    if (str === undefined) {\n        return (0, static_js_1.text)(this);\n    }\n    if (typeof str === 'function') {\n        // Function support\n        return (0, utils_js_1.domEach)(this, (el, i) => this._make(el).text(str.call(el, i, (0, static_js_1.text)([el]))));\n    }\n    // Append text node to each selected elements\n    return (0, utils_js_1.domEach)(this, (el) => {\n        if (!(0, domhandler_1.hasChildren)(el))\n            return;\n        for (const child of el.children) {\n            child.next = child.prev = child.parent = null;\n        }\n        const textNode = new domhandler_1.Text(`${str}`);\n        (0, parse_js_1.update)(textNode, el);\n    });\n}\n/**\n * Clone the cheerio object.\n *\n * @category Manipulation\n * @example\n *\n * ```js\n * const moreFruit = $('#fruits').clone();\n * ```\n *\n * @returns The cloned object.\n * @see {@link https://api.jquery.com/clone/}\n */\nfunction clone() {\n    const clone = Array.prototype.map.call(this.get(), (el) => (0, domhandler_1.cloneNode)(el, true));\n    // Add a root node around the cloned nodes\n    const root = new domhandler_1.Document(clone);\n    for (const node of clone) {\n        node.parent = root;\n    }\n    return this._make(clone);\n}\n//# sourceMappingURL=manipulation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2hlZXJpby9kaXN0L2NvbW1vbmpzL2FwaS9tYW5pcHVsYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLFlBQVksR0FBRyxlQUFlLEdBQUcsY0FBYztBQUNuRSxxQkFBcUI7QUFDckIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2QsZUFBZTtBQUNmLGFBQWE7QUFDYixtQkFBbUI7QUFDbkIsY0FBYztBQUNkLG9CQUFvQjtBQUNwQixjQUFjO0FBQ2QsbUJBQW1CO0FBQ25CLGFBQWE7QUFDYixZQUFZO0FBQ1osZ0JBQWdCO0FBQ2hCLFlBQVk7QUFDWixhQUFhO0FBQ2IscUJBQXFCLG1CQUFPLENBQUMsZ0VBQVk7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsd0VBQWE7QUFDeEMsb0JBQW9CLG1CQUFPLENBQUMsMEVBQWM7QUFDMUMsbUJBQW1CLG1CQUFPLENBQUMsd0VBQWE7QUFDeEMsbUJBQW1CLG1CQUFPLENBQUMsNERBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGNBQWM7QUFDZDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxZQUFZO0FBQ1osWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixJQUFJO0FBQ2pDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsSUFBSTtBQUN0RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvaW10aXlhei9EZXNrdG9wL1N1cGVyTGVhcm4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2NoZWVyaW8vZGlzdC9jb21tb25qcy9hcGkvbWFuaXB1bGF0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBNZXRob2RzIGZvciBtb2RpZnlpbmcgdGhlIERPTSBzdHJ1Y3R1cmUuXG4gKlxuICogQG1vZHVsZSBjaGVlcmlvL21hbmlwdWxhdGlvblxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLndyYXBJbm5lciA9IGV4cG9ydHMud3JhcCA9IGV4cG9ydHMucHJlcGVuZCA9IGV4cG9ydHMuYXBwZW5kID0gdm9pZCAwO1xuZXhwb3J0cy5fbWFrZURvbUFycmF5ID0gX21ha2VEb21BcnJheTtcbmV4cG9ydHMuYXBwZW5kVG8gPSBhcHBlbmRUbztcbmV4cG9ydHMucHJlcGVuZFRvID0gcHJlcGVuZFRvO1xuZXhwb3J0cy51bndyYXAgPSB1bndyYXA7XG5leHBvcnRzLndyYXBBbGwgPSB3cmFwQWxsO1xuZXhwb3J0cy5hZnRlciA9IGFmdGVyO1xuZXhwb3J0cy5pbnNlcnRBZnRlciA9IGluc2VydEFmdGVyO1xuZXhwb3J0cy5iZWZvcmUgPSBiZWZvcmU7XG5leHBvcnRzLmluc2VydEJlZm9yZSA9IGluc2VydEJlZm9yZTtcbmV4cG9ydHMucmVtb3ZlID0gcmVtb3ZlO1xuZXhwb3J0cy5yZXBsYWNlV2l0aCA9IHJlcGxhY2VXaXRoO1xuZXhwb3J0cy5lbXB0eSA9IGVtcHR5O1xuZXhwb3J0cy5odG1sID0gaHRtbDtcbmV4cG9ydHMudG9TdHJpbmcgPSB0b1N0cmluZztcbmV4cG9ydHMudGV4dCA9IHRleHQ7XG5leHBvcnRzLmNsb25lID0gY2xvbmU7XG5jb25zdCBkb21oYW5kbGVyXzEgPSByZXF1aXJlKFwiZG9taGFuZGxlclwiKTtcbmNvbnN0IHBhcnNlX2pzXzEgPSByZXF1aXJlKFwiLi4vcGFyc2UuanNcIik7XG5jb25zdCBzdGF0aWNfanNfMSA9IHJlcXVpcmUoXCIuLi9zdGF0aWMuanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzLmpzXCIpO1xuY29uc3QgZG9tdXRpbHNfMSA9IHJlcXVpcmUoXCJkb211dGlsc1wiKTtcbi8qKlxuICogQ3JlYXRlIGFuIGFycmF5IG9mIG5vZGVzLCByZWN1cnNpbmcgaW50byBhcnJheXMgYW5kIHBhcnNpbmcgc3RyaW5ncyBpZlxuICogbmVjZXNzYXJ5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY2F0ZWdvcnkgTWFuaXB1bGF0aW9uXG4gKiBAcGFyYW0gZWxlbSAtIEVsZW1lbnRzIHRvIG1ha2UgYW4gYXJyYXkgb2YuXG4gKiBAcGFyYW0gY2xvbmUgLSBPcHRpb25hbGx5IGNsb25lIG5vZGVzLlxuICogQHJldHVybnMgVGhlIGFycmF5IG9mIG5vZGVzLlxuICovXG5mdW5jdGlvbiBfbWFrZURvbUFycmF5KGVsZW0sIGNsb25lKSB7XG4gICAgaWYgKGVsZW0gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZWxlbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlKGVsZW0sIHRoaXMub3B0aW9ucywgZmFsc2UsIG51bGwpLmNoaWxkcmVuLnNsaWNlKDApO1xuICAgIH1cbiAgICBpZiAoJ2xlbmd0aCcgaW4gZWxlbSkge1xuICAgICAgICBpZiAoZWxlbS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYWtlRG9tQXJyYXkoZWxlbVswXSwgY2xvbmUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVsID0gZWxlbVtpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZWwgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghKCdsZW5ndGgnIGluIGVsKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjbG9uZSA/ICgwLCBkb21oYW5kbGVyXzEuY2xvbmVOb2RlKShlbCwgdHJ1ZSkgOiBlbCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKC4uLnRoaXMuX21ha2VEb21BcnJheShlbCwgY2xvbmUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gW2Nsb25lID8gKDAsIGRvbWhhbmRsZXJfMS5jbG9uZU5vZGUpKGVsZW0sIHRydWUpIDogZWxlbV07XG59XG5mdW5jdGlvbiBfaW5zZXJ0KGNvbmNhdGVuYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uZWxlbXMpIHtcbiAgICAgICAgY29uc3QgbGFzdElkeCA9IHRoaXMubGVuZ3RoIC0gMTtcbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc19qc18xLmRvbUVhY2gpKHRoaXMsIChlbCwgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKCEoMCwgZG9taGFuZGxlcl8xLmhhc0NoaWxkcmVuKShlbCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgZG9tU3JjID0gdHlwZW9mIGVsZW1zWzBdID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgPyBlbGVtc1swXS5jYWxsKGVsLCBpLCB0aGlzLl9yZW5kZXIoZWwuY2hpbGRyZW4pKVxuICAgICAgICAgICAgICAgIDogZWxlbXM7XG4gICAgICAgICAgICBjb25zdCBkb20gPSB0aGlzLl9tYWtlRG9tQXJyYXkoZG9tU3JjLCBpIDwgbGFzdElkeCk7XG4gICAgICAgICAgICBjb25jYXRlbmF0b3IoZG9tLCBlbC5jaGlsZHJlbiwgZWwpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuLyoqXG4gKiBNb2RpZnkgYW4gYXJyYXkgaW4tcGxhY2UsIHJlbW92aW5nIHNvbWUgbnVtYmVyIG9mIGVsZW1lbnRzIGFuZCBhZGRpbmcgbmV3XG4gKiBlbGVtZW50cyBkaXJlY3RseSBmb2xsb3dpbmcgdGhlbS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNhdGVnb3J5IE1hbmlwdWxhdGlvblxuICogQHBhcmFtIGFycmF5IC0gVGFyZ2V0IGFycmF5IHRvIHNwbGljZS5cbiAqIEBwYXJhbSBzcGxpY2VJZHggLSBJbmRleCBhdCB3aGljaCB0byBiZWdpbiBjaGFuZ2luZyB0aGUgYXJyYXkuXG4gKiBAcGFyYW0gc3BsaWNlQ291bnQgLSBOdW1iZXIgb2YgZWxlbWVudHMgdG8gcmVtb3ZlIGZyb20gdGhlIGFycmF5LlxuICogQHBhcmFtIG5ld0VsZW1zIC0gRWxlbWVudHMgdG8gaW5zZXJ0IGludG8gdGhlIGFycmF5LlxuICogQHBhcmFtIHBhcmVudCAtIFRoZSBwYXJlbnQgb2YgdGhlIG5vZGUuXG4gKiBAcmV0dXJucyBUaGUgc3BsaWNlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gdW5pcXVlU3BsaWNlKGFycmF5LCBzcGxpY2VJZHgsIHNwbGljZUNvdW50LCBuZXdFbGVtcywgcGFyZW50KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBzcGxpY2VBcmdzID0gW1xuICAgICAgICBzcGxpY2VJZHgsXG4gICAgICAgIHNwbGljZUNvdW50LFxuICAgICAgICAuLi5uZXdFbGVtcyxcbiAgICBdO1xuICAgIGNvbnN0IHByZXYgPSBzcGxpY2VJZHggPT09IDAgPyBudWxsIDogYXJyYXlbc3BsaWNlSWR4IC0gMV07XG4gICAgY29uc3QgbmV4dCA9IHNwbGljZUlkeCArIHNwbGljZUNvdW50ID49IGFycmF5Lmxlbmd0aFxuICAgICAgICA/IG51bGxcbiAgICAgICAgOiBhcnJheVtzcGxpY2VJZHggKyBzcGxpY2VDb3VudF07XG4gICAgLypcbiAgICAgKiBCZWZvcmUgc3BsaWNpbmcgaW4gbmV3IGVsZW1lbnRzLCBlbnN1cmUgdGhleSBkbyBub3QgYWxyZWFkeSBhcHBlYXIgaW4gdGhlXG4gICAgICogY3VycmVudCBhcnJheS5cbiAgICAgKi9cbiAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBuZXdFbGVtcy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXdFbGVtc1tpZHhdO1xuICAgICAgICBjb25zdCBvbGRQYXJlbnQgPSBub2RlLnBhcmVudDtcbiAgICAgICAgaWYgKG9sZFBhcmVudCkge1xuICAgICAgICAgICAgY29uc3Qgb2xkU2libGluZ3MgPSBvbGRQYXJlbnQuY2hpbGRyZW47XG4gICAgICAgICAgICBjb25zdCBwcmV2SWR4ID0gb2xkU2libGluZ3MuaW5kZXhPZihub2RlKTtcbiAgICAgICAgICAgIGlmIChwcmV2SWR4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICBvbGRQYXJlbnQuY2hpbGRyZW4uc3BsaWNlKHByZXZJZHgsIDEpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgPT09IG9sZFBhcmVudCAmJiBzcGxpY2VJZHggPiBwcmV2SWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIHNwbGljZUFyZ3NbMF0tLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIGlmIChub2RlLnByZXYpIHtcbiAgICAgICAgICAgIG5vZGUucHJldi5uZXh0ID0gKF9hID0gbm9kZS5uZXh0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLm5leHQpIHtcbiAgICAgICAgICAgIG5vZGUubmV4dC5wcmV2ID0gKF9iID0gbm9kZS5wcmV2KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUucHJldiA9IGlkeCA9PT0gMCA/IHByZXYgOiBuZXdFbGVtc1tpZHggLSAxXTtcbiAgICAgICAgbm9kZS5uZXh0ID0gaWR4ID09PSBuZXdFbGVtcy5sZW5ndGggLSAxID8gbmV4dCA6IG5ld0VsZW1zW2lkeCArIDFdO1xuICAgIH1cbiAgICBpZiAocHJldikge1xuICAgICAgICBwcmV2Lm5leHQgPSBuZXdFbGVtc1swXTtcbiAgICB9XG4gICAgaWYgKG5leHQpIHtcbiAgICAgICAgbmV4dC5wcmV2ID0gbmV3RWxlbXNbbmV3RWxlbXMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHJldHVybiBhcnJheS5zcGxpY2UoLi4uc3BsaWNlQXJncyk7XG59XG4vKipcbiAqIEluc2VydCBldmVyeSBlbGVtZW50IGluIHRoZSBzZXQgb2YgbWF0Y2hlZCBlbGVtZW50cyB0byB0aGUgZW5kIG9mIHRoZSB0YXJnZXQuXG4gKlxuICogQGNhdGVnb3J5IE1hbmlwdWxhdGlvblxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogJCgnPGxpIGNsYXNzPVwicGx1bVwiPlBsdW08L2xpPicpLmFwcGVuZFRvKCcjZnJ1aXRzJyk7XG4gKiAkLmh0bWwoKTtcbiAqIC8vPT4gIDx1bCBpZD1cImZydWl0c1wiPlxuICogLy8gICAgICA8bGkgY2xhc3M9XCJhcHBsZVwiPkFwcGxlPC9saT5cbiAqIC8vICAgICAgPGxpIGNsYXNzPVwib3JhbmdlXCI+T3JhbmdlPC9saT5cbiAqIC8vICAgICAgPGxpIGNsYXNzPVwicGVhclwiPlBlYXI8L2xpPlxuICogLy8gICAgICA8bGkgY2xhc3M9XCJwbHVtXCI+UGx1bTwvbGk+XG4gKiAvLyAgICA8L3VsPlxuICogYGBgXG4gKlxuICogQHBhcmFtIHRhcmdldCAtIEVsZW1lbnQgdG8gYXBwZW5kIGVsZW1lbnRzIHRvLlxuICogQHJldHVybnMgVGhlIGluc3RhbmNlIGl0c2VsZi5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vYXBpLmpxdWVyeS5jb20vYXBwZW5kVG8vfVxuICovXG5mdW5jdGlvbiBhcHBlbmRUbyh0YXJnZXQpIHtcbiAgICBjb25zdCBhcHBlbmRUYXJnZXQgPSAoMCwgdXRpbHNfanNfMS5pc0NoZWVyaW8pKHRhcmdldCkgPyB0YXJnZXQgOiB0aGlzLl9tYWtlKHRhcmdldCk7XG4gICAgYXBwZW5kVGFyZ2V0LmFwcGVuZCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbn1cbi8qKlxuICogSW5zZXJ0IGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIHNldCBvZiBtYXRjaGVkIGVsZW1lbnRzIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlXG4gKiB0YXJnZXQuXG4gKlxuICogQGNhdGVnb3J5IE1hbmlwdWxhdGlvblxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogJCgnPGxpIGNsYXNzPVwicGx1bVwiPlBsdW08L2xpPicpLnByZXBlbmRUbygnI2ZydWl0cycpO1xuICogJC5odG1sKCk7XG4gKiAvLz0+ICA8dWwgaWQ9XCJmcnVpdHNcIj5cbiAqIC8vICAgICAgPGxpIGNsYXNzPVwicGx1bVwiPlBsdW08L2xpPlxuICogLy8gICAgICA8bGkgY2xhc3M9XCJhcHBsZVwiPkFwcGxlPC9saT5cbiAqIC8vICAgICAgPGxpIGNsYXNzPVwib3JhbmdlXCI+T3JhbmdlPC9saT5cbiAqIC8vICAgICAgPGxpIGNsYXNzPVwicGVhclwiPlBlYXI8L2xpPlxuICogLy8gICAgPC91bD5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB0YXJnZXQgLSBFbGVtZW50IHRvIHByZXBlbmQgZWxlbWVudHMgdG8uXG4gKiBAcmV0dXJucyBUaGUgaW5zdGFuY2UgaXRzZWxmLlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9hcGkuanF1ZXJ5LmNvbS9wcmVwZW5kVG8vfVxuICovXG5mdW5jdGlvbiBwcmVwZW5kVG8odGFyZ2V0KSB7XG4gICAgY29uc3QgcHJlcGVuZFRhcmdldCA9ICgwLCB1dGlsc19qc18xLmlzQ2hlZXJpbykodGFyZ2V0KSA/IHRhcmdldCA6IHRoaXMuX21ha2UodGFyZ2V0KTtcbiAgICBwcmVwZW5kVGFyZ2V0LnByZXBlbmQodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG59XG4vKipcbiAqIEluc2VydHMgY29udGVudCBhcyB0aGUgX2xhc3RfIGNoaWxkIG9mIGVhY2ggb2YgdGhlIHNlbGVjdGVkIGVsZW1lbnRzLlxuICpcbiAqIEBjYXRlZ29yeSBNYW5pcHVsYXRpb25cbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqICQoJ3VsJykuYXBwZW5kKCc8bGkgY2xhc3M9XCJwbHVtXCI+UGx1bTwvbGk+Jyk7XG4gKiAkLmh0bWwoKTtcbiAqIC8vPT4gIDx1bCBpZD1cImZydWl0c1wiPlxuICogLy8gICAgICA8bGkgY2xhc3M9XCJhcHBsZVwiPkFwcGxlPC9saT5cbiAqIC8vICAgICAgPGxpIGNsYXNzPVwib3JhbmdlXCI+T3JhbmdlPC9saT5cbiAqIC8vICAgICAgPGxpIGNsYXNzPVwicGVhclwiPlBlYXI8L2xpPlxuICogLy8gICAgICA8bGkgY2xhc3M9XCJwbHVtXCI+UGx1bTwvbGk+XG4gKiAvLyAgICA8L3VsPlxuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9hcGkuanF1ZXJ5LmNvbS9hcHBlbmQvfVxuICovXG5leHBvcnRzLmFwcGVuZCA9IF9pbnNlcnQoKGRvbSwgY2hpbGRyZW4sIHBhcmVudCkgPT4ge1xuICAgIHVuaXF1ZVNwbGljZShjaGlsZHJlbiwgY2hpbGRyZW4ubGVuZ3RoLCAwLCBkb20sIHBhcmVudCk7XG59KTtcbi8qKlxuICogSW5zZXJ0cyBjb250ZW50IGFzIHRoZSBfZmlyc3RfIGNoaWxkIG9mIGVhY2ggb2YgdGhlIHNlbGVjdGVkIGVsZW1lbnRzLlxuICpcbiAqIEBjYXRlZ29yeSBNYW5pcHVsYXRpb25cbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqICQoJ3VsJykucHJlcGVuZCgnPGxpIGNsYXNzPVwicGx1bVwiPlBsdW08L2xpPicpO1xuICogJC5odG1sKCk7XG4gKiAvLz0+ICA8dWwgaWQ9XCJmcnVpdHNcIj5cbiAqIC8vICAgICAgPGxpIGNsYXNzPVwicGx1bVwiPlBsdW08L2xpPlxuICogLy8gICAgICA8bGkgY2xhc3M9XCJhcHBsZVwiPkFwcGxlPC9saT5cbiAqIC8vICAgICAgPGxpIGNsYXNzPVwib3JhbmdlXCI+T3JhbmdlPC9saT5cbiAqIC8vICAgICAgPGxpIGNsYXNzPVwicGVhclwiPlBlYXI8L2xpPlxuICogLy8gICAgPC91bD5cbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vYXBpLmpxdWVyeS5jb20vcHJlcGVuZC99XG4gKi9cbmV4cG9ydHMucHJlcGVuZCA9IF9pbnNlcnQoKGRvbSwgY2hpbGRyZW4sIHBhcmVudCkgPT4ge1xuICAgIHVuaXF1ZVNwbGljZShjaGlsZHJlbiwgMCwgMCwgZG9tLCBwYXJlbnQpO1xufSk7XG5mdW5jdGlvbiBfd3JhcChpbnNlcnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHdyYXBwZXIpIHtcbiAgICAgICAgY29uc3QgbGFzdElkeCA9IHRoaXMubGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3QgbGFzdFBhcmVudCA9IHRoaXMucGFyZW50cygpLmxhc3QoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlbCA9IHRoaXNbaV07XG4gICAgICAgICAgICBjb25zdCB3cmFwID0gdHlwZW9mIHdyYXBwZXIgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICA/IHdyYXBwZXIuY2FsbChlbCwgaSwgZWwpXG4gICAgICAgICAgICAgICAgOiB0eXBlb2Ygd3JhcHBlciA9PT0gJ3N0cmluZycgJiYgISgwLCB1dGlsc19qc18xLmlzSHRtbCkod3JhcHBlcilcbiAgICAgICAgICAgICAgICAgICAgPyBsYXN0UGFyZW50LmZpbmQod3JhcHBlcikuY2xvbmUoKVxuICAgICAgICAgICAgICAgICAgICA6IHdyYXBwZXI7XG4gICAgICAgICAgICBjb25zdCBbd3JhcHBlckRvbV0gPSB0aGlzLl9tYWtlRG9tQXJyYXkod3JhcCwgaSA8IGxhc3RJZHgpO1xuICAgICAgICAgICAgaWYgKCF3cmFwcGVyRG9tIHx8ICEoMCwgZG9taGFuZGxlcl8xLmhhc0NoaWxkcmVuKSh3cmFwcGVyRG9tKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCBlbEluc2VydExvY2F0aW9uID0gd3JhcHBlckRvbTtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBGaW5kIHRoZSBkZWVwZXN0IGNoaWxkLiBPbmx5IGNvbnNpZGVyIHRoZSBmaXJzdCB0YWcgY2hpbGQgb2YgZWFjaCBub2RlXG4gICAgICAgICAgICAgKiAoaWdub3JlIHRleHQpOyBzdG9wIGlmIG5vIGNoaWxkcmVuIGFyZSBmb3VuZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbGV0IGogPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGogPCBlbEluc2VydExvY2F0aW9uLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gZWxJbnNlcnRMb2NhdGlvbi5jaGlsZHJlbltqXTtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIGRvbWhhbmRsZXJfMS5pc1RhZykoY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsSW5zZXJ0TG9jYXRpb24gPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5zZXJ0KGVsLCBlbEluc2VydExvY2F0aW9uLCBbd3JhcHBlckRvbV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG59XG4vKipcbiAqIFRoZSAud3JhcCgpIGZ1bmN0aW9uIGNhbiB0YWtlIGFueSBzdHJpbmcgb3Igb2JqZWN0IHRoYXQgY291bGQgYmUgcGFzc2VkIHRvXG4gKiB0aGUgJCgpIGZhY3RvcnkgZnVuY3Rpb24gdG8gc3BlY2lmeSBhIERPTSBzdHJ1Y3R1cmUuIFRoaXMgc3RydWN0dXJlIG1heSBiZVxuICogbmVzdGVkIHNldmVyYWwgbGV2ZWxzIGRlZXAsIGJ1dCBzaG91bGQgY29udGFpbiBvbmx5IG9uZSBpbm1vc3QgZWxlbWVudC4gQVxuICogY29weSBvZiB0aGlzIHN0cnVjdHVyZSB3aWxsIGJlIHdyYXBwZWQgYXJvdW5kIGVhY2ggb2YgdGhlIGVsZW1lbnRzIGluIHRoZSBzZXRcbiAqIG9mIG1hdGNoZWQgZWxlbWVudHMuIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIG9yaWdpbmFsIHNldCBvZiBlbGVtZW50cyBmb3JcbiAqIGNoYWluaW5nIHB1cnBvc2VzLlxuICpcbiAqIEBjYXRlZ29yeSBNYW5pcHVsYXRpb25cbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIGNvbnN0IHJlZEZydWl0ID0gJCgnPGRpdiBjbGFzcz1cInJlZC1mcnVpdFwiPjwvZGl2PicpO1xuICogJCgnLmFwcGxlJykud3JhcChyZWRGcnVpdCk7XG4gKlxuICogLy89PiA8dWwgaWQ9XCJmcnVpdHNcIj5cbiAqIC8vICAgICA8ZGl2IGNsYXNzPVwicmVkLWZydWl0XCI+XG4gKiAvLyAgICAgIDxsaSBjbGFzcz1cImFwcGxlXCI+QXBwbGU8L2xpPlxuICogLy8gICAgIDwvZGl2PlxuICogLy8gICAgIDxsaSBjbGFzcz1cIm9yYW5nZVwiPk9yYW5nZTwvbGk+XG4gKiAvLyAgICAgPGxpIGNsYXNzPVwicGx1bVwiPlBsdW08L2xpPlxuICogLy8gICA8L3VsPlxuICpcbiAqIGNvbnN0IGhlYWx0aHkgPSAkKCc8ZGl2IGNsYXNzPVwiaGVhbHRoeVwiPjwvZGl2PicpO1xuICogJCgnbGknKS53cmFwKGhlYWx0aHkpO1xuICpcbiAqIC8vPT4gPHVsIGlkPVwiZnJ1aXRzXCI+XG4gKiAvLyAgICAgPGRpdiBjbGFzcz1cImhlYWx0aHlcIj5cbiAqIC8vICAgICAgIDxsaSBjbGFzcz1cImFwcGxlXCI+QXBwbGU8L2xpPlxuICogLy8gICAgIDwvZGl2PlxuICogLy8gICAgIDxkaXYgY2xhc3M9XCJoZWFsdGh5XCI+XG4gKiAvLyAgICAgICA8bGkgY2xhc3M9XCJvcmFuZ2VcIj5PcmFuZ2U8L2xpPlxuICogLy8gICAgIDwvZGl2PlxuICogLy8gICAgIDxkaXYgY2xhc3M9XCJoZWFsdGh5XCI+XG4gKiAvLyAgICAgICAgPGxpIGNsYXNzPVwicGx1bVwiPlBsdW08L2xpPlxuICogLy8gICAgIDwvZGl2PlxuICogLy8gICA8L3VsPlxuICogYGBgXG4gKlxuICogQHBhcmFtIHdyYXBwZXIgLSBUaGUgRE9NIHN0cnVjdHVyZSB0byB3cmFwIGFyb3VuZCBlYWNoIGVsZW1lbnQgaW4gdGhlXG4gKiAgIHNlbGVjdGlvbi5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vYXBpLmpxdWVyeS5jb20vd3JhcC99XG4gKi9cbmV4cG9ydHMud3JhcCA9IF93cmFwKChlbCwgZWxJbnNlcnRMb2NhdGlvbiwgd3JhcHBlckRvbSkgPT4ge1xuICAgIGNvbnN0IHsgcGFyZW50IH0gPSBlbDtcbiAgICBpZiAoIXBhcmVudClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHNpYmxpbmdzID0gcGFyZW50LmNoaWxkcmVuO1xuICAgIGNvbnN0IGluZGV4ID0gc2libGluZ3MuaW5kZXhPZihlbCk7XG4gICAgKDAsIHBhcnNlX2pzXzEudXBkYXRlKShbZWxdLCBlbEluc2VydExvY2F0aW9uKTtcbiAgICAvKlxuICAgICAqIFRoZSBwcmV2aW91cyBvcGVyYXRpb24gcmVtb3ZlZCB0aGUgY3VycmVudCBlbGVtZW50IGZyb20gdGhlIGBzaWJsaW5nc2BcbiAgICAgKiBhcnJheSwgc28gdGhlIGBkb21gIGFycmF5IGNhbiBiZSBpbnNlcnRlZCB3aXRob3V0IHJlbW92aW5nIGFueVxuICAgICAqIGFkZGl0aW9uYWwgZWxlbWVudHMuXG4gICAgICovXG4gICAgdW5pcXVlU3BsaWNlKHNpYmxpbmdzLCBpbmRleCwgMCwgd3JhcHBlckRvbSwgcGFyZW50KTtcbn0pO1xuLyoqXG4gKiBUaGUgLndyYXBJbm5lcigpIGZ1bmN0aW9uIGNhbiB0YWtlIGFueSBzdHJpbmcgb3Igb2JqZWN0IHRoYXQgY291bGQgYmUgcGFzc2VkXG4gKiB0byB0aGUgJCgpIGZhY3RvcnkgZnVuY3Rpb24gdG8gc3BlY2lmeSBhIERPTSBzdHJ1Y3R1cmUuIFRoaXMgc3RydWN0dXJlIG1heSBiZVxuICogbmVzdGVkIHNldmVyYWwgbGV2ZWxzIGRlZXAsIGJ1dCBzaG91bGQgY29udGFpbiBvbmx5IG9uZSBpbm1vc3QgZWxlbWVudC4gVGhlXG4gKiBzdHJ1Y3R1cmUgd2lsbCBiZSB3cmFwcGVkIGFyb3VuZCB0aGUgY29udGVudCBvZiBlYWNoIG9mIHRoZSBlbGVtZW50cyBpbiB0aGVcbiAqIHNldCBvZiBtYXRjaGVkIGVsZW1lbnRzLlxuICpcbiAqIEBjYXRlZ29yeSBNYW5pcHVsYXRpb25cbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIGNvbnN0IHJlZEZydWl0ID0gJCgnPGRpdiBjbGFzcz1cInJlZC1mcnVpdFwiPjwvZGl2PicpO1xuICogJCgnLmFwcGxlJykud3JhcElubmVyKHJlZEZydWl0KTtcbiAqXG4gKiAvLz0+IDx1bCBpZD1cImZydWl0c1wiPlxuICogLy8gICAgIDxsaSBjbGFzcz1cImFwcGxlXCI+XG4gKiAvLyAgICAgICA8ZGl2IGNsYXNzPVwicmVkLWZydWl0XCI+QXBwbGU8L2Rpdj5cbiAqIC8vICAgICA8L2xpPlxuICogLy8gICAgIDxsaSBjbGFzcz1cIm9yYW5nZVwiPk9yYW5nZTwvbGk+XG4gKiAvLyAgICAgPGxpIGNsYXNzPVwicGVhclwiPlBlYXI8L2xpPlxuICogLy8gICA8L3VsPlxuICpcbiAqIGNvbnN0IGhlYWx0aHkgPSAkKCc8ZGl2IGNsYXNzPVwiaGVhbHRoeVwiPjwvZGl2PicpO1xuICogJCgnbGknKS53cmFwSW5uZXIoaGVhbHRoeSk7XG4gKlxuICogLy89PiA8dWwgaWQ9XCJmcnVpdHNcIj5cbiAqIC8vICAgICA8bGkgY2xhc3M9XCJhcHBsZVwiPlxuICogLy8gICAgICAgPGRpdiBjbGFzcz1cImhlYWx0aHlcIj5BcHBsZTwvZGl2PlxuICogLy8gICAgIDwvbGk+XG4gKiAvLyAgICAgPGxpIGNsYXNzPVwib3JhbmdlXCI+XG4gKiAvLyAgICAgICA8ZGl2IGNsYXNzPVwiaGVhbHRoeVwiPk9yYW5nZTwvZGl2PlxuICogLy8gICAgIDwvbGk+XG4gKiAvLyAgICAgPGxpIGNsYXNzPVwicGVhclwiPlxuICogLy8gICAgICAgPGRpdiBjbGFzcz1cImhlYWx0aHlcIj5QZWFyPC9kaXY+XG4gKiAvLyAgICAgPC9saT5cbiAqIC8vICAgPC91bD5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB3cmFwcGVyIC0gVGhlIERPTSBzdHJ1Y3R1cmUgdG8gd3JhcCBhcm91bmQgdGhlIGNvbnRlbnQgb2YgZWFjaCBlbGVtZW50XG4gKiAgIGluIHRoZSBzZWxlY3Rpb24uXG4gKiBAcmV0dXJucyBUaGUgaW5zdGFuY2UgaXRzZWxmLCBmb3IgY2hhaW5pbmcuXG4gKiBAc2VlIHtAbGluayBodHRwczovL2FwaS5qcXVlcnkuY29tL3dyYXBJbm5lci99XG4gKi9cbmV4cG9ydHMud3JhcElubmVyID0gX3dyYXAoKGVsLCBlbEluc2VydExvY2F0aW9uLCB3cmFwcGVyRG9tKSA9PiB7XG4gICAgaWYgKCEoMCwgZG9taGFuZGxlcl8xLmhhc0NoaWxkcmVuKShlbCkpXG4gICAgICAgIHJldHVybjtcbiAgICAoMCwgcGFyc2VfanNfMS51cGRhdGUpKGVsLmNoaWxkcmVuLCBlbEluc2VydExvY2F0aW9uKTtcbiAgICAoMCwgcGFyc2VfanNfMS51cGRhdGUpKHdyYXBwZXJEb20sIGVsKTtcbn0pO1xuLyoqXG4gKiBUaGUgLnVud3JhcCgpIGZ1bmN0aW9uLCByZW1vdmVzIHRoZSBwYXJlbnRzIG9mIHRoZSBzZXQgb2YgbWF0Y2hlZCBlbGVtZW50c1xuICogZnJvbSB0aGUgRE9NLCBsZWF2aW5nIHRoZSBtYXRjaGVkIGVsZW1lbnRzIGluIHRoZWlyIHBsYWNlLlxuICpcbiAqIEBjYXRlZ29yeSBNYW5pcHVsYXRpb25cbiAqIEBleGFtcGxlIDxjYXB0aW9uPndpdGhvdXQgc2VsZWN0b3I8L2NhcHRpb24+XG4gKlxuICogYGBganNcbiAqIGNvbnN0ICQgPSBjaGVlcmlvLmxvYWQoXG4gKiAgICc8ZGl2IGlkPXRlc3Q+XFxuICA8ZGl2PjxwPkhlbGxvPC9wPjwvZGl2PlxcbiAgPGRpdj48cD5Xb3JsZDwvcD48L2Rpdj5cXG48L2Rpdj4nLFxuICogKTtcbiAqICQoJyN0ZXN0IHAnKS51bndyYXAoKTtcbiAqXG4gKiAvLz0+IDxkaXYgaWQ9dGVzdD5cbiAqIC8vICAgICA8cD5IZWxsbzwvcD5cbiAqIC8vICAgICA8cD5Xb3JsZDwvcD5cbiAqIC8vICAgPC9kaXY+XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj53aXRoIHNlbGVjdG9yPC9jYXB0aW9uPlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCAkID0gY2hlZXJpby5sb2FkKFxuICogICAnPGRpdiBpZD10ZXN0PlxcbiAgPHA+SGVsbG88L3A+XFxuICA8Yj48cD5Xb3JsZDwvcD48L2I+XFxuPC9kaXY+JyxcbiAqICk7XG4gKiAkKCcjdGVzdCBwJykudW53cmFwKCdiJyk7XG4gKlxuICogLy89PiA8ZGl2IGlkPXRlc3Q+XG4gKiAvLyAgICAgPHA+SGVsbG88L3A+XG4gKiAvLyAgICAgPHA+V29ybGQ8L3A+XG4gKiAvLyAgIDwvZGl2PlxuICogYGBgXG4gKlxuICogQHBhcmFtIHNlbGVjdG9yIC0gQSBzZWxlY3RvciB0byBjaGVjayB0aGUgcGFyZW50IGVsZW1lbnQgYWdhaW5zdC4gSWYgYW5cbiAqICAgZWxlbWVudCdzIHBhcmVudCBkb2VzIG5vdCBtYXRjaCB0aGUgc2VsZWN0b3IsIHRoZSBlbGVtZW50IHdvbid0IGJlXG4gKiAgIHVud3JhcHBlZC5cbiAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBpdHNlbGYsIGZvciBjaGFpbmluZy5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vYXBpLmpxdWVyeS5jb20vdW53cmFwL31cbiAqL1xuZnVuY3Rpb24gdW53cmFwKHNlbGVjdG9yKSB7XG4gICAgdGhpcy5wYXJlbnQoc2VsZWN0b3IpXG4gICAgICAgIC5ub3QoJ2JvZHknKVxuICAgICAgICAuZWFjaCgoXywgZWwpID0+IHtcbiAgICAgICAgdGhpcy5fbWFrZShlbCkucmVwbGFjZVdpdGgoZWwuY2hpbGRyZW4pO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xufVxuLyoqXG4gKiBUaGUgLndyYXBBbGwoKSBmdW5jdGlvbiBjYW4gdGFrZSBhbnkgc3RyaW5nIG9yIG9iamVjdCB0aGF0IGNvdWxkIGJlIHBhc3NlZCB0b1xuICogdGhlICQoKSBmdW5jdGlvbiB0byBzcGVjaWZ5IGEgRE9NIHN0cnVjdHVyZS4gVGhpcyBzdHJ1Y3R1cmUgbWF5IGJlIG5lc3RlZFxuICogc2V2ZXJhbCBsZXZlbHMgZGVlcCwgYnV0IHNob3VsZCBjb250YWluIG9ubHkgb25lIGlubW9zdCBlbGVtZW50LiBUaGVcbiAqIHN0cnVjdHVyZSB3aWxsIGJlIHdyYXBwZWQgYXJvdW5kIGFsbCBvZiB0aGUgZWxlbWVudHMgaW4gdGhlIHNldCBvZiBtYXRjaGVkXG4gKiBlbGVtZW50cywgYXMgYSBzaW5nbGUgZ3JvdXAuXG4gKlxuICogQGNhdGVnb3J5IE1hbmlwdWxhdGlvblxuICogQGV4YW1wbGUgPGNhcHRpb24+V2l0aCBtYXJrdXAgcGFzc2VkIHRvIGB3cmFwQWxsYDwvY2FwdGlvbj5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgJCA9IGNoZWVyaW8ubG9hZChcbiAqICAgJzxkaXYgY2xhc3M9XCJjb250YWluZXJcIj48ZGl2IGNsYXNzPVwiaW5uZXJcIj5GaXJzdDwvZGl2PjxkaXYgY2xhc3M9XCJpbm5lclwiPlNlY29uZDwvZGl2PjwvZGl2PicsXG4gKiApO1xuICogJCgnLmlubmVyJykud3JhcEFsbChcIjxkaXYgY2xhc3M9J25ldyc+PC9kaXY+XCIpO1xuICpcbiAqIC8vPT4gPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiPlxuICogLy8gICAgIDxkaXYgY2xhc3M9J25ldyc+XG4gKiAvLyAgICAgICA8ZGl2IGNsYXNzPVwiaW5uZXJcIj5GaXJzdDwvZGl2PlxuICogLy8gICAgICAgPGRpdiBjbGFzcz1cImlubmVyXCI+U2Vjb25kPC9kaXY+XG4gKiAvLyAgICAgPC9kaXY+XG4gKiAvLyAgIDwvZGl2PlxuICogYGBgXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+V2l0aCBhbiBleGlzdGluZyBjaGVlcmlvIGluc3RhbmNlPC9jYXB0aW9uPlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCAkID0gY2hlZXJpby5sb2FkKFxuICogICAnPHNwYW4+U3BhbiAxPC9zcGFuPjxzdHJvbmc+U3Ryb25nPC9zdHJvbmc+PHNwYW4+U3BhbiAyPC9zcGFuPicsXG4gKiApO1xuICogY29uc3Qgd3JhcCA9ICQoJzxkaXY+PHA+PGVtPjxiPjwvYj48L2VtPjwvcD48L2Rpdj4nKTtcbiAqICQoJ3NwYW4nKS53cmFwQWxsKHdyYXApO1xuICpcbiAqIC8vPT4gPGRpdj5cbiAqIC8vICAgICA8cD5cbiAqIC8vICAgICAgIDxlbT5cbiAqIC8vICAgICAgICAgPGI+XG4gKiAvLyAgICAgICAgICAgPHNwYW4+U3BhbiAxPC9zcGFuPlxuICogLy8gICAgICAgICAgIDxzcGFuPlNwYW4gMjwvc3Bhbj5cbiAqIC8vICAgICAgICAgPC9iPlxuICogLy8gICAgICAgPC9lbT5cbiAqIC8vICAgICA8L3A+XG4gKiAvLyAgIDwvZGl2PlxuICogLy8gICA8c3Ryb25nPlN0cm9uZzwvc3Ryb25nPlxuICogYGBgXG4gKlxuICogQHBhcmFtIHdyYXBwZXIgLSBUaGUgRE9NIHN0cnVjdHVyZSB0byB3cmFwIGFyb3VuZCBhbGwgbWF0Y2hlZCBlbGVtZW50cyBpbiB0aGVcbiAqICAgc2VsZWN0aW9uLlxuICogQHJldHVybnMgVGhlIGluc3RhbmNlIGl0c2VsZi5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vYXBpLmpxdWVyeS5jb20vd3JhcEFsbC99XG4gKi9cbmZ1bmN0aW9uIHdyYXBBbGwod3JhcHBlcikge1xuICAgIGNvbnN0IGVsID0gdGhpc1swXTtcbiAgICBpZiAoZWwpIHtcbiAgICAgICAgY29uc3Qgd3JhcCA9IHRoaXMuX21ha2UodHlwZW9mIHdyYXBwZXIgPT09ICdmdW5jdGlvbicgPyB3cmFwcGVyLmNhbGwoZWwsIDAsIGVsKSA6IHdyYXBwZXIpLmluc2VydEJlZm9yZShlbCk7XG4gICAgICAgIC8vIElmIGh0bWwgaXMgZ2l2ZW4gYXMgd3JhcHBlciwgd3JhcCBtYXkgY29udGFpbiB0ZXh0IGVsZW1lbnRzXG4gICAgICAgIGxldCBlbEluc2VydExvY2F0aW9uO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdyYXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh3cmFwW2ldLnR5cGUgPT09ICd0YWcnKVxuICAgICAgICAgICAgICAgIGVsSW5zZXJ0TG9jYXRpb24gPSB3cmFwW2ldO1xuICAgICAgICB9XG4gICAgICAgIGxldCBqID0gMDtcbiAgICAgICAgLypcbiAgICAgICAgICogRmluZCB0aGUgZGVlcGVzdCBjaGlsZC4gT25seSBjb25zaWRlciB0aGUgZmlyc3QgdGFnIGNoaWxkIG9mIGVhY2ggbm9kZVxuICAgICAgICAgKiAoaWdub3JlIHRleHQpOyBzdG9wIGlmIG5vIGNoaWxkcmVuIGFyZSBmb3VuZC5cbiAgICAgICAgICovXG4gICAgICAgIHdoaWxlIChlbEluc2VydExvY2F0aW9uICYmIGogPCBlbEluc2VydExvY2F0aW9uLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBlbEluc2VydExvY2F0aW9uLmNoaWxkcmVuW2pdO1xuICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09ICd0YWcnKSB7XG4gICAgICAgICAgICAgICAgZWxJbnNlcnRMb2NhdGlvbiA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbEluc2VydExvY2F0aW9uKVxuICAgICAgICAgICAgdGhpcy5fbWFrZShlbEluc2VydExvY2F0aW9uKS5hcHBlbmQodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufVxuLyoqXG4gKiBJbnNlcnQgY29udGVudCBuZXh0IHRvIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0IG9mIG1hdGNoZWQgZWxlbWVudHMuXG4gKlxuICogQGNhdGVnb3J5IE1hbmlwdWxhdGlvblxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogJCgnLmFwcGxlJykuYWZ0ZXIoJzxsaSBjbGFzcz1cInBsdW1cIj5QbHVtPC9saT4nKTtcbiAqICQuaHRtbCgpO1xuICogLy89PiAgPHVsIGlkPVwiZnJ1aXRzXCI+XG4gKiAvLyAgICAgIDxsaSBjbGFzcz1cImFwcGxlXCI+QXBwbGU8L2xpPlxuICogLy8gICAgICA8bGkgY2xhc3M9XCJwbHVtXCI+UGx1bTwvbGk+XG4gKiAvLyAgICAgIDxsaSBjbGFzcz1cIm9yYW5nZVwiPk9yYW5nZTwvbGk+XG4gKiAvLyAgICAgIDxsaSBjbGFzcz1cInBlYXJcIj5QZWFyPC9saT5cbiAqIC8vICAgIDwvdWw+XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZWxlbXMgLSBIVE1MIHN0cmluZywgRE9NIGVsZW1lbnQsIGFycmF5IG9mIERPTSBlbGVtZW50cyBvciBDaGVlcmlvIHRvXG4gKiAgIGluc2VydCBhZnRlciBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldCBvZiBtYXRjaGVkIGVsZW1lbnRzLlxuICogQHJldHVybnMgVGhlIGluc3RhbmNlIGl0c2VsZi5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vYXBpLmpxdWVyeS5jb20vYWZ0ZXIvfVxuICovXG5mdW5jdGlvbiBhZnRlciguLi5lbGVtcykge1xuICAgIGNvbnN0IGxhc3RJZHggPSB0aGlzLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuICgwLCB1dGlsc19qc18xLmRvbUVhY2gpKHRoaXMsIChlbCwgaSkgPT4ge1xuICAgICAgICBpZiAoISgwLCBkb21oYW5kbGVyXzEuaGFzQ2hpbGRyZW4pKGVsKSB8fCAhZWwucGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2libGluZ3MgPSBlbC5wYXJlbnQuY2hpbGRyZW47XG4gICAgICAgIGNvbnN0IGluZGV4ID0gc2libGluZ3MuaW5kZXhPZihlbCk7XG4gICAgICAgIC8vIElmIG5vdCBmb3VuZCwgbW92ZSBvblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBpZiAoaW5kZXggPCAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBkb21TcmMgPSB0eXBlb2YgZWxlbXNbMF0gPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gZWxlbXNbMF0uY2FsbChlbCwgaSwgdGhpcy5fcmVuZGVyKGVsLmNoaWxkcmVuKSlcbiAgICAgICAgICAgIDogZWxlbXM7XG4gICAgICAgIGNvbnN0IGRvbSA9IHRoaXMuX21ha2VEb21BcnJheShkb21TcmMsIGkgPCBsYXN0SWR4KTtcbiAgICAgICAgLy8gQWRkIGVsZW1lbnQgYWZ0ZXIgYHRoaXNgIGVsZW1lbnRcbiAgICAgICAgdW5pcXVlU3BsaWNlKHNpYmxpbmdzLCBpbmRleCArIDEsIDAsIGRvbSwgZWwucGFyZW50KTtcbiAgICB9KTtcbn1cbi8qKlxuICogSW5zZXJ0IGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIHNldCBvZiBtYXRjaGVkIGVsZW1lbnRzIGFmdGVyIHRoZSB0YXJnZXQuXG4gKlxuICogQGNhdGVnb3J5IE1hbmlwdWxhdGlvblxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogJCgnPGxpIGNsYXNzPVwicGx1bVwiPlBsdW08L2xpPicpLmluc2VydEFmdGVyKCcuYXBwbGUnKTtcbiAqICQuaHRtbCgpO1xuICogLy89PiAgPHVsIGlkPVwiZnJ1aXRzXCI+XG4gKiAvLyAgICAgIDxsaSBjbGFzcz1cImFwcGxlXCI+QXBwbGU8L2xpPlxuICogLy8gICAgICA8bGkgY2xhc3M9XCJwbHVtXCI+UGx1bTwvbGk+XG4gKiAvLyAgICAgIDxsaSBjbGFzcz1cIm9yYW5nZVwiPk9yYW5nZTwvbGk+XG4gKiAvLyAgICAgIDxsaSBjbGFzcz1cInBlYXJcIj5QZWFyPC9saT5cbiAqIC8vICAgIDwvdWw+XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdGFyZ2V0IC0gRWxlbWVudCB0byBpbnNlcnQgZWxlbWVudHMgYWZ0ZXIuXG4gKiBAcmV0dXJucyBUaGUgc2V0IG9mIG5ld2x5IGluc2VydGVkIGVsZW1lbnRzLlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9hcGkuanF1ZXJ5LmNvbS9pbnNlcnRBZnRlci99XG4gKi9cbmZ1bmN0aW9uIGluc2VydEFmdGVyKHRhcmdldCkge1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0YXJnZXQgPSB0aGlzLl9tYWtlKHRhcmdldCk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgY29uc3QgY2xvbmVzID0gW107XG4gICAgZm9yIChjb25zdCBlbCBvZiB0aGlzLl9tYWtlRG9tQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICBjb25zdCBjbG9uZWRTZWxmID0gdGhpcy5jbG9uZSgpLnRvQXJyYXkoKTtcbiAgICAgICAgY29uc3QgeyBwYXJlbnQgfSA9IGVsO1xuICAgICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2libGluZ3MgPSBwYXJlbnQuY2hpbGRyZW47XG4gICAgICAgIGNvbnN0IGluZGV4ID0gc2libGluZ3MuaW5kZXhPZihlbCk7XG4gICAgICAgIC8vIElmIG5vdCBmb3VuZCwgbW92ZSBvblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBpZiAoaW5kZXggPCAwKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIC8vIEFkZCBjbG9uZWQgYHRoaXNgIGVsZW1lbnQocykgYWZ0ZXIgdGFyZ2V0IGVsZW1lbnRcbiAgICAgICAgdW5pcXVlU3BsaWNlKHNpYmxpbmdzLCBpbmRleCArIDEsIDAsIGNsb25lZFNlbGYsIHBhcmVudCk7XG4gICAgICAgIGNsb25lcy5wdXNoKC4uLmNsb25lZFNlbGYpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbWFrZShjbG9uZXMpO1xufVxuLyoqXG4gKiBJbnNlcnQgY29udGVudCBwcmV2aW91cyB0byBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldCBvZiBtYXRjaGVkIGVsZW1lbnRzLlxuICpcbiAqIEBjYXRlZ29yeSBNYW5pcHVsYXRpb25cbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqICQoJy5hcHBsZScpLmJlZm9yZSgnPGxpIGNsYXNzPVwicGx1bVwiPlBsdW08L2xpPicpO1xuICogJC5odG1sKCk7XG4gKiAvLz0+ICA8dWwgaWQ9XCJmcnVpdHNcIj5cbiAqIC8vICAgICAgPGxpIGNsYXNzPVwicGx1bVwiPlBsdW08L2xpPlxuICogLy8gICAgICA8bGkgY2xhc3M9XCJhcHBsZVwiPkFwcGxlPC9saT5cbiAqIC8vICAgICAgPGxpIGNsYXNzPVwib3JhbmdlXCI+T3JhbmdlPC9saT5cbiAqIC8vICAgICAgPGxpIGNsYXNzPVwicGVhclwiPlBlYXI8L2xpPlxuICogLy8gICAgPC91bD5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbGVtcyAtIEhUTUwgc3RyaW5nLCBET00gZWxlbWVudCwgYXJyYXkgb2YgRE9NIGVsZW1lbnRzIG9yIENoZWVyaW8gdG9cbiAqICAgaW5zZXJ0IGJlZm9yZSBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldCBvZiBtYXRjaGVkIGVsZW1lbnRzLlxuICogQHJldHVybnMgVGhlIGluc3RhbmNlIGl0c2VsZi5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vYXBpLmpxdWVyeS5jb20vYmVmb3JlL31cbiAqL1xuZnVuY3Rpb24gYmVmb3JlKC4uLmVsZW1zKSB7XG4gICAgY29uc3QgbGFzdElkeCA9IHRoaXMubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gKDAsIHV0aWxzX2pzXzEuZG9tRWFjaCkodGhpcywgKGVsLCBpKSA9PiB7XG4gICAgICAgIGlmICghKDAsIGRvbWhhbmRsZXJfMS5oYXNDaGlsZHJlbikoZWwpIHx8ICFlbC5wYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IGVsLnBhcmVudC5jaGlsZHJlbjtcbiAgICAgICAgY29uc3QgaW5kZXggPSBzaWJsaW5ncy5pbmRleE9mKGVsKTtcbiAgICAgICAgLy8gSWYgbm90IGZvdW5kLCBtb3ZlIG9uXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGlmIChpbmRleCA8IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGRvbVNyYyA9IHR5cGVvZiBlbGVtc1swXSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBlbGVtc1swXS5jYWxsKGVsLCBpLCB0aGlzLl9yZW5kZXIoZWwuY2hpbGRyZW4pKVxuICAgICAgICAgICAgOiBlbGVtcztcbiAgICAgICAgY29uc3QgZG9tID0gdGhpcy5fbWFrZURvbUFycmF5KGRvbVNyYywgaSA8IGxhc3RJZHgpO1xuICAgICAgICAvLyBBZGQgZWxlbWVudCBiZWZvcmUgYGVsYCBlbGVtZW50XG4gICAgICAgIHVuaXF1ZVNwbGljZShzaWJsaW5ncywgaW5kZXgsIDAsIGRvbSwgZWwucGFyZW50KTtcbiAgICB9KTtcbn1cbi8qKlxuICogSW5zZXJ0IGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIHNldCBvZiBtYXRjaGVkIGVsZW1lbnRzIGJlZm9yZSB0aGUgdGFyZ2V0LlxuICpcbiAqIEBjYXRlZ29yeSBNYW5pcHVsYXRpb25cbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqICQoJzxsaSBjbGFzcz1cInBsdW1cIj5QbHVtPC9saT4nKS5pbnNlcnRCZWZvcmUoJy5hcHBsZScpO1xuICogJC5odG1sKCk7XG4gKiAvLz0+ICA8dWwgaWQ9XCJmcnVpdHNcIj5cbiAqIC8vICAgICAgPGxpIGNsYXNzPVwicGx1bVwiPlBsdW08L2xpPlxuICogLy8gICAgICA8bGkgY2xhc3M9XCJhcHBsZVwiPkFwcGxlPC9saT5cbiAqIC8vICAgICAgPGxpIGNsYXNzPVwib3JhbmdlXCI+T3JhbmdlPC9saT5cbiAqIC8vICAgICAgPGxpIGNsYXNzPVwicGVhclwiPlBlYXI8L2xpPlxuICogLy8gICAgPC91bD5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB0YXJnZXQgLSBFbGVtZW50IHRvIGluc2VydCBlbGVtZW50cyBiZWZvcmUuXG4gKiBAcmV0dXJucyBUaGUgc2V0IG9mIG5ld2x5IGluc2VydGVkIGVsZW1lbnRzLlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9hcGkuanF1ZXJ5LmNvbS9pbnNlcnRCZWZvcmUvfVxuICovXG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUodGFyZ2V0KSB7XG4gICAgY29uc3QgdGFyZ2V0QXJyID0gdGhpcy5fbWFrZSh0YXJnZXQpO1xuICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgY29uc3QgY2xvbmVzID0gW107XG4gICAgKDAsIHV0aWxzX2pzXzEuZG9tRWFjaCkodGFyZ2V0QXJyLCAoZWwpID0+IHtcbiAgICAgICAgY29uc3QgY2xvbmVkU2VsZiA9IHRoaXMuY2xvbmUoKS50b0FycmF5KCk7XG4gICAgICAgIGNvbnN0IHsgcGFyZW50IH0gPSBlbDtcbiAgICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IHBhcmVudC5jaGlsZHJlbjtcbiAgICAgICAgY29uc3QgaW5kZXggPSBzaWJsaW5ncy5pbmRleE9mKGVsKTtcbiAgICAgICAgLy8gSWYgbm90IGZvdW5kLCBtb3ZlIG9uXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGlmIChpbmRleCA8IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIEFkZCBjbG9uZWQgYHRoaXNgIGVsZW1lbnQocykgYWZ0ZXIgdGFyZ2V0IGVsZW1lbnRcbiAgICAgICAgdW5pcXVlU3BsaWNlKHNpYmxpbmdzLCBpbmRleCwgMCwgY2xvbmVkU2VsZiwgcGFyZW50KTtcbiAgICAgICAgY2xvbmVzLnB1c2goLi4uY2xvbmVkU2VsZik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuX21ha2UoY2xvbmVzKTtcbn1cbi8qKlxuICogUmVtb3ZlcyB0aGUgc2V0IG9mIG1hdGNoZWQgZWxlbWVudHMgZnJvbSB0aGUgRE9NIGFuZCBhbGwgdGhlaXIgY2hpbGRyZW4uXG4gKiBgc2VsZWN0b3JgIGZpbHRlcnMgdGhlIHNldCBvZiBtYXRjaGVkIGVsZW1lbnRzIHRvIGJlIHJlbW92ZWQuXG4gKlxuICogQGNhdGVnb3J5IE1hbmlwdWxhdGlvblxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogJCgnLnBlYXInKS5yZW1vdmUoKTtcbiAqICQuaHRtbCgpO1xuICogLy89PiAgPHVsIGlkPVwiZnJ1aXRzXCI+XG4gKiAvLyAgICAgIDxsaSBjbGFzcz1cImFwcGxlXCI+QXBwbGU8L2xpPlxuICogLy8gICAgICA8bGkgY2xhc3M9XCJvcmFuZ2VcIj5PcmFuZ2U8L2xpPlxuICogLy8gICAgPC91bD5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzZWxlY3RvciAtIE9wdGlvbmFsIHNlbGVjdG9yIGZvciBlbGVtZW50cyB0byByZW1vdmUuXG4gKiBAcmV0dXJucyBUaGUgaW5zdGFuY2UgaXRzZWxmLlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9hcGkuanF1ZXJ5LmNvbS9yZW1vdmUvfVxuICovXG5mdW5jdGlvbiByZW1vdmUoc2VsZWN0b3IpIHtcbiAgICAvLyBGaWx0ZXIgaWYgd2UgaGF2ZSBzZWxlY3RvclxuICAgIGNvbnN0IGVsZW1zID0gc2VsZWN0b3IgPyB0aGlzLmZpbHRlcihzZWxlY3RvcikgOiB0aGlzO1xuICAgICgwLCB1dGlsc19qc18xLmRvbUVhY2gpKGVsZW1zLCAoZWwpID0+IHtcbiAgICAgICAgKDAsIGRvbXV0aWxzXzEucmVtb3ZlRWxlbWVudCkoZWwpO1xuICAgICAgICBlbC5wcmV2ID0gZWwubmV4dCA9IGVsLnBhcmVudCA9IG51bGw7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG59XG4vKipcbiAqIFJlcGxhY2VzIG1hdGNoZWQgZWxlbWVudHMgd2l0aCBgY29udGVudGAuXG4gKlxuICogQGNhdGVnb3J5IE1hbmlwdWxhdGlvblxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogY29uc3QgcGx1bSA9ICQoJzxsaSBjbGFzcz1cInBsdW1cIj5QbHVtPC9saT4nKTtcbiAqICQoJy5wZWFyJykucmVwbGFjZVdpdGgocGx1bSk7XG4gKiAkLmh0bWwoKTtcbiAqIC8vPT4gPHVsIGlkPVwiZnJ1aXRzXCI+XG4gKiAvLyAgICAgPGxpIGNsYXNzPVwiYXBwbGVcIj5BcHBsZTwvbGk+XG4gKiAvLyAgICAgPGxpIGNsYXNzPVwib3JhbmdlXCI+T3JhbmdlPC9saT5cbiAqIC8vICAgICA8bGkgY2xhc3M9XCJwbHVtXCI+UGx1bTwvbGk+XG4gKiAvLyAgIDwvdWw+XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gY29udGVudCAtIFJlcGxhY2VtZW50IGZvciBtYXRjaGVkIGVsZW1lbnRzLlxuICogQHJldHVybnMgVGhlIGluc3RhbmNlIGl0c2VsZi5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vYXBpLmpxdWVyeS5jb20vcmVwbGFjZVdpdGgvfVxuICovXG5mdW5jdGlvbiByZXBsYWNlV2l0aChjb250ZW50KSB7XG4gICAgcmV0dXJuICgwLCB1dGlsc19qc18xLmRvbUVhY2gpKHRoaXMsIChlbCwgaSkgPT4ge1xuICAgICAgICBjb25zdCB7IHBhcmVudCB9ID0gZWw7XG4gICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2libGluZ3MgPSBwYXJlbnQuY2hpbGRyZW47XG4gICAgICAgIGNvbnN0IGNvbnQgPSB0eXBlb2YgY29udGVudCA9PT0gJ2Z1bmN0aW9uJyA/IGNvbnRlbnQuY2FsbChlbCwgaSwgZWwpIDogY29udGVudDtcbiAgICAgICAgY29uc3QgZG9tID0gdGhpcy5fbWFrZURvbUFycmF5KGNvbnQpO1xuICAgICAgICAvKlxuICAgICAgICAgKiBJbiB0aGUgY2FzZSB0aGF0IGBkb21gIGNvbnRhaW5zIG5vZGVzIHRoYXQgYWxyZWFkeSBleGlzdCBpbiBvdGhlclxuICAgICAgICAgKiBzdHJ1Y3R1cmVzLCBlbnN1cmUgdGhvc2Ugbm9kZXMgYXJlIHByb3Blcmx5IHJlbW92ZWQuXG4gICAgICAgICAqL1xuICAgICAgICAoMCwgcGFyc2VfanNfMS51cGRhdGUpKGRvbSwgbnVsbCk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gc2libGluZ3MuaW5kZXhPZihlbCk7XG4gICAgICAgIC8vIENvbXBsZXRlbHkgcmVtb3ZlIG9sZCBlbGVtZW50XG4gICAgICAgIHVuaXF1ZVNwbGljZShzaWJsaW5ncywgaW5kZXgsIDEsIGRvbSwgcGFyZW50KTtcbiAgICAgICAgaWYgKCFkb20uaW5jbHVkZXMoZWwpKSB7XG4gICAgICAgICAgICBlbC5wYXJlbnQgPSBlbC5wcmV2ID0gZWwubmV4dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKlxuICogUmVtb3ZlcyBhbGwgY2hpbGRyZW4gZnJvbSBlYWNoIGl0ZW0gaW4gdGhlIHNlbGVjdGlvbi4gVGV4dCBub2RlcyBhbmQgY29tbWVudFxuICogbm9kZXMgYXJlIGxlZnQgYXMgaXMuXG4gKlxuICogQGNhdGVnb3J5IE1hbmlwdWxhdGlvblxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogJCgndWwnKS5lbXB0eSgpO1xuICogJC5odG1sKCk7XG4gKiAvLz0+ICA8dWwgaWQ9XCJmcnVpdHNcIj48L3VsPlxuICogYGBgXG4gKlxuICogQHJldHVybnMgVGhlIGluc3RhbmNlIGl0c2VsZi5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vYXBpLmpxdWVyeS5jb20vZW1wdHkvfVxuICovXG5mdW5jdGlvbiBlbXB0eSgpIHtcbiAgICByZXR1cm4gKDAsIHV0aWxzX2pzXzEuZG9tRWFjaCkodGhpcywgKGVsKSA9PiB7XG4gICAgICAgIGlmICghKDAsIGRvbWhhbmRsZXJfMS5oYXNDaGlsZHJlbikoZWwpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGVsLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBjaGlsZC5uZXh0ID0gY2hpbGQucHJldiA9IGNoaWxkLnBhcmVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWwuY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGh0bWwoc3RyKSB7XG4gICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGVsID0gdGhpc1swXTtcbiAgICAgICAgaWYgKCFlbCB8fCAhKDAsIGRvbWhhbmRsZXJfMS5oYXNDaGlsZHJlbikoZWwpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXIoZWwuY2hpbGRyZW4pO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIHV0aWxzX2pzXzEuZG9tRWFjaCkodGhpcywgKGVsKSA9PiB7XG4gICAgICAgIGlmICghKDAsIGRvbWhhbmRsZXJfMS5oYXNDaGlsZHJlbikoZWwpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGVsLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBjaGlsZC5uZXh0ID0gY2hpbGQucHJldiA9IGNoaWxkLnBhcmVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGVudCA9ICgwLCB1dGlsc19qc18xLmlzQ2hlZXJpbykoc3RyKVxuICAgICAgICAgICAgPyBzdHIudG9BcnJheSgpXG4gICAgICAgICAgICA6IHRoaXMuX3BhcnNlKGAke3N0cn1gLCB0aGlzLm9wdGlvbnMsIGZhbHNlLCBlbCkuY2hpbGRyZW47XG4gICAgICAgICgwLCBwYXJzZV9qc18xLnVwZGF0ZSkoY29udGVudCwgZWwpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBUdXJucyB0aGUgY29sbGVjdGlvbiB0byBhIHN0cmluZy4gQWxpYXMgZm9yIGAuaHRtbCgpYC5cbiAqXG4gKiBAY2F0ZWdvcnkgTWFuaXB1bGF0aW9uXG4gKiBAcmV0dXJucyBUaGUgcmVuZGVyZWQgZG9jdW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9yZW5kZXIodGhpcyk7XG59XG5mdW5jdGlvbiB0ZXh0KHN0cikge1xuICAgIC8vIElmIGBzdHJgIGlzIHVuZGVmaW5lZCwgYWN0IGFzIGEgXCJnZXR0ZXJcIlxuICAgIGlmIChzdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gKDAsIHN0YXRpY19qc18xLnRleHQpKHRoaXMpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHN0ciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBGdW5jdGlvbiBzdXBwb3J0XG4gICAgICAgIHJldHVybiAoMCwgdXRpbHNfanNfMS5kb21FYWNoKSh0aGlzLCAoZWwsIGkpID0+IHRoaXMuX21ha2UoZWwpLnRleHQoc3RyLmNhbGwoZWwsIGksICgwLCBzdGF0aWNfanNfMS50ZXh0KShbZWxdKSkpKTtcbiAgICB9XG4gICAgLy8gQXBwZW5kIHRleHQgbm9kZSB0byBlYWNoIHNlbGVjdGVkIGVsZW1lbnRzXG4gICAgcmV0dXJuICgwLCB1dGlsc19qc18xLmRvbUVhY2gpKHRoaXMsIChlbCkgPT4ge1xuICAgICAgICBpZiAoISgwLCBkb21oYW5kbGVyXzEuaGFzQ2hpbGRyZW4pKGVsKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBlbC5jaGlsZHJlbikge1xuICAgICAgICAgICAgY2hpbGQubmV4dCA9IGNoaWxkLnByZXYgPSBjaGlsZC5wYXJlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRleHROb2RlID0gbmV3IGRvbWhhbmRsZXJfMS5UZXh0KGAke3N0cn1gKTtcbiAgICAgICAgKDAsIHBhcnNlX2pzXzEudXBkYXRlKSh0ZXh0Tm9kZSwgZWwpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBDbG9uZSB0aGUgY2hlZXJpbyBvYmplY3QuXG4gKlxuICogQGNhdGVnb3J5IE1hbmlwdWxhdGlvblxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogY29uc3QgbW9yZUZydWl0ID0gJCgnI2ZydWl0cycpLmNsb25lKCk7XG4gKiBgYGBcbiAqXG4gKiBAcmV0dXJucyBUaGUgY2xvbmVkIG9iamVjdC5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vYXBpLmpxdWVyeS5jb20vY2xvbmUvfVxuICovXG5mdW5jdGlvbiBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZSA9IEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbCh0aGlzLmdldCgpLCAoZWwpID0+ICgwLCBkb21oYW5kbGVyXzEuY2xvbmVOb2RlKShlbCwgdHJ1ZSkpO1xuICAgIC8vIEFkZCBhIHJvb3Qgbm9kZSBhcm91bmQgdGhlIGNsb25lZCBub2Rlc1xuICAgIGNvbnN0IHJvb3QgPSBuZXcgZG9taGFuZGxlcl8xLkRvY3VtZW50KGNsb25lKTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgY2xvbmUpIHtcbiAgICAgICAgbm9kZS5wYXJlbnQgPSByb290O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbWFrZShjbG9uZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYW5pcHVsYXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/cheerio/dist/commonjs/api/manipulation.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/cheerio/dist/commonjs/api/traversing.js":
/*!**************************************************************!*\
  !*** ./node_modules/cheerio/dist/commonjs/api/traversing.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * Methods for traversing the DOM structure.\n *\n * @module cheerio/traversing\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.children = exports.siblings = exports.prevUntil = exports.prevAll = exports.prev = exports.nextUntil = exports.nextAll = exports.next = exports.parentsUntil = exports.parents = exports.parent = void 0;\nexports.find = find;\nexports._findBySelector = _findBySelector;\nexports.closest = closest;\nexports.contents = contents;\nexports.each = each;\nexports.map = map;\nexports.filter = filter;\nexports.filterArray = filterArray;\nexports.is = is;\nexports.not = not;\nexports.has = has;\nexports.first = first;\nexports.last = last;\nexports.eq = eq;\nexports.get = get;\nexports.toArray = toArray;\nexports.index = index;\nexports.slice = slice;\nexports.end = end;\nexports.add = add;\nexports.addBack = addBack;\nconst domhandler_1 = __webpack_require__(/*! domhandler */ \"(rsc)/./node_modules/domhandler/lib/index.js\");\nconst select = __importStar(__webpack_require__(/*! cheerio-select */ \"(rsc)/./node_modules/cheerio-select/lib/index.js\"));\nconst utils_js_1 = __webpack_require__(/*! ../utils.js */ \"(rsc)/./node_modules/cheerio/dist/commonjs/utils.js\");\nconst static_js_1 = __webpack_require__(/*! ../static.js */ \"(rsc)/./node_modules/cheerio/dist/commonjs/static.js\");\nconst domutils_1 = __webpack_require__(/*! domutils */ \"(rsc)/./node_modules/domutils/lib/index.js\");\nconst reSiblingSelector = /^\\s*[+~]/;\n/**\n * Get the descendants of each element in the current set of matched elements,\n * filtered by a selector, jQuery object, or element.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('#fruits').find('li').length;\n * //=> 3\n * $('#fruits').find($('.apple')).length;\n * //=> 1\n * ```\n *\n * @param selectorOrHaystack - Element to look for.\n * @returns The found elements.\n * @see {@link https://api.jquery.com/find/}\n */\nfunction find(selectorOrHaystack) {\n    if (!selectorOrHaystack) {\n        return this._make([]);\n    }\n    if (typeof selectorOrHaystack !== 'string') {\n        const haystack = (0, utils_js_1.isCheerio)(selectorOrHaystack)\n            ? selectorOrHaystack.toArray()\n            : [selectorOrHaystack];\n        const context = this.toArray();\n        return this._make(haystack.filter((elem) => context.some((node) => (0, static_js_1.contains)(node, elem))));\n    }\n    return this._findBySelector(selectorOrHaystack, Number.POSITIVE_INFINITY);\n}\n/**\n * Find elements by a specific selector.\n *\n * @private\n * @category Traversing\n * @param selector - Selector to filter by.\n * @param limit - Maximum number of elements to match.\n * @returns The found elements.\n */\nfunction _findBySelector(selector, limit) {\n    var _a;\n    const context = this.toArray();\n    const elems = reSiblingSelector.test(selector)\n        ? context\n        : this.children().toArray();\n    const options = {\n        context,\n        root: (_a = this._root) === null || _a === void 0 ? void 0 : _a[0],\n        // Pass options that are recognized by `cheerio-select`\n        xmlMode: this.options.xmlMode,\n        lowerCaseTags: this.options.lowerCaseTags,\n        lowerCaseAttributeNames: this.options.lowerCaseAttributeNames,\n        pseudos: this.options.pseudos,\n        quirksMode: this.options.quirksMode,\n    };\n    return this._make(select.select(selector, elems, options, limit));\n}\n/**\n * Creates a matcher, using a particular mapping function. Matchers provide a\n * function that finds elements using a generating function, supporting\n * filtering.\n *\n * @private\n * @param matchMap - Mapping function.\n * @returns - Function for wrapping generating functions.\n */\nfunction _getMatcher(matchMap) {\n    return function (fn, ...postFns) {\n        return function (selector) {\n            var _a;\n            let matched = matchMap(fn, this);\n            if (selector) {\n                matched = filterArray(matched, selector, this.options.xmlMode, (_a = this._root) === null || _a === void 0 ? void 0 : _a[0]);\n            }\n            return this._make(\n            // Post processing is only necessary if there is more than one element.\n            this.length > 1 && matched.length > 1\n                ? postFns.reduce((elems, fn) => fn(elems), matched)\n                : matched);\n        };\n    };\n}\n/** Matcher that adds multiple elements for each entry in the input. */\nconst _matcher = _getMatcher((fn, elems) => {\n    let ret = [];\n    for (let i = 0; i < elems.length; i++) {\n        const value = fn(elems[i]);\n        if (value.length > 0)\n            ret = ret.concat(value);\n    }\n    return ret;\n});\n/** Matcher that adds at most one element for each entry in the input. */\nconst _singleMatcher = _getMatcher((fn, elems) => {\n    const ret = [];\n    for (let i = 0; i < elems.length; i++) {\n        const value = fn(elems[i]);\n        if (value !== null) {\n            ret.push(value);\n        }\n    }\n    return ret;\n});\n/**\n * Matcher that supports traversing until a condition is met.\n *\n * @param nextElem - Function that returns the next element.\n * @param postFns - Post processing functions.\n * @returns A function usable for `*Until` methods.\n */\nfunction _matchUntil(nextElem, ...postFns) {\n    // We use a variable here that is used from within the matcher.\n    let matches = null;\n    const innerMatcher = _getMatcher((nextElem, elems) => {\n        const matched = [];\n        (0, utils_js_1.domEach)(elems, (elem) => {\n            for (let next; (next = nextElem(elem)); elem = next) {\n                // FIXME: `matched` might contain duplicates here and the index is too large.\n                if (matches === null || matches === void 0 ? void 0 : matches(next, matched.length))\n                    break;\n                matched.push(next);\n            }\n        });\n        return matched;\n    })(nextElem, ...postFns);\n    return function (selector, filterSelector) {\n        // Override `matches` variable with the new target.\n        matches =\n            typeof selector === 'string'\n                ? (elem) => select.is(elem, selector, this.options)\n                : selector\n                    ? getFilterFn(selector)\n                    : null;\n        const ret = innerMatcher.call(this, filterSelector);\n        // Set `matches` to `null`, so we don't waste memory.\n        matches = null;\n        return ret;\n    };\n}\nfunction _removeDuplicates(elems) {\n    return elems.length > 1 ? Array.from(new Set(elems)) : elems;\n}\n/**\n * Get the parent of each element in the current set of matched elements,\n * optionally filtered by a selector.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('.pear').parent().attr('id');\n * //=> fruits\n * ```\n *\n * @param selector - If specified filter for parent.\n * @returns The parents.\n * @see {@link https://api.jquery.com/parent/}\n */\nexports.parent = _singleMatcher(({ parent }) => (parent && !(0, domhandler_1.isDocument)(parent) ? parent : null), _removeDuplicates);\n/**\n * Get a set of parents filtered by `selector` of each element in the current\n * set of match elements.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('.orange').parents().length;\n * //=> 2\n * $('.orange').parents('#fruits').length;\n * //=> 1\n * ```\n *\n * @param selector - If specified filter for parents.\n * @returns The parents.\n * @see {@link https://api.jquery.com/parents/}\n */\nexports.parents = _matcher((elem) => {\n    const matched = [];\n    while (elem.parent && !(0, domhandler_1.isDocument)(elem.parent)) {\n        matched.push(elem.parent);\n        elem = elem.parent;\n    }\n    return matched;\n}, domutils_1.uniqueSort, (elems) => elems.reverse());\n/**\n * Get the ancestors of each element in the current set of matched elements, up\n * to but not including the element matched by the selector, DOM node, or\n * cheerio object.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('.orange').parentsUntil('#food').length;\n * //=> 1\n * ```\n *\n * @param selector - Selector for element to stop at.\n * @param filterSelector - Optional filter for parents.\n * @returns The parents.\n * @see {@link https://api.jquery.com/parentsUntil/}\n */\nexports.parentsUntil = _matchUntil(({ parent }) => (parent && !(0, domhandler_1.isDocument)(parent) ? parent : null), domutils_1.uniqueSort, (elems) => elems.reverse());\n/**\n * For each element in the set, get the first element that matches the selector\n * by testing the element itself and traversing up through its ancestors in the\n * DOM tree.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('.orange').closest();\n * //=> []\n *\n * $('.orange').closest('.apple');\n * // => []\n *\n * $('.orange').closest('li');\n * //=> [<li class=\"orange\">Orange</li>]\n *\n * $('.orange').closest('#fruits');\n * //=> [<ul id=\"fruits\"> ... </ul>]\n * ```\n *\n * @param selector - Selector for the element to find.\n * @returns The closest nodes.\n * @see {@link https://api.jquery.com/closest/}\n */\nfunction closest(selector) {\n    var _a;\n    const set = [];\n    if (!selector) {\n        return this._make(set);\n    }\n    const selectOpts = {\n        xmlMode: this.options.xmlMode,\n        root: (_a = this._root) === null || _a === void 0 ? void 0 : _a[0],\n    };\n    const selectFn = typeof selector === 'string'\n        ? (elem) => select.is(elem, selector, selectOpts)\n        : getFilterFn(selector);\n    (0, utils_js_1.domEach)(this, (elem) => {\n        if (elem && !(0, domhandler_1.isDocument)(elem) && !(0, domhandler_1.isTag)(elem)) {\n            elem = elem.parent;\n        }\n        while (elem && (0, domhandler_1.isTag)(elem)) {\n            if (selectFn(elem, 0)) {\n                // Do not add duplicate elements to the set\n                if (!set.includes(elem)) {\n                    set.push(elem);\n                }\n                break;\n            }\n            elem = elem.parent;\n        }\n    });\n    return this._make(set);\n}\n/**\n * Gets the next sibling of each selected element, optionally filtered by a\n * selector.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('.apple').next().hasClass('orange');\n * //=> true\n * ```\n *\n * @param selector - If specified filter for sibling.\n * @returns The next nodes.\n * @see {@link https://api.jquery.com/next/}\n */\nexports.next = _singleMatcher((elem) => (0, domutils_1.nextElementSibling)(elem));\n/**\n * Gets all the following siblings of the each selected element, optionally\n * filtered by a selector.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('.apple').nextAll();\n * //=> [<li class=\"orange\">Orange</li>, <li class=\"pear\">Pear</li>]\n * $('.apple').nextAll('.orange');\n * //=> [<li class=\"orange\">Orange</li>]\n * ```\n *\n * @param selector - If specified filter for siblings.\n * @returns The next nodes.\n * @see {@link https://api.jquery.com/nextAll/}\n */\nexports.nextAll = _matcher((elem) => {\n    const matched = [];\n    while (elem.next) {\n        elem = elem.next;\n        if ((0, domhandler_1.isTag)(elem))\n            matched.push(elem);\n    }\n    return matched;\n}, _removeDuplicates);\n/**\n * Gets all the following siblings up to but not including the element matched\n * by the selector, optionally filtered by another selector.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('.apple').nextUntil('.pear');\n * //=> [<li class=\"orange\">Orange</li>]\n * ```\n *\n * @param selector - Selector for element to stop at.\n * @param filterSelector - If specified filter for siblings.\n * @returns The next nodes.\n * @see {@link https://api.jquery.com/nextUntil/}\n */\nexports.nextUntil = _matchUntil((el) => (0, domutils_1.nextElementSibling)(el), _removeDuplicates);\n/**\n * Gets the previous sibling of each selected element optionally filtered by a\n * selector.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('.orange').prev().hasClass('apple');\n * //=> true\n * ```\n *\n * @param selector - If specified filter for siblings.\n * @returns The previous nodes.\n * @see {@link https://api.jquery.com/prev/}\n */\nexports.prev = _singleMatcher((elem) => (0, domutils_1.prevElementSibling)(elem));\n/**\n * Gets all the preceding siblings of each selected element, optionally filtered\n * by a selector.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('.pear').prevAll();\n * //=> [<li class=\"orange\">Orange</li>, <li class=\"apple\">Apple</li>]\n *\n * $('.pear').prevAll('.orange');\n * //=> [<li class=\"orange\">Orange</li>]\n * ```\n *\n * @param selector - If specified filter for siblings.\n * @returns The previous nodes.\n * @see {@link https://api.jquery.com/prevAll/}\n */\nexports.prevAll = _matcher((elem) => {\n    const matched = [];\n    while (elem.prev) {\n        elem = elem.prev;\n        if ((0, domhandler_1.isTag)(elem))\n            matched.push(elem);\n    }\n    return matched;\n}, _removeDuplicates);\n/**\n * Gets all the preceding siblings up to but not including the element matched\n * by the selector, optionally filtered by another selector.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('.pear').prevUntil('.apple');\n * //=> [<li class=\"orange\">Orange</li>]\n * ```\n *\n * @param selector - Selector for element to stop at.\n * @param filterSelector - If specified filter for siblings.\n * @returns The previous nodes.\n * @see {@link https://api.jquery.com/prevUntil/}\n */\nexports.prevUntil = _matchUntil((el) => (0, domutils_1.prevElementSibling)(el), _removeDuplicates);\n/**\n * Get the siblings of each element (excluding the element) in the set of\n * matched elements, optionally filtered by a selector.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('.pear').siblings().length;\n * //=> 2\n *\n * $('.pear').siblings('.orange').length;\n * //=> 1\n * ```\n *\n * @param selector - If specified filter for siblings.\n * @returns The siblings.\n * @see {@link https://api.jquery.com/siblings/}\n */\nexports.siblings = _matcher((elem) => (0, domutils_1.getSiblings)(elem).filter((el) => (0, domhandler_1.isTag)(el) && el !== elem), domutils_1.uniqueSort);\n/**\n * Gets the element children of each element in the set of matched elements.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('#fruits').children().length;\n * //=> 3\n *\n * $('#fruits').children('.pear').text();\n * //=> Pear\n * ```\n *\n * @param selector - If specified filter for children.\n * @returns The children.\n * @see {@link https://api.jquery.com/children/}\n */\nexports.children = _matcher((elem) => (0, domutils_1.getChildren)(elem).filter(domhandler_1.isTag), _removeDuplicates);\n/**\n * Gets the children of each element in the set of matched elements, including\n * text and comment nodes.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('#fruits').contents().length;\n * //=> 3\n * ```\n *\n * @returns The children.\n * @see {@link https://api.jquery.com/contents/}\n */\nfunction contents() {\n    const elems = this.toArray().reduce((newElems, elem) => (0, domhandler_1.hasChildren)(elem) ? newElems.concat(elem.children) : newElems, []);\n    return this._make(elems);\n}\n/**\n * Iterates over a cheerio object, executing a function for each matched\n * element. When the callback is fired, the function is fired in the context of\n * the DOM element, so `this` refers to the current element, which is equivalent\n * to the function parameter `element`. To break out of the `each` loop early,\n * return with `false`.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * const fruits = [];\n *\n * $('li').each(function (i, elem) {\n *   fruits[i] = $(this).text();\n * });\n *\n * fruits.join(', ');\n * //=> Apple, Orange, Pear\n * ```\n *\n * @param fn - Function to execute.\n * @returns The instance itself, useful for chaining.\n * @see {@link https://api.jquery.com/each/}\n */\nfunction each(fn) {\n    let i = 0;\n    const len = this.length;\n    while (i < len && fn.call(this[i], i, this[i]) !== false)\n        ++i;\n    return this;\n}\n/**\n * Pass each element in the current matched set through a function, producing a\n * new Cheerio object containing the return values. The function can return an\n * individual data item or an array of data items to be inserted into the\n * resulting set. If an array is returned, the elements inside the array are\n * inserted into the set. If the function returns null or undefined, no element\n * will be inserted.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('li')\n *   .map(function (i, el) {\n *     // this === el\n *     return $(this).text();\n *   })\n *   .toArray()\n *   .join(' ');\n * //=> \"apple orange pear\"\n * ```\n *\n * @param fn - Function to execute.\n * @returns The mapped elements, wrapped in a Cheerio collection.\n * @see {@link https://api.jquery.com/map/}\n */\nfunction map(fn) {\n    let elems = [];\n    for (let i = 0; i < this.length; i++) {\n        const el = this[i];\n        const val = fn.call(el, i, el);\n        if (val != null) {\n            elems = elems.concat(val);\n        }\n    }\n    return this._make(elems);\n}\n/**\n * Creates a function to test if a filter is matched.\n *\n * @param match - A filter.\n * @returns A function that determines if a filter has been matched.\n */\nfunction getFilterFn(match) {\n    if (typeof match === 'function') {\n        return (el, i) => match.call(el, i, el);\n    }\n    if ((0, utils_js_1.isCheerio)(match)) {\n        return (el) => Array.prototype.includes.call(match, el);\n    }\n    return function (el) {\n        return match === el;\n    };\n}\nfunction filter(match) {\n    var _a;\n    return this._make(filterArray(this.toArray(), match, this.options.xmlMode, (_a = this._root) === null || _a === void 0 ? void 0 : _a[0]));\n}\nfunction filterArray(nodes, match, xmlMode, root) {\n    return typeof match === 'string'\n        ? select.filter(match, nodes, { xmlMode, root })\n        : nodes.filter(getFilterFn(match));\n}\n/**\n * Checks the current list of elements and returns `true` if _any_ of the\n * elements match the selector. If using an element or Cheerio selection,\n * returns `true` if _any_ of the elements match. If using a predicate function,\n * the function is executed in the context of the selected element, so `this`\n * refers to the current element.\n *\n * @category Traversing\n * @param selector - Selector for the selection.\n * @returns Whether or not the selector matches an element of the instance.\n * @see {@link https://api.jquery.com/is/}\n */\nfunction is(selector) {\n    const nodes = this.toArray();\n    return typeof selector === 'string'\n        ? select.some(nodes.filter(domhandler_1.isTag), selector, this.options)\n        : selector\n            ? nodes.some(getFilterFn(selector))\n            : false;\n}\n/**\n * Remove elements from the set of matched elements. Given a Cheerio object that\n * represents a set of DOM elements, the `.not()` method constructs a new\n * Cheerio object from a subset of the matching elements. The supplied selector\n * is tested against each element; the elements that don't match the selector\n * will be included in the result.\n *\n * The `.not()` method can take a function as its argument in the same way that\n * `.filter()` does. Elements for which the function returns `true` are excluded\n * from the filtered set; all other elements are included.\n *\n * @category Traversing\n * @example <caption>Selector</caption>\n *\n * ```js\n * $('li').not('.apple').length;\n * //=> 2\n * ```\n *\n * @example <caption>Function</caption>\n *\n * ```js\n * $('li').not(function (i, el) {\n *   // this === el\n *   return $(this).attr('class') === 'orange';\n * }).length; //=> 2\n * ```\n *\n * @param match - Value to look for, following the rules above.\n * @returns The filtered collection.\n * @see {@link https://api.jquery.com/not/}\n */\nfunction not(match) {\n    let nodes = this.toArray();\n    if (typeof match === 'string') {\n        const matches = new Set(select.filter(match, nodes, this.options));\n        nodes = nodes.filter((el) => !matches.has(el));\n    }\n    else {\n        const filterFn = getFilterFn(match);\n        nodes = nodes.filter((el, i) => !filterFn(el, i));\n    }\n    return this._make(nodes);\n}\n/**\n * Filters the set of matched elements to only those which have the given DOM\n * element as a descendant or which have a descendant that matches the given\n * selector. Equivalent to `.filter(':has(selector)')`.\n *\n * @category Traversing\n * @example <caption>Selector</caption>\n *\n * ```js\n * $('ul').has('.pear').attr('id');\n * //=> fruits\n * ```\n *\n * @example <caption>Element</caption>\n *\n * ```js\n * $('ul').has($('.pear')[0]).attr('id');\n * //=> fruits\n * ```\n *\n * @param selectorOrHaystack - Element to look for.\n * @returns The filtered collection.\n * @see {@link https://api.jquery.com/has/}\n */\nfunction has(selectorOrHaystack) {\n    return this.filter(typeof selectorOrHaystack === 'string'\n        ? // Using the `:has` selector here short-circuits searches.\n            `:has(${selectorOrHaystack})`\n        : (_, el) => this._make(el).find(selectorOrHaystack).length > 0);\n}\n/**\n * Will select the first element of a cheerio object.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('#fruits').children().first().text();\n * //=> Apple\n * ```\n *\n * @returns The first element.\n * @see {@link https://api.jquery.com/first/}\n */\nfunction first() {\n    return this.length > 1 ? this._make(this[0]) : this;\n}\n/**\n * Will select the last element of a cheerio object.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('#fruits').children().last().text();\n * //=> Pear\n * ```\n *\n * @returns The last element.\n * @see {@link https://api.jquery.com/last/}\n */\nfunction last() {\n    return this.length > 0 ? this._make(this[this.length - 1]) : this;\n}\n/**\n * Reduce the set of matched elements to the one at the specified index. Use\n * `.eq(-i)` to count backwards from the last selected element.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('li').eq(0).text();\n * //=> Apple\n *\n * $('li').eq(-1).text();\n * //=> Pear\n * ```\n *\n * @param i - Index of the element to select.\n * @returns The element at the `i`th position.\n * @see {@link https://api.jquery.com/eq/}\n */\nfunction eq(i) {\n    var _a;\n    i = +i;\n    // Use the first identity optimization if possible\n    if (i === 0 && this.length <= 1)\n        return this;\n    if (i < 0)\n        i = this.length + i;\n    return this._make((_a = this[i]) !== null && _a !== void 0 ? _a : []);\n}\nfunction get(i) {\n    if (i == null) {\n        return this.toArray();\n    }\n    return this[i < 0 ? this.length + i : i];\n}\n/**\n * Retrieve all the DOM elements contained in the jQuery set as an array.\n *\n * @example\n *\n * ```js\n * $('li').toArray();\n * //=> [ {...}, {...}, {...} ]\n * ```\n *\n * @returns The contained items.\n */\nfunction toArray() {\n    return Array.prototype.slice.call(this);\n}\n/**\n * Search for a given element from among the matched elements.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('.pear').index();\n * //=> 2 $('.orange').index('li');\n * //=> 1\n * $('.apple').index($('#fruit, li'));\n * //=> 1\n * ```\n *\n * @param selectorOrNeedle - Element to look for.\n * @returns The index of the element.\n * @see {@link https://api.jquery.com/index/}\n */\nfunction index(selectorOrNeedle) {\n    let $haystack;\n    let needle;\n    if (selectorOrNeedle == null) {\n        $haystack = this.parent().children();\n        needle = this[0];\n    }\n    else if (typeof selectorOrNeedle === 'string') {\n        $haystack = this._make(selectorOrNeedle);\n        needle = this[0];\n    }\n    else {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias, unicorn/no-this-assignment\n        $haystack = this;\n        needle = (0, utils_js_1.isCheerio)(selectorOrNeedle)\n            ? selectorOrNeedle[0]\n            : selectorOrNeedle;\n    }\n    return Array.prototype.indexOf.call($haystack, needle);\n}\n/**\n * Gets the elements matching the specified range (0-based position).\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('li').slice(1).eq(0).text();\n * //=> 'Orange'\n *\n * $('li').slice(1, 2).length;\n * //=> 1\n * ```\n *\n * @param start - A position at which the elements begin to be selected. If\n *   negative, it indicates an offset from the end of the set.\n * @param end - A position at which the elements stop being selected. If\n *   negative, it indicates an offset from the end of the set. If omitted, the\n *   range continues until the end of the set.\n * @returns The elements matching the specified range.\n * @see {@link https://api.jquery.com/slice/}\n */\nfunction slice(start, end) {\n    return this._make(Array.prototype.slice.call(this, start, end));\n}\n/**\n * End the most recent filtering operation in the current chain and return the\n * set of matched elements to its previous state.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('li').eq(0).end().length;\n * //=> 3\n * ```\n *\n * @returns The previous state of the set of matched elements.\n * @see {@link https://api.jquery.com/end/}\n */\nfunction end() {\n    var _a;\n    return (_a = this.prevObject) !== null && _a !== void 0 ? _a : this._make([]);\n}\n/**\n * Add elements to the set of matched elements.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('.apple').add('.orange').length;\n * //=> 2\n * ```\n *\n * @param other - Elements to add.\n * @param context - Optionally the context of the new selection.\n * @returns The combined set.\n * @see {@link https://api.jquery.com/add/}\n */\nfunction add(other, context) {\n    const selection = this._make(other, context);\n    const contents = (0, domutils_1.uniqueSort)([...this.get(), ...selection.get()]);\n    return this._make(contents);\n}\n/**\n * Add the previous set of elements on the stack to the current set, optionally\n * filtered by a selector.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('li').eq(0).addBack('.orange').length;\n * //=> 2\n * ```\n *\n * @param selector - Selector for the elements to add.\n * @returns The combined set.\n * @see {@link https://api.jquery.com/addBack/}\n */\nfunction addBack(selector) {\n    return this.prevObject\n        ? this.add(selector ? this.prevObject.filter(selector) : this.prevObject)\n        : this;\n}\n//# sourceMappingURL=traversing.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2hlZXJpby9kaXN0L2NvbW1vbmpzL2FwaS90cmF2ZXJzaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsaUJBQWlCLEdBQUcsZUFBZSxHQUFHLFlBQVksR0FBRyxpQkFBaUIsR0FBRyxlQUFlLEdBQUcsWUFBWSxHQUFHLG9CQUFvQixHQUFHLGVBQWUsR0FBRyxjQUFjO0FBQ3ZNLFlBQVk7QUFDWix1QkFBdUI7QUFDdkIsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQixZQUFZO0FBQ1osV0FBVztBQUNYLGNBQWM7QUFDZCxtQkFBbUI7QUFDbkIsVUFBVTtBQUNWLFdBQVc7QUFDWCxXQUFXO0FBQ1gsYUFBYTtBQUNiLFlBQVk7QUFDWixVQUFVO0FBQ1YsV0FBVztBQUNYLGVBQWU7QUFDZixhQUFhO0FBQ2IsYUFBYTtBQUNiLFdBQVc7QUFDWCxXQUFXO0FBQ1gsZUFBZTtBQUNmLHFCQUFxQixtQkFBTyxDQUFDLGdFQUFZO0FBQ3pDLDRCQUE0QixtQkFBTyxDQUFDLHdFQUFnQjtBQUNwRCxtQkFBbUIsbUJBQU8sQ0FBQyx3RUFBYTtBQUN4QyxvQkFBb0IsbUJBQU8sQ0FBQywwRUFBYztBQUMxQyxtQkFBbUIsbUJBQU8sQ0FBQyw0REFBVTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix5QkFBeUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGNBQWMscUJBQXFCLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLGtCQUFrQixRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZUFBZTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxVQUFVO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxJQUFJLEdBQUcsSUFBSSxHQUFHLEtBQUs7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvaW10aXlhei9EZXNrdG9wL1N1cGVyTGVhcm4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2NoZWVyaW8vZGlzdC9jb21tb25qcy9hcGkvdHJhdmVyc2luZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogTWV0aG9kcyBmb3IgdHJhdmVyc2luZyB0aGUgRE9NIHN0cnVjdHVyZS5cbiAqXG4gKiBAbW9kdWxlIGNoZWVyaW8vdHJhdmVyc2luZ1xuICovXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2hpbGRyZW4gPSBleHBvcnRzLnNpYmxpbmdzID0gZXhwb3J0cy5wcmV2VW50aWwgPSBleHBvcnRzLnByZXZBbGwgPSBleHBvcnRzLnByZXYgPSBleHBvcnRzLm5leHRVbnRpbCA9IGV4cG9ydHMubmV4dEFsbCA9IGV4cG9ydHMubmV4dCA9IGV4cG9ydHMucGFyZW50c1VudGlsID0gZXhwb3J0cy5wYXJlbnRzID0gZXhwb3J0cy5wYXJlbnQgPSB2b2lkIDA7XG5leHBvcnRzLmZpbmQgPSBmaW5kO1xuZXhwb3J0cy5fZmluZEJ5U2VsZWN0b3IgPSBfZmluZEJ5U2VsZWN0b3I7XG5leHBvcnRzLmNsb3Nlc3QgPSBjbG9zZXN0O1xuZXhwb3J0cy5jb250ZW50cyA9IGNvbnRlbnRzO1xuZXhwb3J0cy5lYWNoID0gZWFjaDtcbmV4cG9ydHMubWFwID0gbWFwO1xuZXhwb3J0cy5maWx0ZXIgPSBmaWx0ZXI7XG5leHBvcnRzLmZpbHRlckFycmF5ID0gZmlsdGVyQXJyYXk7XG5leHBvcnRzLmlzID0gaXM7XG5leHBvcnRzLm5vdCA9IG5vdDtcbmV4cG9ydHMuaGFzID0gaGFzO1xuZXhwb3J0cy5maXJzdCA9IGZpcnN0O1xuZXhwb3J0cy5sYXN0ID0gbGFzdDtcbmV4cG9ydHMuZXEgPSBlcTtcbmV4cG9ydHMuZ2V0ID0gZ2V0O1xuZXhwb3J0cy50b0FycmF5ID0gdG9BcnJheTtcbmV4cG9ydHMuaW5kZXggPSBpbmRleDtcbmV4cG9ydHMuc2xpY2UgPSBzbGljZTtcbmV4cG9ydHMuZW5kID0gZW5kO1xuZXhwb3J0cy5hZGQgPSBhZGQ7XG5leHBvcnRzLmFkZEJhY2sgPSBhZGRCYWNrO1xuY29uc3QgZG9taGFuZGxlcl8xID0gcmVxdWlyZShcImRvbWhhbmRsZXJcIik7XG5jb25zdCBzZWxlY3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImNoZWVyaW8tc2VsZWN0XCIpKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMuanNcIik7XG5jb25zdCBzdGF0aWNfanNfMSA9IHJlcXVpcmUoXCIuLi9zdGF0aWMuanNcIik7XG5jb25zdCBkb211dGlsc18xID0gcmVxdWlyZShcImRvbXV0aWxzXCIpO1xuY29uc3QgcmVTaWJsaW5nU2VsZWN0b3IgPSAvXlxccypbK35dLztcbi8qKlxuICogR2V0IHRoZSBkZXNjZW5kYW50cyBvZiBlYWNoIGVsZW1lbnQgaW4gdGhlIGN1cnJlbnQgc2V0IG9mIG1hdGNoZWQgZWxlbWVudHMsXG4gKiBmaWx0ZXJlZCBieSBhIHNlbGVjdG9yLCBqUXVlcnkgb2JqZWN0LCBvciBlbGVtZW50LlxuICpcbiAqIEBjYXRlZ29yeSBUcmF2ZXJzaW5nXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAkKCcjZnJ1aXRzJykuZmluZCgnbGknKS5sZW5ndGg7XG4gKiAvLz0+IDNcbiAqICQoJyNmcnVpdHMnKS5maW5kKCQoJy5hcHBsZScpKS5sZW5ndGg7XG4gKiAvLz0+IDFcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzZWxlY3Rvck9ySGF5c3RhY2sgLSBFbGVtZW50IHRvIGxvb2sgZm9yLlxuICogQHJldHVybnMgVGhlIGZvdW5kIGVsZW1lbnRzLlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9hcGkuanF1ZXJ5LmNvbS9maW5kL31cbiAqL1xuZnVuY3Rpb24gZmluZChzZWxlY3Rvck9ySGF5c3RhY2spIHtcbiAgICBpZiAoIXNlbGVjdG9yT3JIYXlzdGFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFrZShbXSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc2VsZWN0b3JPckhheXN0YWNrICE9PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBoYXlzdGFjayA9ICgwLCB1dGlsc19qc18xLmlzQ2hlZXJpbykoc2VsZWN0b3JPckhheXN0YWNrKVxuICAgICAgICAgICAgPyBzZWxlY3Rvck9ySGF5c3RhY2sudG9BcnJheSgpXG4gICAgICAgICAgICA6IFtzZWxlY3Rvck9ySGF5c3RhY2tdO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy50b0FycmF5KCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYWtlKGhheXN0YWNrLmZpbHRlcigoZWxlbSkgPT4gY29udGV4dC5zb21lKChub2RlKSA9PiAoMCwgc3RhdGljX2pzXzEuY29udGFpbnMpKG5vZGUsIGVsZW0pKSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZmluZEJ5U2VsZWN0b3Ioc2VsZWN0b3JPckhheXN0YWNrLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xufVxuLyoqXG4gKiBGaW5kIGVsZW1lbnRzIGJ5IGEgc3BlY2lmaWMgc2VsZWN0b3IuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjYXRlZ29yeSBUcmF2ZXJzaW5nXG4gKiBAcGFyYW0gc2VsZWN0b3IgLSBTZWxlY3RvciB0byBmaWx0ZXIgYnkuXG4gKiBAcGFyYW0gbGltaXQgLSBNYXhpbXVtIG51bWJlciBvZiBlbGVtZW50cyB0byBtYXRjaC5cbiAqIEByZXR1cm5zIFRoZSBmb3VuZCBlbGVtZW50cy5cbiAqL1xuZnVuY3Rpb24gX2ZpbmRCeVNlbGVjdG9yKHNlbGVjdG9yLCBsaW1pdCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy50b0FycmF5KCk7XG4gICAgY29uc3QgZWxlbXMgPSByZVNpYmxpbmdTZWxlY3Rvci50ZXN0KHNlbGVjdG9yKVxuICAgICAgICA/IGNvbnRleHRcbiAgICAgICAgOiB0aGlzLmNoaWxkcmVuKCkudG9BcnJheSgpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIHJvb3Q6IChfYSA9IHRoaXMuX3Jvb3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSxcbiAgICAgICAgLy8gUGFzcyBvcHRpb25zIHRoYXQgYXJlIHJlY29nbml6ZWQgYnkgYGNoZWVyaW8tc2VsZWN0YFxuICAgICAgICB4bWxNb2RlOiB0aGlzLm9wdGlvbnMueG1sTW9kZSxcbiAgICAgICAgbG93ZXJDYXNlVGFnczogdGhpcy5vcHRpb25zLmxvd2VyQ2FzZVRhZ3MsXG4gICAgICAgIGxvd2VyQ2FzZUF0dHJpYnV0ZU5hbWVzOiB0aGlzLm9wdGlvbnMubG93ZXJDYXNlQXR0cmlidXRlTmFtZXMsXG4gICAgICAgIHBzZXVkb3M6IHRoaXMub3B0aW9ucy5wc2V1ZG9zLFxuICAgICAgICBxdWlya3NNb2RlOiB0aGlzLm9wdGlvbnMucXVpcmtzTW9kZSxcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl9tYWtlKHNlbGVjdC5zZWxlY3Qoc2VsZWN0b3IsIGVsZW1zLCBvcHRpb25zLCBsaW1pdCkpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0Y2hlciwgdXNpbmcgYSBwYXJ0aWN1bGFyIG1hcHBpbmcgZnVuY3Rpb24uIE1hdGNoZXJzIHByb3ZpZGUgYVxuICogZnVuY3Rpb24gdGhhdCBmaW5kcyBlbGVtZW50cyB1c2luZyBhIGdlbmVyYXRpbmcgZnVuY3Rpb24sIHN1cHBvcnRpbmdcbiAqIGZpbHRlcmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIG1hdGNoTWFwIC0gTWFwcGluZyBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIC0gRnVuY3Rpb24gZm9yIHdyYXBwaW5nIGdlbmVyYXRpbmcgZnVuY3Rpb25zLlxuICovXG5mdW5jdGlvbiBfZ2V0TWF0Y2hlcihtYXRjaE1hcCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZm4sIC4uLnBvc3RGbnMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgbGV0IG1hdGNoZWQgPSBtYXRjaE1hcChmbiwgdGhpcyk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gZmlsdGVyQXJyYXkobWF0Y2hlZCwgc2VsZWN0b3IsIHRoaXMub3B0aW9ucy54bWxNb2RlLCAoX2EgPSB0aGlzLl9yb290KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21ha2UoXG4gICAgICAgICAgICAvLyBQb3N0IHByb2Nlc3NpbmcgaXMgb25seSBuZWNlc3NhcnkgaWYgdGhlcmUgaXMgbW9yZSB0aGFuIG9uZSBlbGVtZW50LlxuICAgICAgICAgICAgdGhpcy5sZW5ndGggPiAxICYmIG1hdGNoZWQubGVuZ3RoID4gMVxuICAgICAgICAgICAgICAgID8gcG9zdEZucy5yZWR1Y2UoKGVsZW1zLCBmbikgPT4gZm4oZWxlbXMpLCBtYXRjaGVkKVxuICAgICAgICAgICAgICAgIDogbWF0Y2hlZCk7XG4gICAgICAgIH07XG4gICAgfTtcbn1cbi8qKiBNYXRjaGVyIHRoYXQgYWRkcyBtdWx0aXBsZSBlbGVtZW50cyBmb3IgZWFjaCBlbnRyeSBpbiB0aGUgaW5wdXQuICovXG5jb25zdCBfbWF0Y2hlciA9IF9nZXRNYXRjaGVyKChmbiwgZWxlbXMpID0+IHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGZuKGVsZW1zW2ldKTtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDApXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn0pO1xuLyoqIE1hdGNoZXIgdGhhdCBhZGRzIGF0IG1vc3Qgb25lIGVsZW1lbnQgZm9yIGVhY2ggZW50cnkgaW4gdGhlIGlucHV0LiAqL1xuY29uc3QgX3NpbmdsZU1hdGNoZXIgPSBfZ2V0TWF0Y2hlcigoZm4sIGVsZW1zKSA9PiB7XG4gICAgY29uc3QgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGZuKGVsZW1zW2ldKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn0pO1xuLyoqXG4gKiBNYXRjaGVyIHRoYXQgc3VwcG9ydHMgdHJhdmVyc2luZyB1bnRpbCBhIGNvbmRpdGlvbiBpcyBtZXQuXG4gKlxuICogQHBhcmFtIG5leHRFbGVtIC0gRnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBuZXh0IGVsZW1lbnQuXG4gKiBAcGFyYW0gcG9zdEZucyAtIFBvc3QgcHJvY2Vzc2luZyBmdW5jdGlvbnMuXG4gKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHVzYWJsZSBmb3IgYCpVbnRpbGAgbWV0aG9kcy5cbiAqL1xuZnVuY3Rpb24gX21hdGNoVW50aWwobmV4dEVsZW0sIC4uLnBvc3RGbnMpIHtcbiAgICAvLyBXZSB1c2UgYSB2YXJpYWJsZSBoZXJlIHRoYXQgaXMgdXNlZCBmcm9tIHdpdGhpbiB0aGUgbWF0Y2hlci5cbiAgICBsZXQgbWF0Y2hlcyA9IG51bGw7XG4gICAgY29uc3QgaW5uZXJNYXRjaGVyID0gX2dldE1hdGNoZXIoKG5leHRFbGVtLCBlbGVtcykgPT4ge1xuICAgICAgICBjb25zdCBtYXRjaGVkID0gW107XG4gICAgICAgICgwLCB1dGlsc19qc18xLmRvbUVhY2gpKGVsZW1zLCAoZWxlbSkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgbmV4dDsgKG5leHQgPSBuZXh0RWxlbShlbGVtKSk7IGVsZW0gPSBuZXh0KSB7XG4gICAgICAgICAgICAgICAgLy8gRklYTUU6IGBtYXRjaGVkYCBtaWdodCBjb250YWluIGR1cGxpY2F0ZXMgaGVyZSBhbmQgdGhlIGluZGV4IGlzIHRvbyBsYXJnZS5cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCB8fCBtYXRjaGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXRjaGVzKG5leHQsIG1hdGNoZWQubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZC5wdXNoKG5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1hdGNoZWQ7XG4gICAgfSkobmV4dEVsZW0sIC4uLnBvc3RGbnMpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoc2VsZWN0b3IsIGZpbHRlclNlbGVjdG9yKSB7XG4gICAgICAgIC8vIE92ZXJyaWRlIGBtYXRjaGVzYCB2YXJpYWJsZSB3aXRoIHRoZSBuZXcgdGFyZ2V0LlxuICAgICAgICBtYXRjaGVzID1cbiAgICAgICAgICAgIHR5cGVvZiBzZWxlY3RvciA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICA/IChlbGVtKSA9PiBzZWxlY3QuaXMoZWxlbSwgc2VsZWN0b3IsIHRoaXMub3B0aW9ucylcbiAgICAgICAgICAgICAgICA6IHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgICAgID8gZ2V0RmlsdGVyRm4oc2VsZWN0b3IpXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgY29uc3QgcmV0ID0gaW5uZXJNYXRjaGVyLmNhbGwodGhpcywgZmlsdGVyU2VsZWN0b3IpO1xuICAgICAgICAvLyBTZXQgYG1hdGNoZXNgIHRvIGBudWxsYCwgc28gd2UgZG9uJ3Qgd2FzdGUgbWVtb3J5LlxuICAgICAgICBtYXRjaGVzID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xufVxuZnVuY3Rpb24gX3JlbW92ZUR1cGxpY2F0ZXMoZWxlbXMpIHtcbiAgICByZXR1cm4gZWxlbXMubGVuZ3RoID4gMSA/IEFycmF5LmZyb20obmV3IFNldChlbGVtcykpIDogZWxlbXM7XG59XG4vKipcbiAqIEdldCB0aGUgcGFyZW50IG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgY3VycmVudCBzZXQgb2YgbWF0Y2hlZCBlbGVtZW50cyxcbiAqIG9wdGlvbmFsbHkgZmlsdGVyZWQgYnkgYSBzZWxlY3Rvci5cbiAqXG4gKiBAY2F0ZWdvcnkgVHJhdmVyc2luZ1xuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogJCgnLnBlYXInKS5wYXJlbnQoKS5hdHRyKCdpZCcpO1xuICogLy89PiBmcnVpdHNcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzZWxlY3RvciAtIElmIHNwZWNpZmllZCBmaWx0ZXIgZm9yIHBhcmVudC5cbiAqIEByZXR1cm5zIFRoZSBwYXJlbnRzLlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9hcGkuanF1ZXJ5LmNvbS9wYXJlbnQvfVxuICovXG5leHBvcnRzLnBhcmVudCA9IF9zaW5nbGVNYXRjaGVyKCh7IHBhcmVudCB9KSA9PiAocGFyZW50ICYmICEoMCwgZG9taGFuZGxlcl8xLmlzRG9jdW1lbnQpKHBhcmVudCkgPyBwYXJlbnQgOiBudWxsKSwgX3JlbW92ZUR1cGxpY2F0ZXMpO1xuLyoqXG4gKiBHZXQgYSBzZXQgb2YgcGFyZW50cyBmaWx0ZXJlZCBieSBgc2VsZWN0b3JgIG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgY3VycmVudFxuICogc2V0IG9mIG1hdGNoIGVsZW1lbnRzLlxuICpcbiAqIEBjYXRlZ29yeSBUcmF2ZXJzaW5nXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAkKCcub3JhbmdlJykucGFyZW50cygpLmxlbmd0aDtcbiAqIC8vPT4gMlxuICogJCgnLm9yYW5nZScpLnBhcmVudHMoJyNmcnVpdHMnKS5sZW5ndGg7XG4gKiAvLz0+IDFcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzZWxlY3RvciAtIElmIHNwZWNpZmllZCBmaWx0ZXIgZm9yIHBhcmVudHMuXG4gKiBAcmV0dXJucyBUaGUgcGFyZW50cy5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vYXBpLmpxdWVyeS5jb20vcGFyZW50cy99XG4gKi9cbmV4cG9ydHMucGFyZW50cyA9IF9tYXRjaGVyKChlbGVtKSA9PiB7XG4gICAgY29uc3QgbWF0Y2hlZCA9IFtdO1xuICAgIHdoaWxlIChlbGVtLnBhcmVudCAmJiAhKDAsIGRvbWhhbmRsZXJfMS5pc0RvY3VtZW50KShlbGVtLnBhcmVudCkpIHtcbiAgICAgICAgbWF0Y2hlZC5wdXNoKGVsZW0ucGFyZW50KTtcbiAgICAgICAgZWxlbSA9IGVsZW0ucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hlZDtcbn0sIGRvbXV0aWxzXzEudW5pcXVlU29ydCwgKGVsZW1zKSA9PiBlbGVtcy5yZXZlcnNlKCkpO1xuLyoqXG4gKiBHZXQgdGhlIGFuY2VzdG9ycyBvZiBlYWNoIGVsZW1lbnQgaW4gdGhlIGN1cnJlbnQgc2V0IG9mIG1hdGNoZWQgZWxlbWVudHMsIHVwXG4gKiB0byBidXQgbm90IGluY2x1ZGluZyB0aGUgZWxlbWVudCBtYXRjaGVkIGJ5IHRoZSBzZWxlY3RvciwgRE9NIG5vZGUsIG9yXG4gKiBjaGVlcmlvIG9iamVjdC5cbiAqXG4gKiBAY2F0ZWdvcnkgVHJhdmVyc2luZ1xuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogJCgnLm9yYW5nZScpLnBhcmVudHNVbnRpbCgnI2Zvb2QnKS5sZW5ndGg7XG4gKiAvLz0+IDFcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzZWxlY3RvciAtIFNlbGVjdG9yIGZvciBlbGVtZW50IHRvIHN0b3AgYXQuXG4gKiBAcGFyYW0gZmlsdGVyU2VsZWN0b3IgLSBPcHRpb25hbCBmaWx0ZXIgZm9yIHBhcmVudHMuXG4gKiBAcmV0dXJucyBUaGUgcGFyZW50cy5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vYXBpLmpxdWVyeS5jb20vcGFyZW50c1VudGlsL31cbiAqL1xuZXhwb3J0cy5wYXJlbnRzVW50aWwgPSBfbWF0Y2hVbnRpbCgoeyBwYXJlbnQgfSkgPT4gKHBhcmVudCAmJiAhKDAsIGRvbWhhbmRsZXJfMS5pc0RvY3VtZW50KShwYXJlbnQpID8gcGFyZW50IDogbnVsbCksIGRvbXV0aWxzXzEudW5pcXVlU29ydCwgKGVsZW1zKSA9PiBlbGVtcy5yZXZlcnNlKCkpO1xuLyoqXG4gKiBGb3IgZWFjaCBlbGVtZW50IGluIHRoZSBzZXQsIGdldCB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIHNlbGVjdG9yXG4gKiBieSB0ZXN0aW5nIHRoZSBlbGVtZW50IGl0c2VsZiBhbmQgdHJhdmVyc2luZyB1cCB0aHJvdWdoIGl0cyBhbmNlc3RvcnMgaW4gdGhlXG4gKiBET00gdHJlZS5cbiAqXG4gKiBAY2F0ZWdvcnkgVHJhdmVyc2luZ1xuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogJCgnLm9yYW5nZScpLmNsb3Nlc3QoKTtcbiAqIC8vPT4gW11cbiAqXG4gKiAkKCcub3JhbmdlJykuY2xvc2VzdCgnLmFwcGxlJyk7XG4gKiAvLyA9PiBbXVxuICpcbiAqICQoJy5vcmFuZ2UnKS5jbG9zZXN0KCdsaScpO1xuICogLy89PiBbPGxpIGNsYXNzPVwib3JhbmdlXCI+T3JhbmdlPC9saT5dXG4gKlxuICogJCgnLm9yYW5nZScpLmNsb3Nlc3QoJyNmcnVpdHMnKTtcbiAqIC8vPT4gWzx1bCBpZD1cImZydWl0c1wiPiAuLi4gPC91bD5dXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2VsZWN0b3IgLSBTZWxlY3RvciBmb3IgdGhlIGVsZW1lbnQgdG8gZmluZC5cbiAqIEByZXR1cm5zIFRoZSBjbG9zZXN0IG5vZGVzLlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9hcGkuanF1ZXJ5LmNvbS9jbG9zZXN0L31cbiAqL1xuZnVuY3Rpb24gY2xvc2VzdChzZWxlY3Rvcikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBzZXQgPSBbXTtcbiAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYWtlKHNldCk7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdE9wdHMgPSB7XG4gICAgICAgIHhtbE1vZGU6IHRoaXMub3B0aW9ucy54bWxNb2RlLFxuICAgICAgICByb290OiAoX2EgPSB0aGlzLl9yb290KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0sXG4gICAgfTtcbiAgICBjb25zdCBzZWxlY3RGbiA9IHR5cGVvZiBzZWxlY3RvciA9PT0gJ3N0cmluZydcbiAgICAgICAgPyAoZWxlbSkgPT4gc2VsZWN0LmlzKGVsZW0sIHNlbGVjdG9yLCBzZWxlY3RPcHRzKVxuICAgICAgICA6IGdldEZpbHRlckZuKHNlbGVjdG9yKTtcbiAgICAoMCwgdXRpbHNfanNfMS5kb21FYWNoKSh0aGlzLCAoZWxlbSkgPT4ge1xuICAgICAgICBpZiAoZWxlbSAmJiAhKDAsIGRvbWhhbmRsZXJfMS5pc0RvY3VtZW50KShlbGVtKSAmJiAhKDAsIGRvbWhhbmRsZXJfMS5pc1RhZykoZWxlbSkpIHtcbiAgICAgICAgICAgIGVsZW0gPSBlbGVtLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoZWxlbSAmJiAoMCwgZG9taGFuZGxlcl8xLmlzVGFnKShlbGVtKSkge1xuICAgICAgICAgICAgaWYgKHNlbGVjdEZuKGVsZW0sIDApKSB7XG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IGFkZCBkdXBsaWNhdGUgZWxlbWVudHMgdG8gdGhlIHNldFxuICAgICAgICAgICAgICAgIGlmICghc2V0LmluY2x1ZGVzKGVsZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldC5wdXNoKGVsZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW0gPSBlbGVtLnBhcmVudDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLl9tYWtlKHNldCk7XG59XG4vKipcbiAqIEdldHMgdGhlIG5leHQgc2libGluZyBvZiBlYWNoIHNlbGVjdGVkIGVsZW1lbnQsIG9wdGlvbmFsbHkgZmlsdGVyZWQgYnkgYVxuICogc2VsZWN0b3IuXG4gKlxuICogQGNhdGVnb3J5IFRyYXZlcnNpbmdcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqICQoJy5hcHBsZScpLm5leHQoKS5oYXNDbGFzcygnb3JhbmdlJyk7XG4gKiAvLz0+IHRydWVcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzZWxlY3RvciAtIElmIHNwZWNpZmllZCBmaWx0ZXIgZm9yIHNpYmxpbmcuXG4gKiBAcmV0dXJucyBUaGUgbmV4dCBub2Rlcy5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vYXBpLmpxdWVyeS5jb20vbmV4dC99XG4gKi9cbmV4cG9ydHMubmV4dCA9IF9zaW5nbGVNYXRjaGVyKChlbGVtKSA9PiAoMCwgZG9tdXRpbHNfMS5uZXh0RWxlbWVudFNpYmxpbmcpKGVsZW0pKTtcbi8qKlxuICogR2V0cyBhbGwgdGhlIGZvbGxvd2luZyBzaWJsaW5ncyBvZiB0aGUgZWFjaCBzZWxlY3RlZCBlbGVtZW50LCBvcHRpb25hbGx5XG4gKiBmaWx0ZXJlZCBieSBhIHNlbGVjdG9yLlxuICpcbiAqIEBjYXRlZ29yeSBUcmF2ZXJzaW5nXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAkKCcuYXBwbGUnKS5uZXh0QWxsKCk7XG4gKiAvLz0+IFs8bGkgY2xhc3M9XCJvcmFuZ2VcIj5PcmFuZ2U8L2xpPiwgPGxpIGNsYXNzPVwicGVhclwiPlBlYXI8L2xpPl1cbiAqICQoJy5hcHBsZScpLm5leHRBbGwoJy5vcmFuZ2UnKTtcbiAqIC8vPT4gWzxsaSBjbGFzcz1cIm9yYW5nZVwiPk9yYW5nZTwvbGk+XVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNlbGVjdG9yIC0gSWYgc3BlY2lmaWVkIGZpbHRlciBmb3Igc2libGluZ3MuXG4gKiBAcmV0dXJucyBUaGUgbmV4dCBub2Rlcy5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vYXBpLmpxdWVyeS5jb20vbmV4dEFsbC99XG4gKi9cbmV4cG9ydHMubmV4dEFsbCA9IF9tYXRjaGVyKChlbGVtKSA9PiB7XG4gICAgY29uc3QgbWF0Y2hlZCA9IFtdO1xuICAgIHdoaWxlIChlbGVtLm5leHQpIHtcbiAgICAgICAgZWxlbSA9IGVsZW0ubmV4dDtcbiAgICAgICAgaWYgKCgwLCBkb21oYW5kbGVyXzEuaXNUYWcpKGVsZW0pKVxuICAgICAgICAgICAgbWF0Y2hlZC5wdXNoKGVsZW0pO1xuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hlZDtcbn0sIF9yZW1vdmVEdXBsaWNhdGVzKTtcbi8qKlxuICogR2V0cyBhbGwgdGhlIGZvbGxvd2luZyBzaWJsaW5ncyB1cCB0byBidXQgbm90IGluY2x1ZGluZyB0aGUgZWxlbWVudCBtYXRjaGVkXG4gKiBieSB0aGUgc2VsZWN0b3IsIG9wdGlvbmFsbHkgZmlsdGVyZWQgYnkgYW5vdGhlciBzZWxlY3Rvci5cbiAqXG4gKiBAY2F0ZWdvcnkgVHJhdmVyc2luZ1xuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogJCgnLmFwcGxlJykubmV4dFVudGlsKCcucGVhcicpO1xuICogLy89PiBbPGxpIGNsYXNzPVwib3JhbmdlXCI+T3JhbmdlPC9saT5dXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2VsZWN0b3IgLSBTZWxlY3RvciBmb3IgZWxlbWVudCB0byBzdG9wIGF0LlxuICogQHBhcmFtIGZpbHRlclNlbGVjdG9yIC0gSWYgc3BlY2lmaWVkIGZpbHRlciBmb3Igc2libGluZ3MuXG4gKiBAcmV0dXJucyBUaGUgbmV4dCBub2Rlcy5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vYXBpLmpxdWVyeS5jb20vbmV4dFVudGlsL31cbiAqL1xuZXhwb3J0cy5uZXh0VW50aWwgPSBfbWF0Y2hVbnRpbCgoZWwpID0+ICgwLCBkb211dGlsc18xLm5leHRFbGVtZW50U2libGluZykoZWwpLCBfcmVtb3ZlRHVwbGljYXRlcyk7XG4vKipcbiAqIEdldHMgdGhlIHByZXZpb3VzIHNpYmxpbmcgb2YgZWFjaCBzZWxlY3RlZCBlbGVtZW50IG9wdGlvbmFsbHkgZmlsdGVyZWQgYnkgYVxuICogc2VsZWN0b3IuXG4gKlxuICogQGNhdGVnb3J5IFRyYXZlcnNpbmdcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqICQoJy5vcmFuZ2UnKS5wcmV2KCkuaGFzQ2xhc3MoJ2FwcGxlJyk7XG4gKiAvLz0+IHRydWVcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzZWxlY3RvciAtIElmIHNwZWNpZmllZCBmaWx0ZXIgZm9yIHNpYmxpbmdzLlxuICogQHJldHVybnMgVGhlIHByZXZpb3VzIG5vZGVzLlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9hcGkuanF1ZXJ5LmNvbS9wcmV2L31cbiAqL1xuZXhwb3J0cy5wcmV2ID0gX3NpbmdsZU1hdGNoZXIoKGVsZW0pID0+ICgwLCBkb211dGlsc18xLnByZXZFbGVtZW50U2libGluZykoZWxlbSkpO1xuLyoqXG4gKiBHZXRzIGFsbCB0aGUgcHJlY2VkaW5nIHNpYmxpbmdzIG9mIGVhY2ggc2VsZWN0ZWQgZWxlbWVudCwgb3B0aW9uYWxseSBmaWx0ZXJlZFxuICogYnkgYSBzZWxlY3Rvci5cbiAqXG4gKiBAY2F0ZWdvcnkgVHJhdmVyc2luZ1xuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogJCgnLnBlYXInKS5wcmV2QWxsKCk7XG4gKiAvLz0+IFs8bGkgY2xhc3M9XCJvcmFuZ2VcIj5PcmFuZ2U8L2xpPiwgPGxpIGNsYXNzPVwiYXBwbGVcIj5BcHBsZTwvbGk+XVxuICpcbiAqICQoJy5wZWFyJykucHJldkFsbCgnLm9yYW5nZScpO1xuICogLy89PiBbPGxpIGNsYXNzPVwib3JhbmdlXCI+T3JhbmdlPC9saT5dXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2VsZWN0b3IgLSBJZiBzcGVjaWZpZWQgZmlsdGVyIGZvciBzaWJsaW5ncy5cbiAqIEByZXR1cm5zIFRoZSBwcmV2aW91cyBub2Rlcy5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vYXBpLmpxdWVyeS5jb20vcHJldkFsbC99XG4gKi9cbmV4cG9ydHMucHJldkFsbCA9IF9tYXRjaGVyKChlbGVtKSA9PiB7XG4gICAgY29uc3QgbWF0Y2hlZCA9IFtdO1xuICAgIHdoaWxlIChlbGVtLnByZXYpIHtcbiAgICAgICAgZWxlbSA9IGVsZW0ucHJldjtcbiAgICAgICAgaWYgKCgwLCBkb21oYW5kbGVyXzEuaXNUYWcpKGVsZW0pKVxuICAgICAgICAgICAgbWF0Y2hlZC5wdXNoKGVsZW0pO1xuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hlZDtcbn0sIF9yZW1vdmVEdXBsaWNhdGVzKTtcbi8qKlxuICogR2V0cyBhbGwgdGhlIHByZWNlZGluZyBzaWJsaW5ncyB1cCB0byBidXQgbm90IGluY2x1ZGluZyB0aGUgZWxlbWVudCBtYXRjaGVkXG4gKiBieSB0aGUgc2VsZWN0b3IsIG9wdGlvbmFsbHkgZmlsdGVyZWQgYnkgYW5vdGhlciBzZWxlY3Rvci5cbiAqXG4gKiBAY2F0ZWdvcnkgVHJhdmVyc2luZ1xuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogJCgnLnBlYXInKS5wcmV2VW50aWwoJy5hcHBsZScpO1xuICogLy89PiBbPGxpIGNsYXNzPVwib3JhbmdlXCI+T3JhbmdlPC9saT5dXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2VsZWN0b3IgLSBTZWxlY3RvciBmb3IgZWxlbWVudCB0byBzdG9wIGF0LlxuICogQHBhcmFtIGZpbHRlclNlbGVjdG9yIC0gSWYgc3BlY2lmaWVkIGZpbHRlciBmb3Igc2libGluZ3MuXG4gKiBAcmV0dXJucyBUaGUgcHJldmlvdXMgbm9kZXMuXG4gKiBAc2VlIHtAbGluayBodHRwczovL2FwaS5qcXVlcnkuY29tL3ByZXZVbnRpbC99XG4gKi9cbmV4cG9ydHMucHJldlVudGlsID0gX21hdGNoVW50aWwoKGVsKSA9PiAoMCwgZG9tdXRpbHNfMS5wcmV2RWxlbWVudFNpYmxpbmcpKGVsKSwgX3JlbW92ZUR1cGxpY2F0ZXMpO1xuLyoqXG4gKiBHZXQgdGhlIHNpYmxpbmdzIG9mIGVhY2ggZWxlbWVudCAoZXhjbHVkaW5nIHRoZSBlbGVtZW50KSBpbiB0aGUgc2V0IG9mXG4gKiBtYXRjaGVkIGVsZW1lbnRzLCBvcHRpb25hbGx5IGZpbHRlcmVkIGJ5IGEgc2VsZWN0b3IuXG4gKlxuICogQGNhdGVnb3J5IFRyYXZlcnNpbmdcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqICQoJy5wZWFyJykuc2libGluZ3MoKS5sZW5ndGg7XG4gKiAvLz0+IDJcbiAqXG4gKiAkKCcucGVhcicpLnNpYmxpbmdzKCcub3JhbmdlJykubGVuZ3RoO1xuICogLy89PiAxXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2VsZWN0b3IgLSBJZiBzcGVjaWZpZWQgZmlsdGVyIGZvciBzaWJsaW5ncy5cbiAqIEByZXR1cm5zIFRoZSBzaWJsaW5ncy5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vYXBpLmpxdWVyeS5jb20vc2libGluZ3MvfVxuICovXG5leHBvcnRzLnNpYmxpbmdzID0gX21hdGNoZXIoKGVsZW0pID0+ICgwLCBkb211dGlsc18xLmdldFNpYmxpbmdzKShlbGVtKS5maWx0ZXIoKGVsKSA9PiAoMCwgZG9taGFuZGxlcl8xLmlzVGFnKShlbCkgJiYgZWwgIT09IGVsZW0pLCBkb211dGlsc18xLnVuaXF1ZVNvcnQpO1xuLyoqXG4gKiBHZXRzIHRoZSBlbGVtZW50IGNoaWxkcmVuIG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0IG9mIG1hdGNoZWQgZWxlbWVudHMuXG4gKlxuICogQGNhdGVnb3J5IFRyYXZlcnNpbmdcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqICQoJyNmcnVpdHMnKS5jaGlsZHJlbigpLmxlbmd0aDtcbiAqIC8vPT4gM1xuICpcbiAqICQoJyNmcnVpdHMnKS5jaGlsZHJlbignLnBlYXInKS50ZXh0KCk7XG4gKiAvLz0+IFBlYXJcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzZWxlY3RvciAtIElmIHNwZWNpZmllZCBmaWx0ZXIgZm9yIGNoaWxkcmVuLlxuICogQHJldHVybnMgVGhlIGNoaWxkcmVuLlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9hcGkuanF1ZXJ5LmNvbS9jaGlsZHJlbi99XG4gKi9cbmV4cG9ydHMuY2hpbGRyZW4gPSBfbWF0Y2hlcigoZWxlbSkgPT4gKDAsIGRvbXV0aWxzXzEuZ2V0Q2hpbGRyZW4pKGVsZW0pLmZpbHRlcihkb21oYW5kbGVyXzEuaXNUYWcpLCBfcmVtb3ZlRHVwbGljYXRlcyk7XG4vKipcbiAqIEdldHMgdGhlIGNoaWxkcmVuIG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0IG9mIG1hdGNoZWQgZWxlbWVudHMsIGluY2x1ZGluZ1xuICogdGV4dCBhbmQgY29tbWVudCBub2Rlcy5cbiAqXG4gKiBAY2F0ZWdvcnkgVHJhdmVyc2luZ1xuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogJCgnI2ZydWl0cycpLmNvbnRlbnRzKCkubGVuZ3RoO1xuICogLy89PiAzXG4gKiBgYGBcbiAqXG4gKiBAcmV0dXJucyBUaGUgY2hpbGRyZW4uXG4gKiBAc2VlIHtAbGluayBodHRwczovL2FwaS5qcXVlcnkuY29tL2NvbnRlbnRzL31cbiAqL1xuZnVuY3Rpb24gY29udGVudHMoKSB7XG4gICAgY29uc3QgZWxlbXMgPSB0aGlzLnRvQXJyYXkoKS5yZWR1Y2UoKG5ld0VsZW1zLCBlbGVtKSA9PiAoMCwgZG9taGFuZGxlcl8xLmhhc0NoaWxkcmVuKShlbGVtKSA/IG5ld0VsZW1zLmNvbmNhdChlbGVtLmNoaWxkcmVuKSA6IG5ld0VsZW1zLCBbXSk7XG4gICAgcmV0dXJuIHRoaXMuX21ha2UoZWxlbXMpO1xufVxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGEgY2hlZXJpbyBvYmplY3QsIGV4ZWN1dGluZyBhIGZ1bmN0aW9uIGZvciBlYWNoIG1hdGNoZWRcbiAqIGVsZW1lbnQuIFdoZW4gdGhlIGNhbGxiYWNrIGlzIGZpcmVkLCB0aGUgZnVuY3Rpb24gaXMgZmlyZWQgaW4gdGhlIGNvbnRleHQgb2ZcbiAqIHRoZSBET00gZWxlbWVudCwgc28gYHRoaXNgIHJlZmVycyB0byB0aGUgY3VycmVudCBlbGVtZW50LCB3aGljaCBpcyBlcXVpdmFsZW50XG4gKiB0byB0aGUgZnVuY3Rpb24gcGFyYW1ldGVyIGBlbGVtZW50YC4gVG8gYnJlYWsgb3V0IG9mIHRoZSBgZWFjaGAgbG9vcCBlYXJseSxcbiAqIHJldHVybiB3aXRoIGBmYWxzZWAuXG4gKlxuICogQGNhdGVnb3J5IFRyYXZlcnNpbmdcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGZydWl0cyA9IFtdO1xuICpcbiAqICQoJ2xpJykuZWFjaChmdW5jdGlvbiAoaSwgZWxlbSkge1xuICogICBmcnVpdHNbaV0gPSAkKHRoaXMpLnRleHQoKTtcbiAqIH0pO1xuICpcbiAqIGZydWl0cy5qb2luKCcsICcpO1xuICogLy89PiBBcHBsZSwgT3JhbmdlLCBQZWFyXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZm4gLSBGdW5jdGlvbiB0byBleGVjdXRlLlxuICogQHJldHVybnMgVGhlIGluc3RhbmNlIGl0c2VsZiwgdXNlZnVsIGZvciBjaGFpbmluZy5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vYXBpLmpxdWVyeS5jb20vZWFjaC99XG4gKi9cbmZ1bmN0aW9uIGVhY2goZm4pIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGg7XG4gICAgd2hpbGUgKGkgPCBsZW4gJiYgZm4uY2FsbCh0aGlzW2ldLCBpLCB0aGlzW2ldKSAhPT0gZmFsc2UpXG4gICAgICAgICsraTtcbiAgICByZXR1cm4gdGhpcztcbn1cbi8qKlxuICogUGFzcyBlYWNoIGVsZW1lbnQgaW4gdGhlIGN1cnJlbnQgbWF0Y2hlZCBzZXQgdGhyb3VnaCBhIGZ1bmN0aW9uLCBwcm9kdWNpbmcgYVxuICogbmV3IENoZWVyaW8gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHJldHVybiB2YWx1ZXMuIFRoZSBmdW5jdGlvbiBjYW4gcmV0dXJuIGFuXG4gKiBpbmRpdmlkdWFsIGRhdGEgaXRlbSBvciBhbiBhcnJheSBvZiBkYXRhIGl0ZW1zIHRvIGJlIGluc2VydGVkIGludG8gdGhlXG4gKiByZXN1bHRpbmcgc2V0LiBJZiBhbiBhcnJheSBpcyByZXR1cm5lZCwgdGhlIGVsZW1lbnRzIGluc2lkZSB0aGUgYXJyYXkgYXJlXG4gKiBpbnNlcnRlZCBpbnRvIHRoZSBzZXQuIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIG51bGwgb3IgdW5kZWZpbmVkLCBubyBlbGVtZW50XG4gKiB3aWxsIGJlIGluc2VydGVkLlxuICpcbiAqIEBjYXRlZ29yeSBUcmF2ZXJzaW5nXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAkKCdsaScpXG4gKiAgIC5tYXAoZnVuY3Rpb24gKGksIGVsKSB7XG4gKiAgICAgLy8gdGhpcyA9PT0gZWxcbiAqICAgICByZXR1cm4gJCh0aGlzKS50ZXh0KCk7XG4gKiAgIH0pXG4gKiAgIC50b0FycmF5KClcbiAqICAgLmpvaW4oJyAnKTtcbiAqIC8vPT4gXCJhcHBsZSBvcmFuZ2UgcGVhclwiXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZm4gLSBGdW5jdGlvbiB0byBleGVjdXRlLlxuICogQHJldHVybnMgVGhlIG1hcHBlZCBlbGVtZW50cywgd3JhcHBlZCBpbiBhIENoZWVyaW8gY29sbGVjdGlvbi5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vYXBpLmpxdWVyeS5jb20vbWFwL31cbiAqL1xuZnVuY3Rpb24gbWFwKGZuKSB7XG4gICAgbGV0IGVsZW1zID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVsID0gdGhpc1tpXTtcbiAgICAgICAgY29uc3QgdmFsID0gZm4uY2FsbChlbCwgaSwgZWwpO1xuICAgICAgICBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgICAgICAgIGVsZW1zID0gZWxlbXMuY29uY2F0KHZhbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX21ha2UoZWxlbXMpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdG8gdGVzdCBpZiBhIGZpbHRlciBpcyBtYXRjaGVkLlxuICpcbiAqIEBwYXJhbSBtYXRjaCAtIEEgZmlsdGVyLlxuICogQHJldHVybnMgQSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgaWYgYSBmaWx0ZXIgaGFzIGJlZW4gbWF0Y2hlZC5cbiAqL1xuZnVuY3Rpb24gZ2V0RmlsdGVyRm4obWF0Y2gpIHtcbiAgICBpZiAodHlwZW9mIG1hdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiAoZWwsIGkpID0+IG1hdGNoLmNhbGwoZWwsIGksIGVsKTtcbiAgICB9XG4gICAgaWYgKCgwLCB1dGlsc19qc18xLmlzQ2hlZXJpbykobWF0Y2gpKSB7XG4gICAgICAgIHJldHVybiAoZWwpID0+IEFycmF5LnByb3RvdHlwZS5pbmNsdWRlcy5jYWxsKG1hdGNoLCBlbCk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoID09PSBlbDtcbiAgICB9O1xufVxuZnVuY3Rpb24gZmlsdGVyKG1hdGNoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiB0aGlzLl9tYWtlKGZpbHRlckFycmF5KHRoaXMudG9BcnJheSgpLCBtYXRjaCwgdGhpcy5vcHRpb25zLnhtbE1vZGUsIChfYSA9IHRoaXMuX3Jvb3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkpO1xufVxuZnVuY3Rpb24gZmlsdGVyQXJyYXkobm9kZXMsIG1hdGNoLCB4bWxNb2RlLCByb290KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBtYXRjaCA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBzZWxlY3QuZmlsdGVyKG1hdGNoLCBub2RlcywgeyB4bWxNb2RlLCByb290IH0pXG4gICAgICAgIDogbm9kZXMuZmlsdGVyKGdldEZpbHRlckZuKG1hdGNoKSk7XG59XG4vKipcbiAqIENoZWNrcyB0aGUgY3VycmVudCBsaXN0IG9mIGVsZW1lbnRzIGFuZCByZXR1cm5zIGB0cnVlYCBpZiBfYW55XyBvZiB0aGVcbiAqIGVsZW1lbnRzIG1hdGNoIHRoZSBzZWxlY3Rvci4gSWYgdXNpbmcgYW4gZWxlbWVudCBvciBDaGVlcmlvIHNlbGVjdGlvbixcbiAqIHJldHVybnMgYHRydWVgIGlmIF9hbnlfIG9mIHRoZSBlbGVtZW50cyBtYXRjaC4gSWYgdXNpbmcgYSBwcmVkaWNhdGUgZnVuY3Rpb24sXG4gKiB0aGUgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgaW4gdGhlIGNvbnRleHQgb2YgdGhlIHNlbGVjdGVkIGVsZW1lbnQsIHNvIGB0aGlzYFxuICogcmVmZXJzIHRvIHRoZSBjdXJyZW50IGVsZW1lbnQuXG4gKlxuICogQGNhdGVnb3J5IFRyYXZlcnNpbmdcbiAqIEBwYXJhbSBzZWxlY3RvciAtIFNlbGVjdG9yIGZvciB0aGUgc2VsZWN0aW9uLlxuICogQHJldHVybnMgV2hldGhlciBvciBub3QgdGhlIHNlbGVjdG9yIG1hdGNoZXMgYW4gZWxlbWVudCBvZiB0aGUgaW5zdGFuY2UuXG4gKiBAc2VlIHtAbGluayBodHRwczovL2FwaS5qcXVlcnkuY29tL2lzL31cbiAqL1xuZnVuY3Rpb24gaXMoc2VsZWN0b3IpIHtcbiAgICBjb25zdCBub2RlcyA9IHRoaXMudG9BcnJheSgpO1xuICAgIHJldHVybiB0eXBlb2Ygc2VsZWN0b3IgPT09ICdzdHJpbmcnXG4gICAgICAgID8gc2VsZWN0LnNvbWUobm9kZXMuZmlsdGVyKGRvbWhhbmRsZXJfMS5pc1RhZyksIHNlbGVjdG9yLCB0aGlzLm9wdGlvbnMpXG4gICAgICAgIDogc2VsZWN0b3JcbiAgICAgICAgICAgID8gbm9kZXMuc29tZShnZXRGaWx0ZXJGbihzZWxlY3RvcikpXG4gICAgICAgICAgICA6IGZhbHNlO1xufVxuLyoqXG4gKiBSZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgc2V0IG9mIG1hdGNoZWQgZWxlbWVudHMuIEdpdmVuIGEgQ2hlZXJpbyBvYmplY3QgdGhhdFxuICogcmVwcmVzZW50cyBhIHNldCBvZiBET00gZWxlbWVudHMsIHRoZSBgLm5vdCgpYCBtZXRob2QgY29uc3RydWN0cyBhIG5ld1xuICogQ2hlZXJpbyBvYmplY3QgZnJvbSBhIHN1YnNldCBvZiB0aGUgbWF0Y2hpbmcgZWxlbWVudHMuIFRoZSBzdXBwbGllZCBzZWxlY3RvclxuICogaXMgdGVzdGVkIGFnYWluc3QgZWFjaCBlbGVtZW50OyB0aGUgZWxlbWVudHMgdGhhdCBkb24ndCBtYXRjaCB0aGUgc2VsZWN0b3JcbiAqIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdC5cbiAqXG4gKiBUaGUgYC5ub3QoKWAgbWV0aG9kIGNhbiB0YWtlIGEgZnVuY3Rpb24gYXMgaXRzIGFyZ3VtZW50IGluIHRoZSBzYW1lIHdheSB0aGF0XG4gKiBgLmZpbHRlcigpYCBkb2VzLiBFbGVtZW50cyBmb3Igd2hpY2ggdGhlIGZ1bmN0aW9uIHJldHVybnMgYHRydWVgIGFyZSBleGNsdWRlZFxuICogZnJvbSB0aGUgZmlsdGVyZWQgc2V0OyBhbGwgb3RoZXIgZWxlbWVudHMgYXJlIGluY2x1ZGVkLlxuICpcbiAqIEBjYXRlZ29yeSBUcmF2ZXJzaW5nXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5TZWxlY3RvcjwvY2FwdGlvbj5cbiAqXG4gKiBgYGBqc1xuICogJCgnbGknKS5ub3QoJy5hcHBsZScpLmxlbmd0aDtcbiAqIC8vPT4gMlxuICogYGBgXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RnVuY3Rpb248L2NhcHRpb24+XG4gKlxuICogYGBganNcbiAqICQoJ2xpJykubm90KGZ1bmN0aW9uIChpLCBlbCkge1xuICogICAvLyB0aGlzID09PSBlbFxuICogICByZXR1cm4gJCh0aGlzKS5hdHRyKCdjbGFzcycpID09PSAnb3JhbmdlJztcbiAqIH0pLmxlbmd0aDsgLy89PiAyXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gbWF0Y2ggLSBWYWx1ZSB0byBsb29rIGZvciwgZm9sbG93aW5nIHRoZSBydWxlcyBhYm92ZS5cbiAqIEByZXR1cm5zIFRoZSBmaWx0ZXJlZCBjb2xsZWN0aW9uLlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9hcGkuanF1ZXJ5LmNvbS9ub3QvfVxuICovXG5mdW5jdGlvbiBub3QobWF0Y2gpIHtcbiAgICBsZXQgbm9kZXMgPSB0aGlzLnRvQXJyYXkoKTtcbiAgICBpZiAodHlwZW9mIG1hdGNoID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gbmV3IFNldChzZWxlY3QuZmlsdGVyKG1hdGNoLCBub2RlcywgdGhpcy5vcHRpb25zKSk7XG4gICAgICAgIG5vZGVzID0gbm9kZXMuZmlsdGVyKChlbCkgPT4gIW1hdGNoZXMuaGFzKGVsKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBmaWx0ZXJGbiA9IGdldEZpbHRlckZuKG1hdGNoKTtcbiAgICAgICAgbm9kZXMgPSBub2Rlcy5maWx0ZXIoKGVsLCBpKSA9PiAhZmlsdGVyRm4oZWwsIGkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX21ha2Uobm9kZXMpO1xufVxuLyoqXG4gKiBGaWx0ZXJzIHRoZSBzZXQgb2YgbWF0Y2hlZCBlbGVtZW50cyB0byBvbmx5IHRob3NlIHdoaWNoIGhhdmUgdGhlIGdpdmVuIERPTVxuICogZWxlbWVudCBhcyBhIGRlc2NlbmRhbnQgb3Igd2hpY2ggaGF2ZSBhIGRlc2NlbmRhbnQgdGhhdCBtYXRjaGVzIHRoZSBnaXZlblxuICogc2VsZWN0b3IuIEVxdWl2YWxlbnQgdG8gYC5maWx0ZXIoJzpoYXMoc2VsZWN0b3IpJylgLlxuICpcbiAqIEBjYXRlZ29yeSBUcmF2ZXJzaW5nXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5TZWxlY3RvcjwvY2FwdGlvbj5cbiAqXG4gKiBgYGBqc1xuICogJCgndWwnKS5oYXMoJy5wZWFyJykuYXR0cignaWQnKTtcbiAqIC8vPT4gZnJ1aXRzXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbGVtZW50PC9jYXB0aW9uPlxuICpcbiAqIGBgYGpzXG4gKiAkKCd1bCcpLmhhcygkKCcucGVhcicpWzBdKS5hdHRyKCdpZCcpO1xuICogLy89PiBmcnVpdHNcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzZWxlY3Rvck9ySGF5c3RhY2sgLSBFbGVtZW50IHRvIGxvb2sgZm9yLlxuICogQHJldHVybnMgVGhlIGZpbHRlcmVkIGNvbGxlY3Rpb24uXG4gKiBAc2VlIHtAbGluayBodHRwczovL2FwaS5qcXVlcnkuY29tL2hhcy99XG4gKi9cbmZ1bmN0aW9uIGhhcyhzZWxlY3Rvck9ySGF5c3RhY2spIHtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXIodHlwZW9mIHNlbGVjdG9yT3JIYXlzdGFjayA9PT0gJ3N0cmluZydcbiAgICAgICAgPyAvLyBVc2luZyB0aGUgYDpoYXNgIHNlbGVjdG9yIGhlcmUgc2hvcnQtY2lyY3VpdHMgc2VhcmNoZXMuXG4gICAgICAgICAgICBgOmhhcygke3NlbGVjdG9yT3JIYXlzdGFja30pYFxuICAgICAgICA6IChfLCBlbCkgPT4gdGhpcy5fbWFrZShlbCkuZmluZChzZWxlY3Rvck9ySGF5c3RhY2spLmxlbmd0aCA+IDApO1xufVxuLyoqXG4gKiBXaWxsIHNlbGVjdCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhIGNoZWVyaW8gb2JqZWN0LlxuICpcbiAqIEBjYXRlZ29yeSBUcmF2ZXJzaW5nXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAkKCcjZnJ1aXRzJykuY2hpbGRyZW4oKS5maXJzdCgpLnRleHQoKTtcbiAqIC8vPT4gQXBwbGVcbiAqIGBgYFxuICpcbiAqIEByZXR1cm5zIFRoZSBmaXJzdCBlbGVtZW50LlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9hcGkuanF1ZXJ5LmNvbS9maXJzdC99XG4gKi9cbmZ1bmN0aW9uIGZpcnN0KCkge1xuICAgIHJldHVybiB0aGlzLmxlbmd0aCA+IDEgPyB0aGlzLl9tYWtlKHRoaXNbMF0pIDogdGhpcztcbn1cbi8qKlxuICogV2lsbCBzZWxlY3QgdGhlIGxhc3QgZWxlbWVudCBvZiBhIGNoZWVyaW8gb2JqZWN0LlxuICpcbiAqIEBjYXRlZ29yeSBUcmF2ZXJzaW5nXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAkKCcjZnJ1aXRzJykuY2hpbGRyZW4oKS5sYXN0KCkudGV4dCgpO1xuICogLy89PiBQZWFyXG4gKiBgYGBcbiAqXG4gKiBAcmV0dXJucyBUaGUgbGFzdCBlbGVtZW50LlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9hcGkuanF1ZXJ5LmNvbS9sYXN0L31cbiAqL1xuZnVuY3Rpb24gbGFzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGggPiAwID8gdGhpcy5fbWFrZSh0aGlzW3RoaXMubGVuZ3RoIC0gMV0pIDogdGhpcztcbn1cbi8qKlxuICogUmVkdWNlIHRoZSBzZXQgb2YgbWF0Y2hlZCBlbGVtZW50cyB0byB0aGUgb25lIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguIFVzZVxuICogYC5lcSgtaSlgIHRvIGNvdW50IGJhY2t3YXJkcyBmcm9tIHRoZSBsYXN0IHNlbGVjdGVkIGVsZW1lbnQuXG4gKlxuICogQGNhdGVnb3J5IFRyYXZlcnNpbmdcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqICQoJ2xpJykuZXEoMCkudGV4dCgpO1xuICogLy89PiBBcHBsZVxuICpcbiAqICQoJ2xpJykuZXEoLTEpLnRleHQoKTtcbiAqIC8vPT4gUGVhclxuICogYGBgXG4gKlxuICogQHBhcmFtIGkgLSBJbmRleCBvZiB0aGUgZWxlbWVudCB0byBzZWxlY3QuXG4gKiBAcmV0dXJucyBUaGUgZWxlbWVudCBhdCB0aGUgYGlgdGggcG9zaXRpb24uXG4gKiBAc2VlIHtAbGluayBodHRwczovL2FwaS5qcXVlcnkuY29tL2VxL31cbiAqL1xuZnVuY3Rpb24gZXEoaSkge1xuICAgIHZhciBfYTtcbiAgICBpID0gK2k7XG4gICAgLy8gVXNlIHRoZSBmaXJzdCBpZGVudGl0eSBvcHRpbWl6YXRpb24gaWYgcG9zc2libGVcbiAgICBpZiAoaSA9PT0gMCAmJiB0aGlzLmxlbmd0aCA8PSAxKVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICBpZiAoaSA8IDApXG4gICAgICAgIGkgPSB0aGlzLmxlbmd0aCArIGk7XG4gICAgcmV0dXJuIHRoaXMuX21ha2UoKF9hID0gdGhpc1tpXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pO1xufVxuZnVuY3Rpb24gZ2V0KGkpIHtcbiAgICBpZiAoaSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNbaSA8IDAgPyB0aGlzLmxlbmd0aCArIGkgOiBpXTtcbn1cbi8qKlxuICogUmV0cmlldmUgYWxsIHRoZSBET00gZWxlbWVudHMgY29udGFpbmVkIGluIHRoZSBqUXVlcnkgc2V0IGFzIGFuIGFycmF5LlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqICQoJ2xpJykudG9BcnJheSgpO1xuICogLy89PiBbIHsuLi59LCB7Li4ufSwgey4uLn0gXVxuICogYGBgXG4gKlxuICogQHJldHVybnMgVGhlIGNvbnRhaW5lZCBpdGVtcy5cbiAqL1xuZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcyk7XG59XG4vKipcbiAqIFNlYXJjaCBmb3IgYSBnaXZlbiBlbGVtZW50IGZyb20gYW1vbmcgdGhlIG1hdGNoZWQgZWxlbWVudHMuXG4gKlxuICogQGNhdGVnb3J5IFRyYXZlcnNpbmdcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqICQoJy5wZWFyJykuaW5kZXgoKTtcbiAqIC8vPT4gMiAkKCcub3JhbmdlJykuaW5kZXgoJ2xpJyk7XG4gKiAvLz0+IDFcbiAqICQoJy5hcHBsZScpLmluZGV4KCQoJyNmcnVpdCwgbGknKSk7XG4gKiAvLz0+IDFcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzZWxlY3Rvck9yTmVlZGxlIC0gRWxlbWVudCB0byBsb29rIGZvci5cbiAqIEByZXR1cm5zIFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudC5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vYXBpLmpxdWVyeS5jb20vaW5kZXgvfVxuICovXG5mdW5jdGlvbiBpbmRleChzZWxlY3Rvck9yTmVlZGxlKSB7XG4gICAgbGV0ICRoYXlzdGFjaztcbiAgICBsZXQgbmVlZGxlO1xuICAgIGlmIChzZWxlY3Rvck9yTmVlZGxlID09IG51bGwpIHtcbiAgICAgICAgJGhheXN0YWNrID0gdGhpcy5wYXJlbnQoKS5jaGlsZHJlbigpO1xuICAgICAgICBuZWVkbGUgPSB0aGlzWzBdO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygc2VsZWN0b3JPck5lZWRsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgJGhheXN0YWNrID0gdGhpcy5fbWFrZShzZWxlY3Rvck9yTmVlZGxlKTtcbiAgICAgICAgbmVlZGxlID0gdGhpc1swXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhcywgdW5pY29ybi9uby10aGlzLWFzc2lnbm1lbnRcbiAgICAgICAgJGhheXN0YWNrID0gdGhpcztcbiAgICAgICAgbmVlZGxlID0gKDAsIHV0aWxzX2pzXzEuaXNDaGVlcmlvKShzZWxlY3Rvck9yTmVlZGxlKVxuICAgICAgICAgICAgPyBzZWxlY3Rvck9yTmVlZGxlWzBdXG4gICAgICAgICAgICA6IHNlbGVjdG9yT3JOZWVkbGU7XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKCRoYXlzdGFjaywgbmVlZGxlKTtcbn1cbi8qKlxuICogR2V0cyB0aGUgZWxlbWVudHMgbWF0Y2hpbmcgdGhlIHNwZWNpZmllZCByYW5nZSAoMC1iYXNlZCBwb3NpdGlvbikuXG4gKlxuICogQGNhdGVnb3J5IFRyYXZlcnNpbmdcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqICQoJ2xpJykuc2xpY2UoMSkuZXEoMCkudGV4dCgpO1xuICogLy89PiAnT3JhbmdlJ1xuICpcbiAqICQoJ2xpJykuc2xpY2UoMSwgMikubGVuZ3RoO1xuICogLy89PiAxXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc3RhcnQgLSBBIHBvc2l0aW9uIGF0IHdoaWNoIHRoZSBlbGVtZW50cyBiZWdpbiB0byBiZSBzZWxlY3RlZC4gSWZcbiAqICAgbmVnYXRpdmUsIGl0IGluZGljYXRlcyBhbiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBzZXQuXG4gKiBAcGFyYW0gZW5kIC0gQSBwb3NpdGlvbiBhdCB3aGljaCB0aGUgZWxlbWVudHMgc3RvcCBiZWluZyBzZWxlY3RlZC4gSWZcbiAqICAgbmVnYXRpdmUsIGl0IGluZGljYXRlcyBhbiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBzZXQuIElmIG9taXR0ZWQsIHRoZVxuICogICByYW5nZSBjb250aW51ZXMgdW50aWwgdGhlIGVuZCBvZiB0aGUgc2V0LlxuICogQHJldHVybnMgVGhlIGVsZW1lbnRzIG1hdGNoaW5nIHRoZSBzcGVjaWZpZWQgcmFuZ2UuXG4gKiBAc2VlIHtAbGluayBodHRwczovL2FwaS5qcXVlcnkuY29tL3NsaWNlL31cbiAqL1xuZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiB0aGlzLl9tYWtlKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMsIHN0YXJ0LCBlbmQpKTtcbn1cbi8qKlxuICogRW5kIHRoZSBtb3N0IHJlY2VudCBmaWx0ZXJpbmcgb3BlcmF0aW9uIGluIHRoZSBjdXJyZW50IGNoYWluIGFuZCByZXR1cm4gdGhlXG4gKiBzZXQgb2YgbWF0Y2hlZCBlbGVtZW50cyB0byBpdHMgcHJldmlvdXMgc3RhdGUuXG4gKlxuICogQGNhdGVnb3J5IFRyYXZlcnNpbmdcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqICQoJ2xpJykuZXEoMCkuZW5kKCkubGVuZ3RoO1xuICogLy89PiAzXG4gKiBgYGBcbiAqXG4gKiBAcmV0dXJucyBUaGUgcHJldmlvdXMgc3RhdGUgb2YgdGhlIHNldCBvZiBtYXRjaGVkIGVsZW1lbnRzLlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9hcGkuanF1ZXJ5LmNvbS9lbmQvfVxuICovXG5mdW5jdGlvbiBlbmQoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLnByZXZPYmplY3QpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuX21ha2UoW10pO1xufVxuLyoqXG4gKiBBZGQgZWxlbWVudHMgdG8gdGhlIHNldCBvZiBtYXRjaGVkIGVsZW1lbnRzLlxuICpcbiAqIEBjYXRlZ29yeSBUcmF2ZXJzaW5nXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAkKCcuYXBwbGUnKS5hZGQoJy5vcmFuZ2UnKS5sZW5ndGg7XG4gKiAvLz0+IDJcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvdGhlciAtIEVsZW1lbnRzIHRvIGFkZC5cbiAqIEBwYXJhbSBjb250ZXh0IC0gT3B0aW9uYWxseSB0aGUgY29udGV4dCBvZiB0aGUgbmV3IHNlbGVjdGlvbi5cbiAqIEByZXR1cm5zIFRoZSBjb21iaW5lZCBzZXQuXG4gKiBAc2VlIHtAbGluayBodHRwczovL2FwaS5qcXVlcnkuY29tL2FkZC99XG4gKi9cbmZ1bmN0aW9uIGFkZChvdGhlciwgY29udGV4dCkge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuX21ha2Uob3RoZXIsIGNvbnRleHQpO1xuICAgIGNvbnN0IGNvbnRlbnRzID0gKDAsIGRvbXV0aWxzXzEudW5pcXVlU29ydCkoWy4uLnRoaXMuZ2V0KCksIC4uLnNlbGVjdGlvbi5nZXQoKV0pO1xuICAgIHJldHVybiB0aGlzLl9tYWtlKGNvbnRlbnRzKTtcbn1cbi8qKlxuICogQWRkIHRoZSBwcmV2aW91cyBzZXQgb2YgZWxlbWVudHMgb24gdGhlIHN0YWNrIHRvIHRoZSBjdXJyZW50IHNldCwgb3B0aW9uYWxseVxuICogZmlsdGVyZWQgYnkgYSBzZWxlY3Rvci5cbiAqXG4gKiBAY2F0ZWdvcnkgVHJhdmVyc2luZ1xuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogJCgnbGknKS5lcSgwKS5hZGRCYWNrKCcub3JhbmdlJykubGVuZ3RoO1xuICogLy89PiAyXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2VsZWN0b3IgLSBTZWxlY3RvciBmb3IgdGhlIGVsZW1lbnRzIHRvIGFkZC5cbiAqIEByZXR1cm5zIFRoZSBjb21iaW5lZCBzZXQuXG4gKiBAc2VlIHtAbGluayBodHRwczovL2FwaS5qcXVlcnkuY29tL2FkZEJhY2svfVxuICovXG5mdW5jdGlvbiBhZGRCYWNrKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMucHJldk9iamVjdFxuICAgICAgICA/IHRoaXMuYWRkKHNlbGVjdG9yID8gdGhpcy5wcmV2T2JqZWN0LmZpbHRlcihzZWxlY3RvcikgOiB0aGlzLnByZXZPYmplY3QpXG4gICAgICAgIDogdGhpcztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYXZlcnNpbmcuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/cheerio/dist/commonjs/api/traversing.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/cheerio/dist/commonjs/cheerio.js":
/*!*******************************************************!*\
  !*** ./node_modules/cheerio/dist/commonjs/cheerio.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Cheerio = void 0;\nconst Attributes = __importStar(__webpack_require__(/*! ./api/attributes.js */ \"(rsc)/./node_modules/cheerio/dist/commonjs/api/attributes.js\"));\nconst Traversing = __importStar(__webpack_require__(/*! ./api/traversing.js */ \"(rsc)/./node_modules/cheerio/dist/commonjs/api/traversing.js\"));\nconst Manipulation = __importStar(__webpack_require__(/*! ./api/manipulation.js */ \"(rsc)/./node_modules/cheerio/dist/commonjs/api/manipulation.js\"));\nconst Css = __importStar(__webpack_require__(/*! ./api/css.js */ \"(rsc)/./node_modules/cheerio/dist/commonjs/api/css.js\"));\nconst Forms = __importStar(__webpack_require__(/*! ./api/forms.js */ \"(rsc)/./node_modules/cheerio/dist/commonjs/api/forms.js\"));\nconst Extract = __importStar(__webpack_require__(/*! ./api/extract.js */ \"(rsc)/./node_modules/cheerio/dist/commonjs/api/extract.js\"));\n/**\n * The cheerio class is the central class of the library. It wraps a set of\n * elements and provides an API for traversing, modifying, and interacting with\n * the set.\n *\n * Loading a document will return the Cheerio class bound to the root element of\n * the document. The class will be instantiated when querying the document (when\n * calling `$('selector')`).\n *\n * @example This is the HTML markup we will be using in all of the API examples:\n *\n * ```html\n * <ul id=\"fruits\">\n *   <li class=\"apple\">Apple</li>\n *   <li class=\"orange\">Orange</li>\n *   <li class=\"pear\">Pear</li>\n * </ul>\n * ```\n */\nclass Cheerio {\n    /**\n     * Instance of cheerio. Methods are specified in the modules. Usage of this\n     * constructor is not recommended. Please use `$.load` instead.\n     *\n     * @private\n     * @param elements - The new selection.\n     * @param root - Sets the root node.\n     * @param options - Options for the instance.\n     */\n    constructor(elements, root, options) {\n        this.length = 0;\n        this.options = options;\n        this._root = root;\n        if (elements) {\n            for (let idx = 0; idx < elements.length; idx++) {\n                this[idx] = elements[idx];\n            }\n            this.length = elements.length;\n        }\n    }\n}\nexports.Cheerio = Cheerio;\n/** Set a signature of the object. */\nCheerio.prototype.cheerio = '[cheerio object]';\n/*\n * Make cheerio an array-like object\n */\nCheerio.prototype.splice = Array.prototype.splice;\n// Support for (const element of $(...)) iteration:\nCheerio.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];\n// Plug in the API\nObject.assign(Cheerio.prototype, Attributes, Traversing, Manipulation, Css, Forms, Extract);\n//# sourceMappingURL=cheerio.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2hlZXJpby9kaXN0L2NvbW1vbmpzL2NoZWVyaW8uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZixnQ0FBZ0MsbUJBQU8sQ0FBQyx5RkFBcUI7QUFDN0QsZ0NBQWdDLG1CQUFPLENBQUMseUZBQXFCO0FBQzdELGtDQUFrQyxtQkFBTyxDQUFDLDZGQUF1QjtBQUNqRSx5QkFBeUIsbUJBQU8sQ0FBQywyRUFBYztBQUMvQywyQkFBMkIsbUJBQU8sQ0FBQywrRUFBZ0I7QUFDbkQsNkJBQTZCLG1CQUFPLENBQUMsbUZBQWtCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHVCQUF1QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvaW10aXlhei9EZXNrdG9wL1N1cGVyTGVhcm4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2NoZWVyaW8vZGlzdC9jb21tb25qcy9jaGVlcmlvLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNoZWVyaW8gPSB2b2lkIDA7XG5jb25zdCBBdHRyaWJ1dGVzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2FwaS9hdHRyaWJ1dGVzLmpzXCIpKTtcbmNvbnN0IFRyYXZlcnNpbmcgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYXBpL3RyYXZlcnNpbmcuanNcIikpO1xuY29uc3QgTWFuaXB1bGF0aW9uID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2FwaS9tYW5pcHVsYXRpb24uanNcIikpO1xuY29uc3QgQ3NzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2FwaS9jc3MuanNcIikpO1xuY29uc3QgRm9ybXMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYXBpL2Zvcm1zLmpzXCIpKTtcbmNvbnN0IEV4dHJhY3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYXBpL2V4dHJhY3QuanNcIikpO1xuLyoqXG4gKiBUaGUgY2hlZXJpbyBjbGFzcyBpcyB0aGUgY2VudHJhbCBjbGFzcyBvZiB0aGUgbGlicmFyeS4gSXQgd3JhcHMgYSBzZXQgb2ZcbiAqIGVsZW1lbnRzIGFuZCBwcm92aWRlcyBhbiBBUEkgZm9yIHRyYXZlcnNpbmcsIG1vZGlmeWluZywgYW5kIGludGVyYWN0aW5nIHdpdGhcbiAqIHRoZSBzZXQuXG4gKlxuICogTG9hZGluZyBhIGRvY3VtZW50IHdpbGwgcmV0dXJuIHRoZSBDaGVlcmlvIGNsYXNzIGJvdW5kIHRvIHRoZSByb290IGVsZW1lbnQgb2ZcbiAqIHRoZSBkb2N1bWVudC4gVGhlIGNsYXNzIHdpbGwgYmUgaW5zdGFudGlhdGVkIHdoZW4gcXVlcnlpbmcgdGhlIGRvY3VtZW50ICh3aGVuXG4gKiBjYWxsaW5nIGAkKCdzZWxlY3RvcicpYCkuXG4gKlxuICogQGV4YW1wbGUgVGhpcyBpcyB0aGUgSFRNTCBtYXJrdXAgd2Ugd2lsbCBiZSB1c2luZyBpbiBhbGwgb2YgdGhlIEFQSSBleGFtcGxlczpcbiAqXG4gKiBgYGBodG1sXG4gKiA8dWwgaWQ9XCJmcnVpdHNcIj5cbiAqICAgPGxpIGNsYXNzPVwiYXBwbGVcIj5BcHBsZTwvbGk+XG4gKiAgIDxsaSBjbGFzcz1cIm9yYW5nZVwiPk9yYW5nZTwvbGk+XG4gKiAgIDxsaSBjbGFzcz1cInBlYXJcIj5QZWFyPC9saT5cbiAqIDwvdWw+XG4gKiBgYGBcbiAqL1xuY2xhc3MgQ2hlZXJpbyB7XG4gICAgLyoqXG4gICAgICogSW5zdGFuY2Ugb2YgY2hlZXJpby4gTWV0aG9kcyBhcmUgc3BlY2lmaWVkIGluIHRoZSBtb2R1bGVzLiBVc2FnZSBvZiB0aGlzXG4gICAgICogY29uc3RydWN0b3IgaXMgbm90IHJlY29tbWVuZGVkLiBQbGVhc2UgdXNlIGAkLmxvYWRgIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSBlbGVtZW50cyAtIFRoZSBuZXcgc2VsZWN0aW9uLlxuICAgICAqIEBwYXJhbSByb290IC0gU2V0cyB0aGUgcm9vdCBub2RlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRzLCByb290LCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5fcm9vdCA9IHJvb3Q7XG4gICAgICAgIGlmIChlbGVtZW50cykge1xuICAgICAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgZWxlbWVudHMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgICAgIHRoaXNbaWR4XSA9IGVsZW1lbnRzW2lkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ2hlZXJpbyA9IENoZWVyaW87XG4vKiogU2V0IGEgc2lnbmF0dXJlIG9mIHRoZSBvYmplY3QuICovXG5DaGVlcmlvLnByb3RvdHlwZS5jaGVlcmlvID0gJ1tjaGVlcmlvIG9iamVjdF0nO1xuLypcbiAqIE1ha2UgY2hlZXJpbyBhbiBhcnJheS1saWtlIG9iamVjdFxuICovXG5DaGVlcmlvLnByb3RvdHlwZS5zcGxpY2UgPSBBcnJheS5wcm90b3R5cGUuc3BsaWNlO1xuLy8gU3VwcG9ydCBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgJCguLi4pKSBpdGVyYXRpb246XG5DaGVlcmlvLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gQXJyYXkucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl07XG4vLyBQbHVnIGluIHRoZSBBUElcbk9iamVjdC5hc3NpZ24oQ2hlZXJpby5wcm90b3R5cGUsIEF0dHJpYnV0ZXMsIFRyYXZlcnNpbmcsIE1hbmlwdWxhdGlvbiwgQ3NzLCBGb3JtcywgRXh0cmFjdCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVlcmlvLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/cheerio/dist/commonjs/cheerio.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/cheerio/dist/commonjs/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/cheerio/dist/commonjs/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * @file Batteries-included version of Cheerio. This module includes several\n *   convenience methods for loading documents from various sources.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.merge = exports.contains = void 0;\nexports.loadBuffer = loadBuffer;\nexports.stringStream = stringStream;\nexports.decodeStream = decodeStream;\nexports.fromURL = fromURL;\n__exportStar(__webpack_require__(/*! ./load-parse.js */ \"(rsc)/./node_modules/cheerio/dist/commonjs/load-parse.js\"), exports);\nvar static_js_1 = __webpack_require__(/*! ./static.js */ \"(rsc)/./node_modules/cheerio/dist/commonjs/static.js\");\nObject.defineProperty(exports, \"contains\", ({ enumerable: true, get: function () { return static_js_1.contains; } }));\nObject.defineProperty(exports, \"merge\", ({ enumerable: true, get: function () { return static_js_1.merge; } }));\nconst parse5_htmlparser2_tree_adapter_1 = __webpack_require__(/*! parse5-htmlparser2-tree-adapter */ \"(rsc)/./node_modules/parse5-htmlparser2-tree-adapter/dist/cjs/index.js\");\nconst htmlparser2 = __importStar(__webpack_require__(/*! htmlparser2 */ \"(rsc)/./node_modules/htmlparser2/lib/index.js\"));\nconst parse5_parser_stream_1 = __webpack_require__(/*! parse5-parser-stream */ \"(rsc)/./node_modules/parse5-parser-stream/dist/cjs/index.js\");\nconst encoding_sniffer_1 = __webpack_require__(/*! encoding-sniffer */ \"(rsc)/./node_modules/encoding-sniffer/dist/commonjs/index.js\");\nconst undici = __importStar(__webpack_require__(/*! undici */ \"(rsc)/./node_modules/undici/index.js\"));\nconst whatwg_mimetype_1 = __importDefault(__webpack_require__(/*! whatwg-mimetype */ \"(rsc)/./node_modules/whatwg-mimetype/lib/mime-type.js\"));\nconst node_stream_1 = __webpack_require__(/*! node:stream */ \"node:stream\");\nconst options_js_1 = __webpack_require__(/*! ./options.js */ \"(rsc)/./node_modules/cheerio/dist/commonjs/options.js\");\nconst load_parse_js_1 = __webpack_require__(/*! ./load-parse.js */ \"(rsc)/./node_modules/cheerio/dist/commonjs/load-parse.js\");\n/**\n * Sniffs the encoding of a buffer, then creates a querying function bound to a\n * document created from the buffer.\n *\n * @category Loading\n * @example\n *\n * ```js\n * import * as cheerio from 'cheerio';\n *\n * const buffer = fs.readFileSync('index.html');\n * const $ = cheerio.fromBuffer(buffer);\n * ```\n *\n * @param buffer - The buffer to sniff the encoding of.\n * @param options - The options to pass to Cheerio.\n * @returns The loaded document.\n */\nfunction loadBuffer(buffer, options = {}) {\n    const opts = (0, options_js_1.flattenOptions)(options);\n    const str = (0, encoding_sniffer_1.decodeBuffer)(buffer, {\n        defaultEncoding: (opts === null || opts === void 0 ? void 0 : opts.xmlMode) ? 'utf8' : 'windows-1252',\n        ...options.encoding,\n    });\n    return (0, load_parse_js_1.load)(str, opts);\n}\nfunction _stringStream(options, cb) {\n    var _a;\n    if (options === null || options === void 0 ? void 0 : options._useHtmlParser2) {\n        const parser = htmlparser2.createDocumentStream((err, document) => cb(err, (0, load_parse_js_1.load)(document)), options);\n        return new node_stream_1.Writable({\n            decodeStrings: false,\n            write(chunk, _encoding, callback) {\n                if (typeof chunk !== 'string') {\n                    throw new TypeError('Expected a string');\n                }\n                parser.write(chunk);\n                callback();\n            },\n            final(callback) {\n                parser.end();\n                callback();\n            },\n        });\n    }\n    options !== null && options !== void 0 ? options : (options = {});\n    (_a = options.treeAdapter) !== null && _a !== void 0 ? _a : (options.treeAdapter = parse5_htmlparser2_tree_adapter_1.adapter);\n    if (options.scriptingEnabled !== false) {\n        options.scriptingEnabled = true;\n    }\n    const stream = new parse5_parser_stream_1.ParserStream(options);\n    (0, node_stream_1.finished)(stream, (err) => cb(err, (0, load_parse_js_1.load)(stream.document)));\n    return stream;\n}\n/**\n * Creates a stream that parses a sequence of strings into a document.\n *\n * The stream is a `Writable` stream that accepts strings. When the stream is\n * finished, the callback is called with the loaded document.\n *\n * @category Loading\n * @example\n *\n * ```js\n * import * as cheerio from 'cheerio';\n * import * as fs from 'fs';\n *\n * const writeStream = cheerio.stringStream({}, (err, $) => {\n *   if (err) {\n *     // Handle error\n *   }\n *\n *   console.log($('h1').text());\n *   // Output: Hello, world!\n * });\n *\n * fs.createReadStream('my-document.html', { encoding: 'utf8' }).pipe(\n *   writeStream,\n * );\n * ```\n *\n * @param options - The options to pass to Cheerio.\n * @param cb - The callback to call when the stream is finished.\n * @returns The writable stream.\n */\nfunction stringStream(options, cb) {\n    return _stringStream((0, options_js_1.flattenOptions)(options), cb);\n}\n/**\n * Parses a stream of buffers into a document.\n *\n * The stream is a `Writable` stream that accepts buffers. When the stream is\n * finished, the callback is called with the loaded document.\n *\n * @category Loading\n * @param options - The options to pass to Cheerio.\n * @param cb - The callback to call when the stream is finished.\n * @returns The writable stream.\n */\nfunction decodeStream(options, cb) {\n    var _a;\n    const { encoding = {}, ...cheerioOptions } = options;\n    const opts = (0, options_js_1.flattenOptions)(cheerioOptions);\n    // Set the default encoding to UTF-8 for XML mode\n    (_a = encoding.defaultEncoding) !== null && _a !== void 0 ? _a : (encoding.defaultEncoding = (opts === null || opts === void 0 ? void 0 : opts.xmlMode) ? 'utf8' : 'windows-1252');\n    const decodeStream = new encoding_sniffer_1.DecodeStream(encoding);\n    const loadStream = _stringStream(opts, cb);\n    decodeStream.pipe(loadStream);\n    return decodeStream;\n}\nconst defaultRequestOptions = {\n    method: 'GET',\n    // Allow redirects by default\n    maxRedirections: 5,\n    // NOTE: `throwOnError` currently doesn't work https://github.com/nodejs/undici/issues/1753\n    throwOnError: true,\n    // Set an Accept header\n    headers: {\n        accept: 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n    },\n};\n/**\n * `fromURL` loads a document from a URL.\n *\n * By default, redirects are allowed and non-2xx responses are rejected.\n *\n * @category Loading\n * @example\n *\n * ```js\n * import * as cheerio from 'cheerio';\n *\n * const $ = await cheerio.fromURL('https://example.com');\n * ```\n *\n * @param url - The URL to load the document from.\n * @param options - The options to pass to Cheerio.\n * @returns The loaded document.\n */\nasync function fromURL(url, options = {}) {\n    var _a;\n    const { requestOptions = defaultRequestOptions, encoding = {}, ...cheerioOptions } = options;\n    let undiciStream;\n    // Add headers if none were supplied.\n    (_a = requestOptions.headers) !== null && _a !== void 0 ? _a : (requestOptions.headers = defaultRequestOptions.headers);\n    const promise = new Promise((resolve, reject) => {\n        undiciStream = undici.stream(url, requestOptions, (res) => {\n            var _a, _b;\n            const contentType = (_a = res.headers['content-type']) !== null && _a !== void 0 ? _a : 'text/html';\n            const mimeType = new whatwg_mimetype_1.default(Array.isArray(contentType) ? contentType[0] : contentType);\n            if (!mimeType.isHTML() && !mimeType.isXML()) {\n                throw new RangeError(`The content-type \"${contentType}\" is neither HTML nor XML.`);\n            }\n            // Forward the charset from the header to the decodeStream.\n            encoding.transportLayerEncodingLabel = mimeType.parameters.get('charset');\n            /*\n             * If we allow redirects, we will have entries in the history.\n             * The last entry will be the final URL.\n             */\n            const history = (_b = res.context) === null || _b === void 0 ? void 0 : _b.history;\n            const opts = {\n                encoding,\n                // Set XML mode based on the MIME type.\n                xmlMode: mimeType.isXML(),\n                // Set the `baseURL` to the final URL.\n                baseURL: history ? history[history.length - 1] : url,\n                ...cheerioOptions,\n            };\n            return decodeStream(opts, (err, $) => (err ? reject(err) : resolve($)));\n        });\n    });\n    // Let's make sure the request is completed before returning the promise.\n    await undiciStream;\n    return promise;\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2hlZXJpby9kaXN0L2NvbW1vbmpzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxHQUFHLGdCQUFnQjtBQUNoQyxrQkFBa0I7QUFDbEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixlQUFlO0FBQ2YsYUFBYSxtQkFBTyxDQUFDLGlGQUFpQjtBQUN0QyxrQkFBa0IsbUJBQU8sQ0FBQyx5RUFBYTtBQUN2Qyw0Q0FBMkMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDbkgseUNBQXdDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQzdHLDBDQUEwQyxtQkFBTyxDQUFDLCtHQUFpQztBQUNuRixpQ0FBaUMsbUJBQU8sQ0FBQyxrRUFBYTtBQUN0RCwrQkFBK0IsbUJBQU8sQ0FBQyx5RkFBc0I7QUFDN0QsMkJBQTJCLG1CQUFPLENBQUMsc0ZBQWtCO0FBQ3JELDRCQUE0QixtQkFBTyxDQUFDLG9EQUFRO0FBQzVDLDBDQUEwQyxtQkFBTyxDQUFDLDhFQUFpQjtBQUNuRSxzQkFBc0IsbUJBQU8sQ0FBQyxnQ0FBYTtBQUMzQyxxQkFBcUIsbUJBQU8sQ0FBQywyRUFBYztBQUMzQyx3QkFBd0IsbUJBQU8sQ0FBQyxpRkFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsNkNBQTZDLGtCQUFrQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWEsc0JBQXNCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLFVBQVU7QUFDM0UsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0EsWUFBWSxxREFBcUQsc0JBQXNCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxZQUFZO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2ltdGl5YXovRGVza3RvcC9TdXBlckxlYXJuL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9jaGVlcmlvL2Rpc3QvY29tbW9uanMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlIEJhdHRlcmllcy1pbmNsdWRlZCB2ZXJzaW9uIG9mIENoZWVyaW8uIFRoaXMgbW9kdWxlIGluY2x1ZGVzIHNldmVyYWxcbiAqICAgY29udmVuaWVuY2UgbWV0aG9kcyBmb3IgbG9hZGluZyBkb2N1bWVudHMgZnJvbSB2YXJpb3VzIHNvdXJjZXMuXG4gKi9cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubWVyZ2UgPSBleHBvcnRzLmNvbnRhaW5zID0gdm9pZCAwO1xuZXhwb3J0cy5sb2FkQnVmZmVyID0gbG9hZEJ1ZmZlcjtcbmV4cG9ydHMuc3RyaW5nU3RyZWFtID0gc3RyaW5nU3RyZWFtO1xuZXhwb3J0cy5kZWNvZGVTdHJlYW0gPSBkZWNvZGVTdHJlYW07XG5leHBvcnRzLmZyb21VUkwgPSBmcm9tVVJMO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2xvYWQtcGFyc2UuanNcIiksIGV4cG9ydHMpO1xudmFyIHN0YXRpY19qc18xID0gcmVxdWlyZShcIi4vc3RhdGljLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29udGFpbnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0YXRpY19qc18xLmNvbnRhaW5zOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWVyZ2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0YXRpY19qc18xLm1lcmdlOyB9IH0pO1xuY29uc3QgcGFyc2U1X2h0bWxwYXJzZXIyX3RyZWVfYWRhcHRlcl8xID0gcmVxdWlyZShcInBhcnNlNS1odG1scGFyc2VyMi10cmVlLWFkYXB0ZXJcIik7XG5jb25zdCBodG1scGFyc2VyMiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiaHRtbHBhcnNlcjJcIikpO1xuY29uc3QgcGFyc2U1X3BhcnNlcl9zdHJlYW1fMSA9IHJlcXVpcmUoXCJwYXJzZTUtcGFyc2VyLXN0cmVhbVwiKTtcbmNvbnN0IGVuY29kaW5nX3NuaWZmZXJfMSA9IHJlcXVpcmUoXCJlbmNvZGluZy1zbmlmZmVyXCIpO1xuY29uc3QgdW5kaWNpID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJ1bmRpY2lcIikpO1xuY29uc3Qgd2hhdHdnX21pbWV0eXBlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIndoYXR3Zy1taW1ldHlwZVwiKSk7XG5jb25zdCBub2RlX3N0cmVhbV8xID0gcmVxdWlyZShcIm5vZGU6c3RyZWFtXCIpO1xuY29uc3Qgb3B0aW9uc19qc18xID0gcmVxdWlyZShcIi4vb3B0aW9ucy5qc1wiKTtcbmNvbnN0IGxvYWRfcGFyc2VfanNfMSA9IHJlcXVpcmUoXCIuL2xvYWQtcGFyc2UuanNcIik7XG4vKipcbiAqIFNuaWZmcyB0aGUgZW5jb2Rpbmcgb2YgYSBidWZmZXIsIHRoZW4gY3JlYXRlcyBhIHF1ZXJ5aW5nIGZ1bmN0aW9uIGJvdW5kIHRvIGFcbiAqIGRvY3VtZW50IGNyZWF0ZWQgZnJvbSB0aGUgYnVmZmVyLlxuICpcbiAqIEBjYXRlZ29yeSBMb2FkaW5nXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiBpbXBvcnQgKiBhcyBjaGVlcmlvIGZyb20gJ2NoZWVyaW8nO1xuICpcbiAqIGNvbnN0IGJ1ZmZlciA9IGZzLnJlYWRGaWxlU3luYygnaW5kZXguaHRtbCcpO1xuICogY29uc3QgJCA9IGNoZWVyaW8uZnJvbUJ1ZmZlcihidWZmZXIpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIGJ1ZmZlciAtIFRoZSBidWZmZXIgdG8gc25pZmYgdGhlIGVuY29kaW5nIG9mLlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byBwYXNzIHRvIENoZWVyaW8uXG4gKiBAcmV0dXJucyBUaGUgbG9hZGVkIGRvY3VtZW50LlxuICovXG5mdW5jdGlvbiBsb2FkQnVmZmVyKGJ1ZmZlciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgb3B0cyA9ICgwLCBvcHRpb25zX2pzXzEuZmxhdHRlbk9wdGlvbnMpKG9wdGlvbnMpO1xuICAgIGNvbnN0IHN0ciA9ICgwLCBlbmNvZGluZ19zbmlmZmVyXzEuZGVjb2RlQnVmZmVyKShidWZmZXIsIHtcbiAgICAgICAgZGVmYXVsdEVuY29kaW5nOiAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnhtbE1vZGUpID8gJ3V0ZjgnIDogJ3dpbmRvd3MtMTI1MicsXG4gICAgICAgIC4uLm9wdGlvbnMuZW5jb2RpbmcsXG4gICAgfSk7XG4gICAgcmV0dXJuICgwLCBsb2FkX3BhcnNlX2pzXzEubG9hZCkoc3RyLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIF9zdHJpbmdTdHJlYW0ob3B0aW9ucywgY2IpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5fdXNlSHRtbFBhcnNlcjIpIHtcbiAgICAgICAgY29uc3QgcGFyc2VyID0gaHRtbHBhcnNlcjIuY3JlYXRlRG9jdW1lbnRTdHJlYW0oKGVyciwgZG9jdW1lbnQpID0+IGNiKGVyciwgKDAsIGxvYWRfcGFyc2VfanNfMS5sb2FkKShkb2N1bWVudCkpLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIG5ldyBub2RlX3N0cmVhbV8xLldyaXRhYmxlKHtcbiAgICAgICAgICAgIGRlY29kZVN0cmluZ3M6IGZhbHNlLFxuICAgICAgICAgICAgd3JpdGUoY2h1bmssIF9lbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIHN0cmluZycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJzZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmluYWwoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuZW5kKCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiAob3B0aW9ucyA9IHt9KTtcbiAgICAoX2EgPSBvcHRpb25zLnRyZWVBZGFwdGVyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAob3B0aW9ucy50cmVlQWRhcHRlciA9IHBhcnNlNV9odG1scGFyc2VyMl90cmVlX2FkYXB0ZXJfMS5hZGFwdGVyKTtcbiAgICBpZiAob3B0aW9ucy5zY3JpcHRpbmdFbmFibGVkICE9PSBmYWxzZSkge1xuICAgICAgICBvcHRpb25zLnNjcmlwdGluZ0VuYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBzdHJlYW0gPSBuZXcgcGFyc2U1X3BhcnNlcl9zdHJlYW1fMS5QYXJzZXJTdHJlYW0ob3B0aW9ucyk7XG4gICAgKDAsIG5vZGVfc3RyZWFtXzEuZmluaXNoZWQpKHN0cmVhbSwgKGVycikgPT4gY2IoZXJyLCAoMCwgbG9hZF9wYXJzZV9qc18xLmxvYWQpKHN0cmVhbS5kb2N1bWVudCkpKTtcbiAgICByZXR1cm4gc3RyZWFtO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgc3RyZWFtIHRoYXQgcGFyc2VzIGEgc2VxdWVuY2Ugb2Ygc3RyaW5ncyBpbnRvIGEgZG9jdW1lbnQuXG4gKlxuICogVGhlIHN0cmVhbSBpcyBhIGBXcml0YWJsZWAgc3RyZWFtIHRoYXQgYWNjZXB0cyBzdHJpbmdzLiBXaGVuIHRoZSBzdHJlYW0gaXNcbiAqIGZpbmlzaGVkLCB0aGUgY2FsbGJhY2sgaXMgY2FsbGVkIHdpdGggdGhlIGxvYWRlZCBkb2N1bWVudC5cbiAqXG4gKiBAY2F0ZWdvcnkgTG9hZGluZ1xuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0ICogYXMgY2hlZXJpbyBmcm9tICdjaGVlcmlvJztcbiAqIGltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbiAqXG4gKiBjb25zdCB3cml0ZVN0cmVhbSA9IGNoZWVyaW8uc3RyaW5nU3RyZWFtKHt9LCAoZXJyLCAkKSA9PiB7XG4gKiAgIGlmIChlcnIpIHtcbiAqICAgICAvLyBIYW5kbGUgZXJyb3JcbiAqICAgfVxuICpcbiAqICAgY29uc29sZS5sb2coJCgnaDEnKS50ZXh0KCkpO1xuICogICAvLyBPdXRwdXQ6IEhlbGxvLCB3b3JsZCFcbiAqIH0pO1xuICpcbiAqIGZzLmNyZWF0ZVJlYWRTdHJlYW0oJ215LWRvY3VtZW50Lmh0bWwnLCB7IGVuY29kaW5nOiAndXRmOCcgfSkucGlwZShcbiAqICAgd3JpdGVTdHJlYW0sXG4gKiApO1xuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byBwYXNzIHRvIENoZWVyaW8uXG4gKiBAcGFyYW0gY2IgLSBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuIHRoZSBzdHJlYW0gaXMgZmluaXNoZWQuXG4gKiBAcmV0dXJucyBUaGUgd3JpdGFibGUgc3RyZWFtLlxuICovXG5mdW5jdGlvbiBzdHJpbmdTdHJlYW0ob3B0aW9ucywgY2IpIHtcbiAgICByZXR1cm4gX3N0cmluZ1N0cmVhbSgoMCwgb3B0aW9uc19qc18xLmZsYXR0ZW5PcHRpb25zKShvcHRpb25zKSwgY2IpO1xufVxuLyoqXG4gKiBQYXJzZXMgYSBzdHJlYW0gb2YgYnVmZmVycyBpbnRvIGEgZG9jdW1lbnQuXG4gKlxuICogVGhlIHN0cmVhbSBpcyBhIGBXcml0YWJsZWAgc3RyZWFtIHRoYXQgYWNjZXB0cyBidWZmZXJzLiBXaGVuIHRoZSBzdHJlYW0gaXNcbiAqIGZpbmlzaGVkLCB0aGUgY2FsbGJhY2sgaXMgY2FsbGVkIHdpdGggdGhlIGxvYWRlZCBkb2N1bWVudC5cbiAqXG4gKiBAY2F0ZWdvcnkgTG9hZGluZ1xuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byBwYXNzIHRvIENoZWVyaW8uXG4gKiBAcGFyYW0gY2IgLSBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuIHRoZSBzdHJlYW0gaXMgZmluaXNoZWQuXG4gKiBAcmV0dXJucyBUaGUgd3JpdGFibGUgc3RyZWFtLlxuICovXG5mdW5jdGlvbiBkZWNvZGVTdHJlYW0ob3B0aW9ucywgY2IpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBlbmNvZGluZyA9IHt9LCAuLi5jaGVlcmlvT3B0aW9ucyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBvcHRzID0gKDAsIG9wdGlvbnNfanNfMS5mbGF0dGVuT3B0aW9ucykoY2hlZXJpb09wdGlvbnMpO1xuICAgIC8vIFNldCB0aGUgZGVmYXVsdCBlbmNvZGluZyB0byBVVEYtOCBmb3IgWE1MIG1vZGVcbiAgICAoX2EgPSBlbmNvZGluZy5kZWZhdWx0RW5jb2RpbmcpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChlbmNvZGluZy5kZWZhdWx0RW5jb2RpbmcgPSAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnhtbE1vZGUpID8gJ3V0ZjgnIDogJ3dpbmRvd3MtMTI1MicpO1xuICAgIGNvbnN0IGRlY29kZVN0cmVhbSA9IG5ldyBlbmNvZGluZ19zbmlmZmVyXzEuRGVjb2RlU3RyZWFtKGVuY29kaW5nKTtcbiAgICBjb25zdCBsb2FkU3RyZWFtID0gX3N0cmluZ1N0cmVhbShvcHRzLCBjYik7XG4gICAgZGVjb2RlU3RyZWFtLnBpcGUobG9hZFN0cmVhbSk7XG4gICAgcmV0dXJuIGRlY29kZVN0cmVhbTtcbn1cbmNvbnN0IGRlZmF1bHRSZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIC8vIEFsbG93IHJlZGlyZWN0cyBieSBkZWZhdWx0XG4gICAgbWF4UmVkaXJlY3Rpb25zOiA1LFxuICAgIC8vIE5PVEU6IGB0aHJvd09uRXJyb3JgIGN1cnJlbnRseSBkb2Vzbid0IHdvcmsgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzE3NTNcbiAgICB0aHJvd09uRXJyb3I6IHRydWUsXG4gICAgLy8gU2V0IGFuIEFjY2VwdCBoZWFkZXJcbiAgICBoZWFkZXJzOiB7XG4gICAgICAgIGFjY2VwdDogJ3RleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LCovKjtxPTAuOCcsXG4gICAgfSxcbn07XG4vKipcbiAqIGBmcm9tVVJMYCBsb2FkcyBhIGRvY3VtZW50IGZyb20gYSBVUkwuXG4gKlxuICogQnkgZGVmYXVsdCwgcmVkaXJlY3RzIGFyZSBhbGxvd2VkIGFuZCBub24tMnh4IHJlc3BvbnNlcyBhcmUgcmVqZWN0ZWQuXG4gKlxuICogQGNhdGVnb3J5IExvYWRpbmdcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIGltcG9ydCAqIGFzIGNoZWVyaW8gZnJvbSAnY2hlZXJpbyc7XG4gKlxuICogY29uc3QgJCA9IGF3YWl0IGNoZWVyaW8uZnJvbVVSTCgnaHR0cHM6Ly9leGFtcGxlLmNvbScpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdG8gbG9hZCB0aGUgZG9jdW1lbnQgZnJvbS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gcGFzcyB0byBDaGVlcmlvLlxuICogQHJldHVybnMgVGhlIGxvYWRlZCBkb2N1bWVudC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZnJvbVVSTCh1cmwsIG9wdGlvbnMgPSB7fSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IHJlcXVlc3RPcHRpb25zID0gZGVmYXVsdFJlcXVlc3RPcHRpb25zLCBlbmNvZGluZyA9IHt9LCAuLi5jaGVlcmlvT3B0aW9ucyB9ID0gb3B0aW9ucztcbiAgICBsZXQgdW5kaWNpU3RyZWFtO1xuICAgIC8vIEFkZCBoZWFkZXJzIGlmIG5vbmUgd2VyZSBzdXBwbGllZC5cbiAgICAoX2EgPSByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAocmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IGRlZmF1bHRSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzKTtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB1bmRpY2lTdHJlYW0gPSB1bmRpY2kuc3RyZWFtKHVybCwgcmVxdWVzdE9wdGlvbnMsIChyZXMpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IChfYSA9IHJlcy5oZWFkZXJzWydjb250ZW50LXR5cGUnXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ3RleHQvaHRtbCc7XG4gICAgICAgICAgICBjb25zdCBtaW1lVHlwZSA9IG5ldyB3aGF0d2dfbWltZXR5cGVfMS5kZWZhdWx0KEFycmF5LmlzQXJyYXkoY29udGVudFR5cGUpID8gY29udGVudFR5cGVbMF0gOiBjb250ZW50VHlwZSk7XG4gICAgICAgICAgICBpZiAoIW1pbWVUeXBlLmlzSFRNTCgpICYmICFtaW1lVHlwZS5pc1hNTCgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFRoZSBjb250ZW50LXR5cGUgXCIke2NvbnRlbnRUeXBlfVwiIGlzIG5laXRoZXIgSFRNTCBub3IgWE1MLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRm9yd2FyZCB0aGUgY2hhcnNldCBmcm9tIHRoZSBoZWFkZXIgdG8gdGhlIGRlY29kZVN0cmVhbS5cbiAgICAgICAgICAgIGVuY29kaW5nLnRyYW5zcG9ydExheWVyRW5jb2RpbmdMYWJlbCA9IG1pbWVUeXBlLnBhcmFtZXRlcnMuZ2V0KCdjaGFyc2V0Jyk7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogSWYgd2UgYWxsb3cgcmVkaXJlY3RzLCB3ZSB3aWxsIGhhdmUgZW50cmllcyBpbiB0aGUgaGlzdG9yeS5cbiAgICAgICAgICAgICAqIFRoZSBsYXN0IGVudHJ5IHdpbGwgYmUgdGhlIGZpbmFsIFVSTC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgaGlzdG9yeSA9IChfYiA9IHJlcy5jb250ZXh0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaGlzdG9yeTtcbiAgICAgICAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgICAgICAgICAgZW5jb2RpbmcsXG4gICAgICAgICAgICAgICAgLy8gU2V0IFhNTCBtb2RlIGJhc2VkIG9uIHRoZSBNSU1FIHR5cGUuXG4gICAgICAgICAgICAgICAgeG1sTW9kZTogbWltZVR5cGUuaXNYTUwoKSxcbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIGBiYXNlVVJMYCB0byB0aGUgZmluYWwgVVJMLlxuICAgICAgICAgICAgICAgIGJhc2VVUkw6IGhpc3RvcnkgPyBoaXN0b3J5W2hpc3RvcnkubGVuZ3RoIC0gMV0gOiB1cmwsXG4gICAgICAgICAgICAgICAgLi4uY2hlZXJpb09wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZVN0cmVhbShvcHRzLCAoZXJyLCAkKSA9PiAoZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKCQpKSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8vIExldCdzIG1ha2Ugc3VyZSB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZWQgYmVmb3JlIHJldHVybmluZyB0aGUgcHJvbWlzZS5cbiAgICBhd2FpdCB1bmRpY2lTdHJlYW07XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/cheerio/dist/commonjs/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/cheerio/dist/commonjs/load-parse.js":
/*!**********************************************************!*\
  !*** ./node_modules/cheerio/dist/commonjs/load-parse.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.load = void 0;\nconst load_js_1 = __webpack_require__(/*! ./load.js */ \"(rsc)/./node_modules/cheerio/dist/commonjs/load.js\");\nconst parse_js_1 = __webpack_require__(/*! ./parse.js */ \"(rsc)/./node_modules/cheerio/dist/commonjs/parse.js\");\nconst parse5_adapter_js_1 = __webpack_require__(/*! ./parsers/parse5-adapter.js */ \"(rsc)/./node_modules/cheerio/dist/commonjs/parsers/parse5-adapter.js\");\nconst dom_serializer_1 = __importDefault(__webpack_require__(/*! dom-serializer */ \"(rsc)/./node_modules/dom-serializer/lib/index.js\"));\nconst htmlparser2_1 = __webpack_require__(/*! htmlparser2 */ \"(rsc)/./node_modules/htmlparser2/lib/index.js\");\nconst parse = (0, parse_js_1.getParse)((content, options, isDocument, context) => options._useHtmlParser2\n    ? (0, htmlparser2_1.parseDocument)(content, options)\n    : (0, parse5_adapter_js_1.parseWithParse5)(content, options, isDocument, context));\n// Duplicate docs due to https://github.com/TypeStrong/typedoc/issues/1616\n/**\n * Create a querying function, bound to a document created from the provided\n * markup.\n *\n * Note that similar to web browser contexts, this operation may introduce\n * `<html>`, `<head>`, and `<body>` elements; set `isDocument` to `false` to\n * switch to fragment mode and disable this.\n *\n * @category Loading\n * @param content - Markup to be loaded.\n * @param options - Options for the created instance.\n * @param isDocument - Allows parser to be switched to fragment mode.\n * @returns The loaded document.\n * @see {@link https://cheerio.js.org#loading} for additional usage information.\n */\nexports.load = (0, load_js_1.getLoad)(parse, (dom, options) => options._useHtmlParser2\n    ? (0, dom_serializer_1.default)(dom, options)\n    : (0, parse5_adapter_js_1.renderWithParse5)(dom));\n//# sourceMappingURL=load-parse.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2hlZXJpby9kaXN0L2NvbW1vbmpzL2xvYWQtcGFyc2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZO0FBQ1osa0JBQWtCLG1CQUFPLENBQUMscUVBQVc7QUFDckMsbUJBQW1CLG1CQUFPLENBQUMsdUVBQVk7QUFDdkMsNEJBQTRCLG1CQUFPLENBQUMseUdBQTZCO0FBQ2pFLHlDQUF5QyxtQkFBTyxDQUFDLHdFQUFnQjtBQUNqRSxzQkFBc0IsbUJBQU8sQ0FBQyxrRUFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHNDQUFzQztBQUMvQztBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2ltdGl5YXovRGVza3RvcC9TdXBlckxlYXJuL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9jaGVlcmlvL2Rpc3QvY29tbW9uanMvbG9hZC1wYXJzZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubG9hZCA9IHZvaWQgMDtcbmNvbnN0IGxvYWRfanNfMSA9IHJlcXVpcmUoXCIuL2xvYWQuanNcIik7XG5jb25zdCBwYXJzZV9qc18xID0gcmVxdWlyZShcIi4vcGFyc2UuanNcIik7XG5jb25zdCBwYXJzZTVfYWRhcHRlcl9qc18xID0gcmVxdWlyZShcIi4vcGFyc2Vycy9wYXJzZTUtYWRhcHRlci5qc1wiKTtcbmNvbnN0IGRvbV9zZXJpYWxpemVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRvbS1zZXJpYWxpemVyXCIpKTtcbmNvbnN0IGh0bWxwYXJzZXIyXzEgPSByZXF1aXJlKFwiaHRtbHBhcnNlcjJcIik7XG5jb25zdCBwYXJzZSA9ICgwLCBwYXJzZV9qc18xLmdldFBhcnNlKSgoY29udGVudCwgb3B0aW9ucywgaXNEb2N1bWVudCwgY29udGV4dCkgPT4gb3B0aW9ucy5fdXNlSHRtbFBhcnNlcjJcbiAgICA/ICgwLCBodG1scGFyc2VyMl8xLnBhcnNlRG9jdW1lbnQpKGNvbnRlbnQsIG9wdGlvbnMpXG4gICAgOiAoMCwgcGFyc2U1X2FkYXB0ZXJfanNfMS5wYXJzZVdpdGhQYXJzZTUpKGNvbnRlbnQsIG9wdGlvbnMsIGlzRG9jdW1lbnQsIGNvbnRleHQpKTtcbi8vIER1cGxpY2F0ZSBkb2NzIGR1ZSB0byBodHRwczovL2dpdGh1Yi5jb20vVHlwZVN0cm9uZy90eXBlZG9jL2lzc3Vlcy8xNjE2XG4vKipcbiAqIENyZWF0ZSBhIHF1ZXJ5aW5nIGZ1bmN0aW9uLCBib3VuZCB0byBhIGRvY3VtZW50IGNyZWF0ZWQgZnJvbSB0aGUgcHJvdmlkZWRcbiAqIG1hcmt1cC5cbiAqXG4gKiBOb3RlIHRoYXQgc2ltaWxhciB0byB3ZWIgYnJvd3NlciBjb250ZXh0cywgdGhpcyBvcGVyYXRpb24gbWF5IGludHJvZHVjZVxuICogYDxodG1sPmAsIGA8aGVhZD5gLCBhbmQgYDxib2R5PmAgZWxlbWVudHM7IHNldCBgaXNEb2N1bWVudGAgdG8gYGZhbHNlYCB0b1xuICogc3dpdGNoIHRvIGZyYWdtZW50IG1vZGUgYW5kIGRpc2FibGUgdGhpcy5cbiAqXG4gKiBAY2F0ZWdvcnkgTG9hZGluZ1xuICogQHBhcmFtIGNvbnRlbnQgLSBNYXJrdXAgdG8gYmUgbG9hZGVkLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgY3JlYXRlZCBpbnN0YW5jZS5cbiAqIEBwYXJhbSBpc0RvY3VtZW50IC0gQWxsb3dzIHBhcnNlciB0byBiZSBzd2l0Y2hlZCB0byBmcmFnbWVudCBtb2RlLlxuICogQHJldHVybnMgVGhlIGxvYWRlZCBkb2N1bWVudC5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vY2hlZXJpby5qcy5vcmcjbG9hZGluZ30gZm9yIGFkZGl0aW9uYWwgdXNhZ2UgaW5mb3JtYXRpb24uXG4gKi9cbmV4cG9ydHMubG9hZCA9ICgwLCBsb2FkX2pzXzEuZ2V0TG9hZCkocGFyc2UsIChkb20sIG9wdGlvbnMpID0+IG9wdGlvbnMuX3VzZUh0bWxQYXJzZXIyXG4gICAgPyAoMCwgZG9tX3NlcmlhbGl6ZXJfMS5kZWZhdWx0KShkb20sIG9wdGlvbnMpXG4gICAgOiAoMCwgcGFyc2U1X2FkYXB0ZXJfanNfMS5yZW5kZXJXaXRoUGFyc2U1KShkb20pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWQtcGFyc2UuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/cheerio/dist/commonjs/load-parse.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/cheerio/dist/commonjs/load.js":
/*!****************************************************!*\
  !*** ./node_modules/cheerio/dist/commonjs/load.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getLoad = getLoad;\nconst options_js_1 = __webpack_require__(/*! ./options.js */ \"(rsc)/./node_modules/cheerio/dist/commonjs/options.js\");\nconst staticMethods = __importStar(__webpack_require__(/*! ./static.js */ \"(rsc)/./node_modules/cheerio/dist/commonjs/static.js\"));\nconst cheerio_js_1 = __webpack_require__(/*! ./cheerio.js */ \"(rsc)/./node_modules/cheerio/dist/commonjs/cheerio.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/cheerio/dist/commonjs/utils.js\");\nfunction getLoad(parse, render) {\n    /**\n     * Create a querying function, bound to a document created from the provided\n     * markup.\n     *\n     * Note that similar to web browser contexts, this operation may introduce\n     * `<html>`, `<head>`, and `<body>` elements; set `isDocument` to `false` to\n     * switch to fragment mode and disable this.\n     *\n     * @param content - Markup to be loaded.\n     * @param options - Options for the created instance.\n     * @param isDocument - Allows parser to be switched to fragment mode.\n     * @returns The loaded document.\n     * @see {@link https://cheerio.js.org#loading} for additional usage information.\n     */\n    return function load(content, options, isDocument = true) {\n        if (content == null) {\n            throw new Error('cheerio.load() expects a string');\n        }\n        const internalOpts = (0, options_js_1.flattenOptions)(options);\n        const initialRoot = parse(content, internalOpts, isDocument, null);\n        /**\n         * Create an extended class here, so that extensions only live on one\n         * instance.\n         */\n        class LoadedCheerio extends cheerio_js_1.Cheerio {\n            _make(selector, context) {\n                const cheerio = initialize(selector, context);\n                cheerio.prevObject = this;\n                return cheerio;\n            }\n            _parse(content, options, isDocument, context) {\n                return parse(content, options, isDocument, context);\n            }\n            _render(dom) {\n                return render(dom, this.options);\n            }\n        }\n        function initialize(selector, context, root = initialRoot, opts) {\n            // $($)\n            if (selector && (0, utils_js_1.isCheerio)(selector))\n                return selector;\n            const options = (0, options_js_1.flattenOptions)(opts, internalOpts);\n            const r = typeof root === 'string'\n                ? [parse(root, options, false, null)]\n                : 'length' in root\n                    ? root\n                    : [root];\n            const rootInstance = (0, utils_js_1.isCheerio)(r)\n                ? r\n                : new LoadedCheerio(r, null, options);\n            // Add a cyclic reference, so that calling methods on `_root` never fails.\n            rootInstance._root = rootInstance;\n            // $(), $(null), $(undefined), $(false)\n            if (!selector) {\n                return new LoadedCheerio(undefined, rootInstance, options);\n            }\n            const elements = typeof selector === 'string' && (0, utils_js_1.isHtml)(selector)\n                ? // $(<html>)\n                    parse(selector, options, false, null).children\n                : isNode(selector)\n                    ? // $(dom)\n                        [selector]\n                    : Array.isArray(selector)\n                        ? // $([dom])\n                            selector\n                        : undefined;\n            const instance = new LoadedCheerio(elements, rootInstance, options);\n            if (elements) {\n                return instance;\n            }\n            if (typeof selector !== 'string') {\n                throw new TypeError('Unexpected type of selector');\n            }\n            // We know that our selector is a string now.\n            let search = selector;\n            const searchContext = context\n                ? // If we don't have a context, maybe we have a root, from loading\n                    typeof context === 'string'\n                        ? (0, utils_js_1.isHtml)(context)\n                            ? // $('li', '<ul>...</ul>')\n                                new LoadedCheerio([parse(context, options, false, null)], rootInstance, options)\n                            : // $('li', 'ul')\n                                ((search = `${context} ${search}`), rootInstance)\n                        : (0, utils_js_1.isCheerio)(context)\n                            ? // $('li', $)\n                                context\n                            : // $('li', node), $('li', [nodes])\n                                new LoadedCheerio(Array.isArray(context) ? context : [context], rootInstance, options)\n                : rootInstance;\n            // If we still don't have a context, return\n            if (!searchContext)\n                return instance;\n            /*\n             * #id, .class, tag\n             */\n            return searchContext.find(search);\n        }\n        // Add in static methods & properties\n        Object.assign(initialize, staticMethods, {\n            load,\n            // `_root` and `_options` are used in static methods.\n            _root: initialRoot,\n            _options: internalOpts,\n            // Add `fn` for plugins\n            fn: LoadedCheerio.prototype,\n            // Add the prototype here to maintain `instanceof` behavior.\n            prototype: LoadedCheerio.prototype,\n        });\n        return initialize;\n    };\n}\nfunction isNode(obj) {\n    return (!!obj.name ||\n        obj.type === 'root' ||\n        obj.type === 'text' ||\n        obj.type === 'comment');\n}\n//# sourceMappingURL=load.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2hlZXJpby9kaXN0L2NvbW1vbmpzL2xvYWQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZixxQkFBcUIsbUJBQU8sQ0FBQywyRUFBYztBQUMzQyxtQ0FBbUMsbUJBQU8sQ0FBQyx5RUFBYTtBQUN4RCxxQkFBcUIsbUJBQU8sQ0FBQywyRUFBYztBQUMzQyxtQkFBbUIsbUJBQU8sQ0FBQyx1RUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzQ0FBc0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFNBQVMsRUFBRSxPQUFPO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvaW10aXlhei9EZXNrdG9wL1N1cGVyTGVhcm4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2NoZWVyaW8vZGlzdC9jb21tb25qcy9sb2FkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldExvYWQgPSBnZXRMb2FkO1xuY29uc3Qgb3B0aW9uc19qc18xID0gcmVxdWlyZShcIi4vb3B0aW9ucy5qc1wiKTtcbmNvbnN0IHN0YXRpY01ldGhvZHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vc3RhdGljLmpzXCIpKTtcbmNvbnN0IGNoZWVyaW9fanNfMSA9IHJlcXVpcmUoXCIuL2NoZWVyaW8uanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG5mdW5jdGlvbiBnZXRMb2FkKHBhcnNlLCByZW5kZXIpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBxdWVyeWluZyBmdW5jdGlvbiwgYm91bmQgdG8gYSBkb2N1bWVudCBjcmVhdGVkIGZyb20gdGhlIHByb3ZpZGVkXG4gICAgICogbWFya3VwLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHNpbWlsYXIgdG8gd2ViIGJyb3dzZXIgY29udGV4dHMsIHRoaXMgb3BlcmF0aW9uIG1heSBpbnRyb2R1Y2VcbiAgICAgKiBgPGh0bWw+YCwgYDxoZWFkPmAsIGFuZCBgPGJvZHk+YCBlbGVtZW50czsgc2V0IGBpc0RvY3VtZW50YCB0byBgZmFsc2VgIHRvXG4gICAgICogc3dpdGNoIHRvIGZyYWdtZW50IG1vZGUgYW5kIGRpc2FibGUgdGhpcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250ZW50IC0gTWFya3VwIHRvIGJlIGxvYWRlZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBjcmVhdGVkIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSBpc0RvY3VtZW50IC0gQWxsb3dzIHBhcnNlciB0byBiZSBzd2l0Y2hlZCB0byBmcmFnbWVudCBtb2RlLlxuICAgICAqIEByZXR1cm5zIFRoZSBsb2FkZWQgZG9jdW1lbnQuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9jaGVlcmlvLmpzLm9yZyNsb2FkaW5nfSBmb3IgYWRkaXRpb25hbCB1c2FnZSBpbmZvcm1hdGlvbi5cbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24gbG9hZChjb250ZW50LCBvcHRpb25zLCBpc0RvY3VtZW50ID0gdHJ1ZSkge1xuICAgICAgICBpZiAoY29udGVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWVyaW8ubG9hZCgpIGV4cGVjdHMgYSBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnRlcm5hbE9wdHMgPSAoMCwgb3B0aW9uc19qc18xLmZsYXR0ZW5PcHRpb25zKShvcHRpb25zKTtcbiAgICAgICAgY29uc3QgaW5pdGlhbFJvb3QgPSBwYXJzZShjb250ZW50LCBpbnRlcm5hbE9wdHMsIGlzRG9jdW1lbnQsIG51bGwpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGFuIGV4dGVuZGVkIGNsYXNzIGhlcmUsIHNvIHRoYXQgZXh0ZW5zaW9ucyBvbmx5IGxpdmUgb24gb25lXG4gICAgICAgICAqIGluc3RhbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3MgTG9hZGVkQ2hlZXJpbyBleHRlbmRzIGNoZWVyaW9fanNfMS5DaGVlcmlvIHtcbiAgICAgICAgICAgIF9tYWtlKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hlZXJpbyA9IGluaXRpYWxpemUoc2VsZWN0b3IsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGNoZWVyaW8ucHJldk9iamVjdCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoZWVyaW87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfcGFyc2UoY29udGVudCwgb3B0aW9ucywgaXNEb2N1bWVudCwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZShjb250ZW50LCBvcHRpb25zLCBpc0RvY3VtZW50LCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9yZW5kZXIoZG9tKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlcihkb20sIHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaW5pdGlhbGl6ZShzZWxlY3RvciwgY29udGV4dCwgcm9vdCA9IGluaXRpYWxSb290LCBvcHRzKSB7XG4gICAgICAgICAgICAvLyAkKCQpXG4gICAgICAgICAgICBpZiAoc2VsZWN0b3IgJiYgKDAsIHV0aWxzX2pzXzEuaXNDaGVlcmlvKShzZWxlY3RvcikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdG9yO1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9ICgwLCBvcHRpb25zX2pzXzEuZmxhdHRlbk9wdGlvbnMpKG9wdHMsIGludGVybmFsT3B0cyk7XG4gICAgICAgICAgICBjb25zdCByID0gdHlwZW9mIHJvb3QgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgPyBbcGFyc2Uocm9vdCwgb3B0aW9ucywgZmFsc2UsIG51bGwpXVxuICAgICAgICAgICAgICAgIDogJ2xlbmd0aCcgaW4gcm9vdFxuICAgICAgICAgICAgICAgICAgICA/IHJvb3RcbiAgICAgICAgICAgICAgICAgICAgOiBbcm9vdF07XG4gICAgICAgICAgICBjb25zdCByb290SW5zdGFuY2UgPSAoMCwgdXRpbHNfanNfMS5pc0NoZWVyaW8pKHIpXG4gICAgICAgICAgICAgICAgPyByXG4gICAgICAgICAgICAgICAgOiBuZXcgTG9hZGVkQ2hlZXJpbyhyLCBudWxsLCBvcHRpb25zKTtcbiAgICAgICAgICAgIC8vIEFkZCBhIGN5Y2xpYyByZWZlcmVuY2UsIHNvIHRoYXQgY2FsbGluZyBtZXRob2RzIG9uIGBfcm9vdGAgbmV2ZXIgZmFpbHMuXG4gICAgICAgICAgICByb290SW5zdGFuY2UuX3Jvb3QgPSByb290SW5zdGFuY2U7XG4gICAgICAgICAgICAvLyAkKCksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcbiAgICAgICAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IExvYWRlZENoZWVyaW8odW5kZWZpbmVkLCByb290SW5zdGFuY2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSB0eXBlb2Ygc2VsZWN0b3IgPT09ICdzdHJpbmcnICYmICgwLCB1dGlsc19qc18xLmlzSHRtbCkoc2VsZWN0b3IpXG4gICAgICAgICAgICAgICAgPyAvLyAkKDxodG1sPilcbiAgICAgICAgICAgICAgICAgICAgcGFyc2Uoc2VsZWN0b3IsIG9wdGlvbnMsIGZhbHNlLCBudWxsKS5jaGlsZHJlblxuICAgICAgICAgICAgICAgIDogaXNOb2RlKHNlbGVjdG9yKVxuICAgICAgICAgICAgICAgICAgICA/IC8vICQoZG9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgW3NlbGVjdG9yXVxuICAgICAgICAgICAgICAgICAgICA6IEFycmF5LmlzQXJyYXkoc2VsZWN0b3IpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IC8vICQoW2RvbV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgTG9hZGVkQ2hlZXJpbyhlbGVtZW50cywgcm9vdEluc3RhbmNlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5leHBlY3RlZCB0eXBlIG9mIHNlbGVjdG9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBrbm93IHRoYXQgb3VyIHNlbGVjdG9yIGlzIGEgc3RyaW5nIG5vdy5cbiAgICAgICAgICAgIGxldCBzZWFyY2ggPSBzZWxlY3RvcjtcbiAgICAgICAgICAgIGNvbnN0IHNlYXJjaENvbnRleHQgPSBjb250ZXh0XG4gICAgICAgICAgICAgICAgPyAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgY29udGV4dCwgbWF5YmUgd2UgaGF2ZSBhIHJvb3QsIGZyb20gbG9hZGluZ1xuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgY29udGV4dCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKDAsIHV0aWxzX2pzXzEuaXNIdG1sKShjb250ZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gLy8gJCgnbGknLCAnPHVsPi4uLjwvdWw+JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IExvYWRlZENoZWVyaW8oW3BhcnNlKGNvbnRleHQsIG9wdGlvbnMsIGZhbHNlLCBudWxsKV0sIHJvb3RJbnN0YW5jZSwgb3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IC8vICQoJ2xpJywgJ3VsJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChzZWFyY2ggPSBgJHtjb250ZXh0fSAke3NlYXJjaH1gKSwgcm9vdEluc3RhbmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAoMCwgdXRpbHNfanNfMS5pc0NoZWVyaW8pKGNvbnRleHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAvLyAkKCdsaScsICQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IC8vICQoJ2xpJywgbm9kZSksICQoJ2xpJywgW25vZGVzXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IExvYWRlZENoZWVyaW8oQXJyYXkuaXNBcnJheShjb250ZXh0KSA/IGNvbnRleHQgOiBbY29udGV4dF0sIHJvb3RJbnN0YW5jZSwgb3B0aW9ucylcbiAgICAgICAgICAgICAgICA6IHJvb3RJbnN0YW5jZTtcbiAgICAgICAgICAgIC8vIElmIHdlIHN0aWxsIGRvbid0IGhhdmUgYSBjb250ZXh0LCByZXR1cm5cbiAgICAgICAgICAgIGlmICghc2VhcmNoQ29udGV4dClcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogI2lkLCAuY2xhc3MsIHRhZ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXR1cm4gc2VhcmNoQ29udGV4dC5maW5kKHNlYXJjaCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGluIHN0YXRpYyBtZXRob2RzICYgcHJvcGVydGllc1xuICAgICAgICBPYmplY3QuYXNzaWduKGluaXRpYWxpemUsIHN0YXRpY01ldGhvZHMsIHtcbiAgICAgICAgICAgIGxvYWQsXG4gICAgICAgICAgICAvLyBgX3Jvb3RgIGFuZCBgX29wdGlvbnNgIGFyZSB1c2VkIGluIHN0YXRpYyBtZXRob2RzLlxuICAgICAgICAgICAgX3Jvb3Q6IGluaXRpYWxSb290LFxuICAgICAgICAgICAgX29wdGlvbnM6IGludGVybmFsT3B0cyxcbiAgICAgICAgICAgIC8vIEFkZCBgZm5gIGZvciBwbHVnaW5zXG4gICAgICAgICAgICBmbjogTG9hZGVkQ2hlZXJpby5wcm90b3R5cGUsXG4gICAgICAgICAgICAvLyBBZGQgdGhlIHByb3RvdHlwZSBoZXJlIHRvIG1haW50YWluIGBpbnN0YW5jZW9mYCBiZWhhdmlvci5cbiAgICAgICAgICAgIHByb3RvdHlwZTogTG9hZGVkQ2hlZXJpby5wcm90b3R5cGUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaW5pdGlhbGl6ZTtcbiAgICB9O1xufVxuZnVuY3Rpb24gaXNOb2RlKG9iaikge1xuICAgIHJldHVybiAoISFvYmoubmFtZSB8fFxuICAgICAgICBvYmoudHlwZSA9PT0gJ3Jvb3QnIHx8XG4gICAgICAgIG9iai50eXBlID09PSAndGV4dCcgfHxcbiAgICAgICAgb2JqLnR5cGUgPT09ICdjb21tZW50Jyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/cheerio/dist/commonjs/load.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/cheerio/dist/commonjs/options.js":
/*!*******************************************************!*\
  !*** ./node_modules/cheerio/dist/commonjs/options.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.flattenOptions = flattenOptions;\nconst defaultOpts = {\n    _useHtmlParser2: false,\n};\n/**\n * Flatten the options for Cheerio.\n *\n * This will set `_useHtmlParser2` to true if `xml` is set to true.\n *\n * @param options - The options to flatten.\n * @param baseOptions - The base options to use.\n * @returns The flattened options.\n */\nfunction flattenOptions(options, baseOptions) {\n    if (!options) {\n        return baseOptions !== null && baseOptions !== void 0 ? baseOptions : defaultOpts;\n    }\n    const opts = {\n        _useHtmlParser2: !!options.xmlMode,\n        ...baseOptions,\n        ...options,\n    };\n    if (options.xml) {\n        opts._useHtmlParser2 = true;\n        opts.xmlMode = true;\n        if (options.xml !== true) {\n            Object.assign(opts, options.xml);\n        }\n    }\n    else if (options.xmlMode) {\n        opts._useHtmlParser2 = true;\n    }\n    return opts;\n}\n//# sourceMappingURL=options.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2hlZXJpby9kaXN0L2NvbW1vbmpzL29wdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9pbXRpeWF6L0Rlc2t0b3AvU3VwZXJMZWFybi9mcm9udGVuZC9ub2RlX21vZHVsZXMvY2hlZXJpby9kaXN0L2NvbW1vbmpzL29wdGlvbnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZsYXR0ZW5PcHRpb25zID0gZmxhdHRlbk9wdGlvbnM7XG5jb25zdCBkZWZhdWx0T3B0cyA9IHtcbiAgICBfdXNlSHRtbFBhcnNlcjI6IGZhbHNlLFxufTtcbi8qKlxuICogRmxhdHRlbiB0aGUgb3B0aW9ucyBmb3IgQ2hlZXJpby5cbiAqXG4gKiBUaGlzIHdpbGwgc2V0IGBfdXNlSHRtbFBhcnNlcjJgIHRvIHRydWUgaWYgYHhtbGAgaXMgc2V0IHRvIHRydWUuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byBmbGF0dGVuLlxuICogQHBhcmFtIGJhc2VPcHRpb25zIC0gVGhlIGJhc2Ugb3B0aW9ucyB0byB1c2UuXG4gKiBAcmV0dXJucyBUaGUgZmxhdHRlbmVkIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5PcHRpb25zKG9wdGlvbnMsIGJhc2VPcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBiYXNlT3B0aW9ucyAhPT0gbnVsbCAmJiBiYXNlT3B0aW9ucyAhPT0gdm9pZCAwID8gYmFzZU9wdGlvbnMgOiBkZWZhdWx0T3B0cztcbiAgICB9XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgX3VzZUh0bWxQYXJzZXIyOiAhIW9wdGlvbnMueG1sTW9kZSxcbiAgICAgICAgLi4uYmFzZU9wdGlvbnMsXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgfTtcbiAgICBpZiAob3B0aW9ucy54bWwpIHtcbiAgICAgICAgb3B0cy5fdXNlSHRtbFBhcnNlcjIgPSB0cnVlO1xuICAgICAgICBvcHRzLnhtbE1vZGUgPSB0cnVlO1xuICAgICAgICBpZiAob3B0aW9ucy54bWwgIT09IHRydWUpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3B0cywgb3B0aW9ucy54bWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbnMueG1sTW9kZSkge1xuICAgICAgICBvcHRzLl91c2VIdG1sUGFyc2VyMiA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBvcHRzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3B0aW9ucy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/cheerio/dist/commonjs/options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/cheerio/dist/commonjs/parse.js":
/*!*****************************************************!*\
  !*** ./node_modules/cheerio/dist/commonjs/parse.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getParse = getParse;\nexports.update = update;\nconst domutils_1 = __webpack_require__(/*! domutils */ \"(rsc)/./node_modules/domutils/lib/index.js\");\nconst domhandler_1 = __webpack_require__(/*! domhandler */ \"(rsc)/./node_modules/domhandler/lib/index.js\");\n/**\n * Get the parse function with options.\n *\n * @param parser - The parser function.\n * @returns The parse function with options.\n */\nfunction getParse(parser) {\n    /**\n     * Parse a HTML string or a node.\n     *\n     * @param content - The HTML string or node.\n     * @param options - The parser options.\n     * @param isDocument - If `content` is a document.\n     * @param context - The context node in the DOM tree.\n     * @returns The parsed document node.\n     */\n    return function parse(content, options, isDocument, context) {\n        if (typeof Buffer !== 'undefined' && Buffer.isBuffer(content)) {\n            content = content.toString();\n        }\n        if (typeof content === 'string') {\n            return parser(content, options, isDocument, context);\n        }\n        const doc = content;\n        if (!Array.isArray(doc) && (0, domhandler_1.isDocument)(doc)) {\n            // If `doc` is already a root, just return it\n            return doc;\n        }\n        // Add conent to new root element\n        const root = new domhandler_1.Document([]);\n        // Update the DOM using the root\n        update(doc, root);\n        return root;\n    };\n}\n/**\n * Update the dom structure, for one changed layer.\n *\n * @param newChilds - The new children.\n * @param parent - The new parent.\n * @returns The parent node.\n */\nfunction update(newChilds, parent) {\n    // Normalize\n    const arr = Array.isArray(newChilds) ? newChilds : [newChilds];\n    // Update parent\n    if (parent) {\n        parent.children = arr;\n    }\n    else {\n        parent = null;\n    }\n    // Update neighbors\n    for (let i = 0; i < arr.length; i++) {\n        const node = arr[i];\n        // Cleanly remove existing nodes from their previous structures.\n        if (node.parent && node.parent.children !== arr) {\n            (0, domutils_1.removeElement)(node);\n        }\n        if (parent) {\n            node.prev = arr[i - 1] || null;\n            node.next = arr[i + 1] || null;\n        }\n        else {\n            node.prev = node.next = null;\n        }\n        node.parent = parent;\n    }\n    return parent;\n}\n//# sourceMappingURL=parse.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2hlZXJpby9kaXN0L2NvbW1vbmpzL3BhcnNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsbUJBQW1CLG1CQUFPLENBQUMsNERBQVU7QUFDckMscUJBQXFCLG1CQUFPLENBQUMsZ0VBQVk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvaW10aXlhei9EZXNrdG9wL1N1cGVyTGVhcm4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2NoZWVyaW8vZGlzdC9jb21tb25qcy9wYXJzZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0UGFyc2UgPSBnZXRQYXJzZTtcbmV4cG9ydHMudXBkYXRlID0gdXBkYXRlO1xuY29uc3QgZG9tdXRpbHNfMSA9IHJlcXVpcmUoXCJkb211dGlsc1wiKTtcbmNvbnN0IGRvbWhhbmRsZXJfMSA9IHJlcXVpcmUoXCJkb21oYW5kbGVyXCIpO1xuLyoqXG4gKiBHZXQgdGhlIHBhcnNlIGZ1bmN0aW9uIHdpdGggb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gcGFyc2VyIC0gVGhlIHBhcnNlciBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIFRoZSBwYXJzZSBmdW5jdGlvbiB3aXRoIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGdldFBhcnNlKHBhcnNlcikge1xuICAgIC8qKlxuICAgICAqIFBhcnNlIGEgSFRNTCBzdHJpbmcgb3IgYSBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnRlbnQgLSBUaGUgSFRNTCBzdHJpbmcgb3Igbm9kZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBwYXJzZXIgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gaXNEb2N1bWVudCAtIElmIGBjb250ZW50YCBpcyBhIGRvY3VtZW50LlxuICAgICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGNvbnRleHQgbm9kZSBpbiB0aGUgRE9NIHRyZWUuXG4gICAgICogQHJldHVybnMgVGhlIHBhcnNlZCBkb2N1bWVudCBub2RlLlxuICAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbiBwYXJzZShjb250ZW50LCBvcHRpb25zLCBpc0RvY3VtZW50LCBjb250ZXh0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBCdWZmZXIuaXNCdWZmZXIoY29udGVudCkpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlcihjb250ZW50LCBvcHRpb25zLCBpc0RvY3VtZW50LCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkb2MgPSBjb250ZW50O1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZG9jKSAmJiAoMCwgZG9taGFuZGxlcl8xLmlzRG9jdW1lbnQpKGRvYykpIHtcbiAgICAgICAgICAgIC8vIElmIGBkb2NgIGlzIGFscmVhZHkgYSByb290LCBqdXN0IHJldHVybiBpdFxuICAgICAgICAgICAgcmV0dXJuIGRvYztcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgY29uZW50IHRvIG5ldyByb290IGVsZW1lbnRcbiAgICAgICAgY29uc3Qgcm9vdCA9IG5ldyBkb21oYW5kbGVyXzEuRG9jdW1lbnQoW10pO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIERPTSB1c2luZyB0aGUgcm9vdFxuICAgICAgICB1cGRhdGUoZG9jLCByb290KTtcbiAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfTtcbn1cbi8qKlxuICogVXBkYXRlIHRoZSBkb20gc3RydWN0dXJlLCBmb3Igb25lIGNoYW5nZWQgbGF5ZXIuXG4gKlxuICogQHBhcmFtIG5ld0NoaWxkcyAtIFRoZSBuZXcgY2hpbGRyZW4uXG4gKiBAcGFyYW0gcGFyZW50IC0gVGhlIG5ldyBwYXJlbnQuXG4gKiBAcmV0dXJucyBUaGUgcGFyZW50IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZShuZXdDaGlsZHMsIHBhcmVudCkge1xuICAgIC8vIE5vcm1hbGl6ZVxuICAgIGNvbnN0IGFyciA9IEFycmF5LmlzQXJyYXkobmV3Q2hpbGRzKSA/IG5ld0NoaWxkcyA6IFtuZXdDaGlsZHNdO1xuICAgIC8vIFVwZGF0ZSBwYXJlbnRcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHBhcmVudC5jaGlsZHJlbiA9IGFycjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBhcmVudCA9IG51bGw7XG4gICAgfVxuICAgIC8vIFVwZGF0ZSBuZWlnaGJvcnNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gYXJyW2ldO1xuICAgICAgICAvLyBDbGVhbmx5IHJlbW92ZSBleGlzdGluZyBub2RlcyBmcm9tIHRoZWlyIHByZXZpb3VzIHN0cnVjdHVyZXMuXG4gICAgICAgIGlmIChub2RlLnBhcmVudCAmJiBub2RlLnBhcmVudC5jaGlsZHJlbiAhPT0gYXJyKSB7XG4gICAgICAgICAgICAoMCwgZG9tdXRpbHNfMS5yZW1vdmVFbGVtZW50KShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICBub2RlLnByZXYgPSBhcnJbaSAtIDFdIHx8IG51bGw7XG4gICAgICAgICAgICBub2RlLm5leHQgPSBhcnJbaSArIDFdIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub2RlLnByZXYgPSBub2RlLm5leHQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUucGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gcGFyZW50O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2UuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/cheerio/dist/commonjs/parse.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/cheerio/dist/commonjs/parsers/parse5-adapter.js":
/*!**********************************************************************!*\
  !*** ./node_modules/cheerio/dist/commonjs/parsers/parse5-adapter.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseWithParse5 = parseWithParse5;\nexports.renderWithParse5 = renderWithParse5;\nconst domhandler_1 = __webpack_require__(/*! domhandler */ \"(rsc)/./node_modules/domhandler/lib/index.js\");\nconst parse5_1 = __webpack_require__(/*! parse5 */ \"(rsc)/./node_modules/parse5/dist/cjs/index.js\");\nconst parse5_htmlparser2_tree_adapter_1 = __webpack_require__(/*! parse5-htmlparser2-tree-adapter */ \"(rsc)/./node_modules/parse5-htmlparser2-tree-adapter/dist/cjs/index.js\");\n/**\n * Parse the content with `parse5` in the context of the given `ParentNode`.\n *\n * @param content - The content to parse.\n * @param options - A set of options to use to parse.\n * @param isDocument - Whether to parse the content as a full HTML document.\n * @param context - The context in which to parse the content.\n * @returns The parsed content.\n */\nfunction parseWithParse5(content, options, isDocument, context) {\n    var _a;\n    (_a = options.treeAdapter) !== null && _a !== void 0 ? _a : (options.treeAdapter = parse5_htmlparser2_tree_adapter_1.adapter);\n    if (options.scriptingEnabled !== false) {\n        options.scriptingEnabled = true;\n    }\n    return isDocument\n        ? (0, parse5_1.parse)(content, options)\n        : (0, parse5_1.parseFragment)(context, content, options);\n}\nconst renderOpts = { treeAdapter: parse5_htmlparser2_tree_adapter_1.adapter };\n/**\n * Renders the given DOM tree with `parse5` and returns the result as a string.\n *\n * @param dom - The DOM tree to render.\n * @returns The rendered document.\n */\nfunction renderWithParse5(dom) {\n    /*\n     * `dom-serializer` passes over the special \"root\" node and renders the\n     * node's children in its place. To mimic this behavior with `parse5`, an\n     * equivalent operation must be applied to the input array.\n     */\n    const nodes = 'length' in dom ? dom : [dom];\n    for (let index = 0; index < nodes.length; index += 1) {\n        const node = nodes[index];\n        if ((0, domhandler_1.isDocument)(node)) {\n            Array.prototype.splice.call(nodes, index, 1, ...node.children);\n        }\n    }\n    let result = '';\n    for (let index = 0; index < nodes.length; index += 1) {\n        const node = nodes[index];\n        result += (0, parse5_1.serializeOuter)(node, renderOpts);\n    }\n    return result;\n}\n//# sourceMappingURL=parse5-adapter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2hlZXJpby9kaXN0L2NvbW1vbmpzL3BhcnNlcnMvcGFyc2U1LWFkYXB0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCO0FBQ3ZCLHdCQUF3QjtBQUN4QixxQkFBcUIsbUJBQU8sQ0FBQyxnRUFBWTtBQUN6QyxpQkFBaUIsbUJBQU8sQ0FBQyw2REFBUTtBQUNqQywwQ0FBMEMsbUJBQU8sQ0FBQywrR0FBaUM7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9pbXRpeWF6L0Rlc2t0b3AvU3VwZXJMZWFybi9mcm9udGVuZC9ub2RlX21vZHVsZXMvY2hlZXJpby9kaXN0L2NvbW1vbmpzL3BhcnNlcnMvcGFyc2U1LWFkYXB0ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhcnNlV2l0aFBhcnNlNSA9IHBhcnNlV2l0aFBhcnNlNTtcbmV4cG9ydHMucmVuZGVyV2l0aFBhcnNlNSA9IHJlbmRlcldpdGhQYXJzZTU7XG5jb25zdCBkb21oYW5kbGVyXzEgPSByZXF1aXJlKFwiZG9taGFuZGxlclwiKTtcbmNvbnN0IHBhcnNlNV8xID0gcmVxdWlyZShcInBhcnNlNVwiKTtcbmNvbnN0IHBhcnNlNV9odG1scGFyc2VyMl90cmVlX2FkYXB0ZXJfMSA9IHJlcXVpcmUoXCJwYXJzZTUtaHRtbHBhcnNlcjItdHJlZS1hZGFwdGVyXCIpO1xuLyoqXG4gKiBQYXJzZSB0aGUgY29udGVudCB3aXRoIGBwYXJzZTVgIGluIHRoZSBjb250ZXh0IG9mIHRoZSBnaXZlbiBgUGFyZW50Tm9kZWAuXG4gKlxuICogQHBhcmFtIGNvbnRlbnQgLSBUaGUgY29udGVudCB0byBwYXJzZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gQSBzZXQgb2Ygb3B0aW9ucyB0byB1c2UgdG8gcGFyc2UuXG4gKiBAcGFyYW0gaXNEb2N1bWVudCAtIFdoZXRoZXIgdG8gcGFyc2UgdGhlIGNvbnRlbnQgYXMgYSBmdWxsIEhUTUwgZG9jdW1lbnQuXG4gKiBAcGFyYW0gY29udGV4dCAtIFRoZSBjb250ZXh0IGluIHdoaWNoIHRvIHBhcnNlIHRoZSBjb250ZW50LlxuICogQHJldHVybnMgVGhlIHBhcnNlZCBjb250ZW50LlxuICovXG5mdW5jdGlvbiBwYXJzZVdpdGhQYXJzZTUoY29udGVudCwgb3B0aW9ucywgaXNEb2N1bWVudCwgY29udGV4dCkge1xuICAgIHZhciBfYTtcbiAgICAoX2EgPSBvcHRpb25zLnRyZWVBZGFwdGVyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAob3B0aW9ucy50cmVlQWRhcHRlciA9IHBhcnNlNV9odG1scGFyc2VyMl90cmVlX2FkYXB0ZXJfMS5hZGFwdGVyKTtcbiAgICBpZiAob3B0aW9ucy5zY3JpcHRpbmdFbmFibGVkICE9PSBmYWxzZSkge1xuICAgICAgICBvcHRpb25zLnNjcmlwdGluZ0VuYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gaXNEb2N1bWVudFxuICAgICAgICA/ICgwLCBwYXJzZTVfMS5wYXJzZSkoY29udGVudCwgb3B0aW9ucylcbiAgICAgICAgOiAoMCwgcGFyc2U1XzEucGFyc2VGcmFnbWVudCkoY29udGV4dCwgY29udGVudCwgb3B0aW9ucyk7XG59XG5jb25zdCByZW5kZXJPcHRzID0geyB0cmVlQWRhcHRlcjogcGFyc2U1X2h0bWxwYXJzZXIyX3RyZWVfYWRhcHRlcl8xLmFkYXB0ZXIgfTtcbi8qKlxuICogUmVuZGVycyB0aGUgZ2l2ZW4gRE9NIHRyZWUgd2l0aCBgcGFyc2U1YCBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBkb20gLSBUaGUgRE9NIHRyZWUgdG8gcmVuZGVyLlxuICogQHJldHVybnMgVGhlIHJlbmRlcmVkIGRvY3VtZW50LlxuICovXG5mdW5jdGlvbiByZW5kZXJXaXRoUGFyc2U1KGRvbSkge1xuICAgIC8qXG4gICAgICogYGRvbS1zZXJpYWxpemVyYCBwYXNzZXMgb3ZlciB0aGUgc3BlY2lhbCBcInJvb3RcIiBub2RlIGFuZCByZW5kZXJzIHRoZVxuICAgICAqIG5vZGUncyBjaGlsZHJlbiBpbiBpdHMgcGxhY2UuIFRvIG1pbWljIHRoaXMgYmVoYXZpb3Igd2l0aCBgcGFyc2U1YCwgYW5cbiAgICAgKiBlcXVpdmFsZW50IG9wZXJhdGlvbiBtdXN0IGJlIGFwcGxpZWQgdG8gdGhlIGlucHV0IGFycmF5LlxuICAgICAqL1xuICAgIGNvbnN0IG5vZGVzID0gJ2xlbmd0aCcgaW4gZG9tID8gZG9tIDogW2RvbV07XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG5vZGVzLmxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaW5kZXhdO1xuICAgICAgICBpZiAoKDAsIGRvbWhhbmRsZXJfMS5pc0RvY3VtZW50KShub2RlKSkge1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNwbGljZS5jYWxsKG5vZGVzLCBpbmRleCwgMSwgLi4ubm9kZS5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBub2Rlcy5sZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2luZGV4XTtcbiAgICAgICAgcmVzdWx0ICs9ICgwLCBwYXJzZTVfMS5zZXJpYWxpemVPdXRlcikobm9kZSwgcmVuZGVyT3B0cyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZTUtYWRhcHRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/cheerio/dist/commonjs/parsers/parse5-adapter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/cheerio/dist/commonjs/static.js":
/*!******************************************************!*\
  !*** ./node_modules/cheerio/dist/commonjs/static.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.html = html;\nexports.xml = xml;\nexports.text = text;\nexports.parseHTML = parseHTML;\nexports.root = root;\nexports.contains = contains;\nexports.extract = extract;\nexports.merge = merge;\nconst domutils_1 = __webpack_require__(/*! domutils */ \"(rsc)/./node_modules/domutils/lib/index.js\");\nconst options_js_1 = __webpack_require__(/*! ./options.js */ \"(rsc)/./node_modules/cheerio/dist/commonjs/options.js\");\n/**\n * Helper function to render a DOM.\n *\n * @param that - Cheerio instance to render.\n * @param dom - The DOM to render. Defaults to `that`'s root.\n * @param options - Options for rendering.\n * @returns The rendered document.\n */\nfunction render(that, dom, options) {\n    if (!that)\n        return '';\n    return that(dom !== null && dom !== void 0 ? dom : that._root.children, null, undefined, options).toString();\n}\n/**\n * Checks if a passed object is an options object.\n *\n * @param dom - Object to check if it is an options object.\n * @param options - Options object.\n * @returns Whether the object is an options object.\n */\nfunction isOptions(dom, options) {\n    return (!options &&\n        typeof dom === 'object' &&\n        dom != null &&\n        !('length' in dom) &&\n        !('type' in dom));\n}\nfunction html(dom, options) {\n    /*\n     * Be flexible about parameters, sometimes we call html(),\n     * with options as only parameter\n     * check dom argument for dom element specific properties\n     * assume there is no 'length' or 'type' properties in the options object\n     */\n    const toRender = isOptions(dom) ? ((options = dom), undefined) : dom;\n    /*\n     * Sometimes `$.html()` is used without preloading html,\n     * so fallback non-existing options to the default ones.\n     */\n    const opts = {\n        ...this === null || this === void 0 ? void 0 : this._options,\n        ...(0, options_js_1.flattenOptions)(options),\n    };\n    return render(this, toRender, opts);\n}\n/**\n * Render the document as XML.\n *\n * @category Static\n * @param dom - Element to render.\n * @returns THe rendered document.\n */\nfunction xml(dom) {\n    const options = { ...this._options, xmlMode: true };\n    return render(this, dom, options);\n}\n/**\n * Render the document as text.\n *\n * This returns the `textContent` of the passed elements. The result will\n * include the contents of `<script>` and `<style>` elements. To avoid this, use\n * `.prop('innerText')` instead.\n *\n * @category Static\n * @param elements - Elements to render.\n * @returns The rendered document.\n */\nfunction text(elements) {\n    const elems = elements !== null && elements !== void 0 ? elements : (this ? this.root() : []);\n    let ret = '';\n    for (let i = 0; i < elems.length; i++) {\n        ret += (0, domutils_1.textContent)(elems[i]);\n    }\n    return ret;\n}\nfunction parseHTML(data, context, keepScripts = typeof context === 'boolean' ? context : false) {\n    if (!data || typeof data !== 'string') {\n        return null;\n    }\n    if (typeof context === 'boolean') {\n        keepScripts = context;\n    }\n    const parsed = this.load(data, this._options, false);\n    if (!keepScripts) {\n        parsed('script').remove();\n    }\n    /*\n     * The `children` array is used by Cheerio internally to group elements that\n     * share the same parents. When nodes created through `parseHTML` are\n     * inserted into previously-existing DOM structures, they will be removed\n     * from the `children` array. The results of `parseHTML` should remain\n     * constant across these operations, so a shallow copy should be returned.\n     */\n    return [...parsed.root()[0].children];\n}\n/**\n * Sometimes you need to work with the top-level root element. To query it, you\n * can use `$.root()`.\n *\n * @category Static\n * @example\n *\n * ```js\n * $.root().append('<ul id=\"vegetables\"></ul>').html();\n * //=> <ul id=\"fruits\">...</ul><ul id=\"vegetables\"></ul>\n * ```\n *\n * @returns Cheerio instance wrapping the root node.\n * @alias Cheerio.root\n */\nfunction root() {\n    return this(this._root);\n}\n/**\n * Checks to see if the `contained` DOM element is a descendant of the\n * `container` DOM element.\n *\n * @category Static\n * @param container - Potential parent node.\n * @param contained - Potential child node.\n * @returns Indicates if the nodes contain one another.\n * @alias Cheerio.contains\n * @see {@link https://api.jquery.com/jQuery.contains/}\n */\nfunction contains(container, contained) {\n    // According to the jQuery API, an element does not \"contain\" itself\n    if (contained === container) {\n        return false;\n    }\n    /*\n     * Step up the descendants, stopping when the root element is reached\n     * (signaled by `.parent` returning a reference to the same object)\n     */\n    let next = contained;\n    while (next && next !== next.parent) {\n        next = next.parent;\n        if (next === container) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Extract multiple values from a document, and store them in an object.\n *\n * @category Static\n * @param map - An object containing key-value pairs. The keys are the names of\n *   the properties to be created on the object, and the values are the\n *   selectors to be used to extract the values.\n * @returns An object containing the extracted values.\n */\nfunction extract(map) {\n    return this.root().extract(map);\n}\n/**\n * $.merge().\n *\n * @category Static\n * @param arr1 - First array.\n * @param arr2 - Second array.\n * @returns `arr1`, with elements of `arr2` inserted.\n * @alias Cheerio.merge\n * @see {@link https://api.jquery.com/jQuery.merge/}\n */\nfunction merge(arr1, arr2) {\n    if (!isArrayLike(arr1) || !isArrayLike(arr2)) {\n        return;\n    }\n    let newLength = arr1.length;\n    const len = +arr2.length;\n    for (let i = 0; i < len; i++) {\n        arr1[newLength++] = arr2[i];\n    }\n    arr1.length = newLength;\n    return arr1;\n}\n/**\n * Checks if an object is array-like.\n *\n * @category Static\n * @param item - Item to check.\n * @returns Indicates if the item is array-like.\n */\nfunction isArrayLike(item) {\n    if (Array.isArray(item)) {\n        return true;\n    }\n    if (typeof item !== 'object' ||\n        item === null ||\n        !('length' in item) ||\n        typeof item.length !== 'number' ||\n        item.length < 0) {\n        return false;\n    }\n    for (let i = 0; i < item.length; i++) {\n        if (!(i in item)) {\n            return false;\n        }\n    }\n    return true;\n}\n//# sourceMappingURL=static.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2hlZXJpby9kaXN0L2NvbW1vbmpzL3N0YXRpYy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZO0FBQ1osV0FBVztBQUNYLFlBQVk7QUFDWixpQkFBaUI7QUFDakIsWUFBWTtBQUNaLGdCQUFnQjtBQUNoQixlQUFlO0FBQ2YsYUFBYTtBQUNiLG1CQUFtQixtQkFBTyxDQUFDLDREQUFVO0FBQ3JDLHFCQUFxQixtQkFBTyxDQUFDLDJFQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvaW10aXlhei9EZXNrdG9wL1N1cGVyTGVhcm4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2NoZWVyaW8vZGlzdC9jb21tb25qcy9zdGF0aWMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmh0bWwgPSBodG1sO1xuZXhwb3J0cy54bWwgPSB4bWw7XG5leHBvcnRzLnRleHQgPSB0ZXh0O1xuZXhwb3J0cy5wYXJzZUhUTUwgPSBwYXJzZUhUTUw7XG5leHBvcnRzLnJvb3QgPSByb290O1xuZXhwb3J0cy5jb250YWlucyA9IGNvbnRhaW5zO1xuZXhwb3J0cy5leHRyYWN0ID0gZXh0cmFjdDtcbmV4cG9ydHMubWVyZ2UgPSBtZXJnZTtcbmNvbnN0IGRvbXV0aWxzXzEgPSByZXF1aXJlKFwiZG9tdXRpbHNcIik7XG5jb25zdCBvcHRpb25zX2pzXzEgPSByZXF1aXJlKFwiLi9vcHRpb25zLmpzXCIpO1xuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gcmVuZGVyIGEgRE9NLlxuICpcbiAqIEBwYXJhbSB0aGF0IC0gQ2hlZXJpbyBpbnN0YW5jZSB0byByZW5kZXIuXG4gKiBAcGFyYW0gZG9tIC0gVGhlIERPTSB0byByZW5kZXIuIERlZmF1bHRzIHRvIGB0aGF0YCdzIHJvb3QuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHJlbmRlcmluZy5cbiAqIEByZXR1cm5zIFRoZSByZW5kZXJlZCBkb2N1bWVudC5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyKHRoYXQsIGRvbSwgb3B0aW9ucykge1xuICAgIGlmICghdGhhdClcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIHJldHVybiB0aGF0KGRvbSAhPT0gbnVsbCAmJiBkb20gIT09IHZvaWQgMCA/IGRvbSA6IHRoYXQuX3Jvb3QuY2hpbGRyZW4sIG51bGwsIHVuZGVmaW5lZCwgb3B0aW9ucykudG9TdHJpbmcoKTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIGEgcGFzc2VkIG9iamVjdCBpcyBhbiBvcHRpb25zIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gZG9tIC0gT2JqZWN0IHRvIGNoZWNrIGlmIGl0IGlzIGFuIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIG9iamVjdC5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIG9iamVjdCBpcyBhbiBvcHRpb25zIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNPcHRpb25zKGRvbSwgb3B0aW9ucykge1xuICAgIHJldHVybiAoIW9wdGlvbnMgJiZcbiAgICAgICAgdHlwZW9mIGRvbSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgZG9tICE9IG51bGwgJiZcbiAgICAgICAgISgnbGVuZ3RoJyBpbiBkb20pICYmXG4gICAgICAgICEoJ3R5cGUnIGluIGRvbSkpO1xufVxuZnVuY3Rpb24gaHRtbChkb20sIG9wdGlvbnMpIHtcbiAgICAvKlxuICAgICAqIEJlIGZsZXhpYmxlIGFib3V0IHBhcmFtZXRlcnMsIHNvbWV0aW1lcyB3ZSBjYWxsIGh0bWwoKSxcbiAgICAgKiB3aXRoIG9wdGlvbnMgYXMgb25seSBwYXJhbWV0ZXJcbiAgICAgKiBjaGVjayBkb20gYXJndW1lbnQgZm9yIGRvbSBlbGVtZW50IHNwZWNpZmljIHByb3BlcnRpZXNcbiAgICAgKiBhc3N1bWUgdGhlcmUgaXMgbm8gJ2xlbmd0aCcgb3IgJ3R5cGUnIHByb3BlcnRpZXMgaW4gdGhlIG9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgY29uc3QgdG9SZW5kZXIgPSBpc09wdGlvbnMoZG9tKSA/ICgob3B0aW9ucyA9IGRvbSksIHVuZGVmaW5lZCkgOiBkb207XG4gICAgLypcbiAgICAgKiBTb21ldGltZXMgYCQuaHRtbCgpYCBpcyB1c2VkIHdpdGhvdXQgcHJlbG9hZGluZyBodG1sLFxuICAgICAqIHNvIGZhbGxiYWNrIG5vbi1leGlzdGluZyBvcHRpb25zIHRvIHRoZSBkZWZhdWx0IG9uZXMuXG4gICAgICovXG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgLi4udGhpcyA9PT0gbnVsbCB8fCB0aGlzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0aGlzLl9vcHRpb25zLFxuICAgICAgICAuLi4oMCwgb3B0aW9uc19qc18xLmZsYXR0ZW5PcHRpb25zKShvcHRpb25zKSxcbiAgICB9O1xuICAgIHJldHVybiByZW5kZXIodGhpcywgdG9SZW5kZXIsIG9wdHMpO1xufVxuLyoqXG4gKiBSZW5kZXIgdGhlIGRvY3VtZW50IGFzIFhNTC5cbiAqXG4gKiBAY2F0ZWdvcnkgU3RhdGljXG4gKiBAcGFyYW0gZG9tIC0gRWxlbWVudCB0byByZW5kZXIuXG4gKiBAcmV0dXJucyBUSGUgcmVuZGVyZWQgZG9jdW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHhtbChkb20pIHtcbiAgICBjb25zdCBvcHRpb25zID0geyAuLi50aGlzLl9vcHRpb25zLCB4bWxNb2RlOiB0cnVlIH07XG4gICAgcmV0dXJuIHJlbmRlcih0aGlzLCBkb20sIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBSZW5kZXIgdGhlIGRvY3VtZW50IGFzIHRleHQuXG4gKlxuICogVGhpcyByZXR1cm5zIHRoZSBgdGV4dENvbnRlbnRgIG9mIHRoZSBwYXNzZWQgZWxlbWVudHMuIFRoZSByZXN1bHQgd2lsbFxuICogaW5jbHVkZSB0aGUgY29udGVudHMgb2YgYDxzY3JpcHQ+YCBhbmQgYDxzdHlsZT5gIGVsZW1lbnRzLiBUbyBhdm9pZCB0aGlzLCB1c2VcbiAqIGAucHJvcCgnaW5uZXJUZXh0JylgIGluc3RlYWQuXG4gKlxuICogQGNhdGVnb3J5IFN0YXRpY1xuICogQHBhcmFtIGVsZW1lbnRzIC0gRWxlbWVudHMgdG8gcmVuZGVyLlxuICogQHJldHVybnMgVGhlIHJlbmRlcmVkIGRvY3VtZW50LlxuICovXG5mdW5jdGlvbiB0ZXh0KGVsZW1lbnRzKSB7XG4gICAgY29uc3QgZWxlbXMgPSBlbGVtZW50cyAhPT0gbnVsbCAmJiBlbGVtZW50cyAhPT0gdm9pZCAwID8gZWxlbWVudHMgOiAodGhpcyA/IHRoaXMucm9vdCgpIDogW10pO1xuICAgIGxldCByZXQgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJldCArPSAoMCwgZG9tdXRpbHNfMS50ZXh0Q29udGVudCkoZWxlbXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gcGFyc2VIVE1MKGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzID0gdHlwZW9mIGNvbnRleHQgPT09ICdib29sZWFuJyA/IGNvbnRleHQgOiBmYWxzZSkge1xuICAgIGlmICghZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29udGV4dCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGtlZXBTY3JpcHRzID0gY29udGV4dDtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5sb2FkKGRhdGEsIHRoaXMuX29wdGlvbnMsIGZhbHNlKTtcbiAgICBpZiAoIWtlZXBTY3JpcHRzKSB7XG4gICAgICAgIHBhcnNlZCgnc2NyaXB0JykucmVtb3ZlKCk7XG4gICAgfVxuICAgIC8qXG4gICAgICogVGhlIGBjaGlsZHJlbmAgYXJyYXkgaXMgdXNlZCBieSBDaGVlcmlvIGludGVybmFsbHkgdG8gZ3JvdXAgZWxlbWVudHMgdGhhdFxuICAgICAqIHNoYXJlIHRoZSBzYW1lIHBhcmVudHMuIFdoZW4gbm9kZXMgY3JlYXRlZCB0aHJvdWdoIGBwYXJzZUhUTUxgIGFyZVxuICAgICAqIGluc2VydGVkIGludG8gcHJldmlvdXNseS1leGlzdGluZyBET00gc3RydWN0dXJlcywgdGhleSB3aWxsIGJlIHJlbW92ZWRcbiAgICAgKiBmcm9tIHRoZSBgY2hpbGRyZW5gIGFycmF5LiBUaGUgcmVzdWx0cyBvZiBgcGFyc2VIVE1MYCBzaG91bGQgcmVtYWluXG4gICAgICogY29uc3RhbnQgYWNyb3NzIHRoZXNlIG9wZXJhdGlvbnMsIHNvIGEgc2hhbGxvdyBjb3B5IHNob3VsZCBiZSByZXR1cm5lZC5cbiAgICAgKi9cbiAgICByZXR1cm4gWy4uLnBhcnNlZC5yb290KClbMF0uY2hpbGRyZW5dO1xufVxuLyoqXG4gKiBTb21ldGltZXMgeW91IG5lZWQgdG8gd29yayB3aXRoIHRoZSB0b3AtbGV2ZWwgcm9vdCBlbGVtZW50LiBUbyBxdWVyeSBpdCwgeW91XG4gKiBjYW4gdXNlIGAkLnJvb3QoKWAuXG4gKlxuICogQGNhdGVnb3J5IFN0YXRpY1xuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogJC5yb290KCkuYXBwZW5kKCc8dWwgaWQ9XCJ2ZWdldGFibGVzXCI+PC91bD4nKS5odG1sKCk7XG4gKiAvLz0+IDx1bCBpZD1cImZydWl0c1wiPi4uLjwvdWw+PHVsIGlkPVwidmVnZXRhYmxlc1wiPjwvdWw+XG4gKiBgYGBcbiAqXG4gKiBAcmV0dXJucyBDaGVlcmlvIGluc3RhbmNlIHdyYXBwaW5nIHRoZSByb290IG5vZGUuXG4gKiBAYWxpYXMgQ2hlZXJpby5yb290XG4gKi9cbmZ1bmN0aW9uIHJvb3QoKSB7XG4gICAgcmV0dXJuIHRoaXModGhpcy5fcm9vdCk7XG59XG4vKipcbiAqIENoZWNrcyB0byBzZWUgaWYgdGhlIGBjb250YWluZWRgIERPTSBlbGVtZW50IGlzIGEgZGVzY2VuZGFudCBvZiB0aGVcbiAqIGBjb250YWluZXJgIERPTSBlbGVtZW50LlxuICpcbiAqIEBjYXRlZ29yeSBTdGF0aWNcbiAqIEBwYXJhbSBjb250YWluZXIgLSBQb3RlbnRpYWwgcGFyZW50IG5vZGUuXG4gKiBAcGFyYW0gY29udGFpbmVkIC0gUG90ZW50aWFsIGNoaWxkIG5vZGUuXG4gKiBAcmV0dXJucyBJbmRpY2F0ZXMgaWYgdGhlIG5vZGVzIGNvbnRhaW4gb25lIGFub3RoZXIuXG4gKiBAYWxpYXMgQ2hlZXJpby5jb250YWluc1xuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9hcGkuanF1ZXJ5LmNvbS9qUXVlcnkuY29udGFpbnMvfVxuICovXG5mdW5jdGlvbiBjb250YWlucyhjb250YWluZXIsIGNvbnRhaW5lZCkge1xuICAgIC8vIEFjY29yZGluZyB0byB0aGUgalF1ZXJ5IEFQSSwgYW4gZWxlbWVudCBkb2VzIG5vdCBcImNvbnRhaW5cIiBpdHNlbGZcbiAgICBpZiAoY29udGFpbmVkID09PSBjb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKlxuICAgICAqIFN0ZXAgdXAgdGhlIGRlc2NlbmRhbnRzLCBzdG9wcGluZyB3aGVuIHRoZSByb290IGVsZW1lbnQgaXMgcmVhY2hlZFxuICAgICAqIChzaWduYWxlZCBieSBgLnBhcmVudGAgcmV0dXJuaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBzYW1lIG9iamVjdClcbiAgICAgKi9cbiAgICBsZXQgbmV4dCA9IGNvbnRhaW5lZDtcbiAgICB3aGlsZSAobmV4dCAmJiBuZXh0ICE9PSBuZXh0LnBhcmVudCkge1xuICAgICAgICBuZXh0ID0gbmV4dC5wYXJlbnQ7XG4gICAgICAgIGlmIChuZXh0ID09PSBjb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogRXh0cmFjdCBtdWx0aXBsZSB2YWx1ZXMgZnJvbSBhIGRvY3VtZW50LCBhbmQgc3RvcmUgdGhlbSBpbiBhbiBvYmplY3QuXG4gKlxuICogQGNhdGVnb3J5IFN0YXRpY1xuICogQHBhcmFtIG1hcCAtIEFuIG9iamVjdCBjb250YWluaW5nIGtleS12YWx1ZSBwYWlycy4gVGhlIGtleXMgYXJlIHRoZSBuYW1lcyBvZlxuICogICB0aGUgcHJvcGVydGllcyB0byBiZSBjcmVhdGVkIG9uIHRoZSBvYmplY3QsIGFuZCB0aGUgdmFsdWVzIGFyZSB0aGVcbiAqICAgc2VsZWN0b3JzIHRvIGJlIHVzZWQgdG8gZXh0cmFjdCB0aGUgdmFsdWVzLlxuICogQHJldHVybnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGV4dHJhY3RlZCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3QobWFwKSB7XG4gICAgcmV0dXJuIHRoaXMucm9vdCgpLmV4dHJhY3QobWFwKTtcbn1cbi8qKlxuICogJC5tZXJnZSgpLlxuICpcbiAqIEBjYXRlZ29yeSBTdGF0aWNcbiAqIEBwYXJhbSBhcnIxIC0gRmlyc3QgYXJyYXkuXG4gKiBAcGFyYW0gYXJyMiAtIFNlY29uZCBhcnJheS5cbiAqIEByZXR1cm5zIGBhcnIxYCwgd2l0aCBlbGVtZW50cyBvZiBgYXJyMmAgaW5zZXJ0ZWQuXG4gKiBAYWxpYXMgQ2hlZXJpby5tZXJnZVxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9hcGkuanF1ZXJ5LmNvbS9qUXVlcnkubWVyZ2UvfVxuICovXG5mdW5jdGlvbiBtZXJnZShhcnIxLCBhcnIyKSB7XG4gICAgaWYgKCFpc0FycmF5TGlrZShhcnIxKSB8fCAhaXNBcnJheUxpa2UoYXJyMikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgbmV3TGVuZ3RoID0gYXJyMS5sZW5ndGg7XG4gICAgY29uc3QgbGVuID0gK2FycjIubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgYXJyMVtuZXdMZW5ndGgrK10gPSBhcnIyW2ldO1xuICAgIH1cbiAgICBhcnIxLmxlbmd0aCA9IG5ld0xlbmd0aDtcbiAgICByZXR1cm4gYXJyMTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIGFuIG9iamVjdCBpcyBhcnJheS1saWtlLlxuICpcbiAqIEBjYXRlZ29yeSBTdGF0aWNcbiAqIEBwYXJhbSBpdGVtIC0gSXRlbSB0byBjaGVjay5cbiAqIEByZXR1cm5zIEluZGljYXRlcyBpZiB0aGUgaXRlbSBpcyBhcnJheS1saWtlLlxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZShpdGVtKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaXRlbSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgaXRlbSA9PT0gbnVsbCB8fFxuICAgICAgICAhKCdsZW5ndGgnIGluIGl0ZW0pIHx8XG4gICAgICAgIHR5cGVvZiBpdGVtLmxlbmd0aCAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgaXRlbS5sZW5ndGggPCAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghKGkgaW4gaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRpYy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/cheerio/dist/commonjs/static.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/cheerio/dist/commonjs/utils.js":
/*!*****************************************************!*\
  !*** ./node_modules/cheerio/dist/commonjs/utils.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isCheerio = isCheerio;\nexports.camelCase = camelCase;\nexports.cssCase = cssCase;\nexports.domEach = domEach;\nexports.isHtml = isHtml;\n/**\n * Checks if an object is a Cheerio instance.\n *\n * @category Utils\n * @param maybeCheerio - The object to check.\n * @returns Whether the object is a Cheerio instance.\n */\nfunction isCheerio(maybeCheerio) {\n    return maybeCheerio.cheerio != null;\n}\n/**\n * Convert a string to camel case notation.\n *\n * @private\n * @category Utils\n * @param str - The string to be converted.\n * @returns String in camel case notation.\n */\nfunction camelCase(str) {\n    return str.replace(/[._-](\\w|$)/g, (_, x) => x.toUpperCase());\n}\n/**\n * Convert a string from camel case to \"CSS case\", where word boundaries are\n * described by hyphens (\"-\") and all characters are lower-case.\n *\n * @private\n * @category Utils\n * @param str - The string to be converted.\n * @returns String in \"CSS case\".\n */\nfunction cssCase(str) {\n    return str.replace(/[A-Z]/g, '-$&').toLowerCase();\n}\n/**\n * Iterate over each DOM element without creating intermediary Cheerio\n * instances.\n *\n * This is indented for use internally to avoid otherwise unnecessary memory\n * pressure introduced by _make.\n *\n * @category Utils\n * @param array - The array to iterate over.\n * @param fn - Function to call.\n * @returns The original instance.\n */\nfunction domEach(array, fn) {\n    const len = array.length;\n    for (let i = 0; i < len; i++)\n        fn(array[i], i);\n    return array;\n}\nvar CharacterCodes;\n(function (CharacterCodes) {\n    CharacterCodes[CharacterCodes[\"LowerA\"] = 97] = \"LowerA\";\n    CharacterCodes[CharacterCodes[\"LowerZ\"] = 122] = \"LowerZ\";\n    CharacterCodes[CharacterCodes[\"UpperA\"] = 65] = \"UpperA\";\n    CharacterCodes[CharacterCodes[\"UpperZ\"] = 90] = \"UpperZ\";\n    CharacterCodes[CharacterCodes[\"Exclamation\"] = 33] = \"Exclamation\";\n})(CharacterCodes || (CharacterCodes = {}));\n/**\n * Check if string is HTML.\n *\n * Tests for a `<` within a string, immediate followed by a letter and\n * eventually followed by a `>`.\n *\n * @private\n * @category Utils\n * @param str - The string to check.\n * @returns Indicates if `str` is HTML.\n */\nfunction isHtml(str) {\n    const tagStart = str.indexOf('<');\n    if (tagStart < 0 || tagStart > str.length - 3)\n        return false;\n    const tagChar = str.charCodeAt(tagStart + 1);\n    return (((tagChar >= CharacterCodes.LowerA && tagChar <= CharacterCodes.LowerZ) ||\n        (tagChar >= CharacterCodes.UpperA && tagChar <= CharacterCodes.UpperZ) ||\n        tagChar === CharacterCodes.Exclamation) &&\n        str.includes('>', tagStart + 2));\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2hlZXJpby9kaXN0L2NvbW1vbmpzL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsZUFBZTtBQUNmLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0M7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2ltdGl5YXovRGVza3RvcC9TdXBlckxlYXJuL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9jaGVlcmlvL2Rpc3QvY29tbW9uanMvdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzQ2hlZXJpbyA9IGlzQ2hlZXJpbztcbmV4cG9ydHMuY2FtZWxDYXNlID0gY2FtZWxDYXNlO1xuZXhwb3J0cy5jc3NDYXNlID0gY3NzQ2FzZTtcbmV4cG9ydHMuZG9tRWFjaCA9IGRvbUVhY2g7XG5leHBvcnRzLmlzSHRtbCA9IGlzSHRtbDtcbi8qKlxuICogQ2hlY2tzIGlmIGFuIG9iamVjdCBpcyBhIENoZWVyaW8gaW5zdGFuY2UuXG4gKlxuICogQGNhdGVnb3J5IFV0aWxzXG4gKiBAcGFyYW0gbWF5YmVDaGVlcmlvIC0gVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIG9iamVjdCBpcyBhIENoZWVyaW8gaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGlzQ2hlZXJpbyhtYXliZUNoZWVyaW8pIHtcbiAgICByZXR1cm4gbWF5YmVDaGVlcmlvLmNoZWVyaW8gIT0gbnVsbDtcbn1cbi8qKlxuICogQ29udmVydCBhIHN0cmluZyB0byBjYW1lbCBjYXNlIG5vdGF0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY2F0ZWdvcnkgVXRpbHNcbiAqIEBwYXJhbSBzdHIgLSBUaGUgc3RyaW5nIHRvIGJlIGNvbnZlcnRlZC5cbiAqIEByZXR1cm5zIFN0cmluZyBpbiBjYW1lbCBjYXNlIG5vdGF0aW9uLlxuICovXG5mdW5jdGlvbiBjYW1lbENhc2Uoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bLl8tXShcXHd8JCkvZywgKF8sIHgpID0+IHgudG9VcHBlckNhc2UoKSk7XG59XG4vKipcbiAqIENvbnZlcnQgYSBzdHJpbmcgZnJvbSBjYW1lbCBjYXNlIHRvIFwiQ1NTIGNhc2VcIiwgd2hlcmUgd29yZCBib3VuZGFyaWVzIGFyZVxuICogZGVzY3JpYmVkIGJ5IGh5cGhlbnMgKFwiLVwiKSBhbmQgYWxsIGNoYXJhY3RlcnMgYXJlIGxvd2VyLWNhc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjYXRlZ29yeSBVdGlsc1xuICogQHBhcmFtIHN0ciAtIFRoZSBzdHJpbmcgdG8gYmUgY29udmVydGVkLlxuICogQHJldHVybnMgU3RyaW5nIGluIFwiQ1NTIGNhc2VcIi5cbiAqL1xuZnVuY3Rpb24gY3NzQ2FzZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1tBLVpdL2csICctJCYnKS50b0xvd2VyQ2FzZSgpO1xufVxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgZWFjaCBET00gZWxlbWVudCB3aXRob3V0IGNyZWF0aW5nIGludGVybWVkaWFyeSBDaGVlcmlvXG4gKiBpbnN0YW5jZXMuXG4gKlxuICogVGhpcyBpcyBpbmRlbnRlZCBmb3IgdXNlIGludGVybmFsbHkgdG8gYXZvaWQgb3RoZXJ3aXNlIHVubmVjZXNzYXJ5IG1lbW9yeVxuICogcHJlc3N1cmUgaW50cm9kdWNlZCBieSBfbWFrZS5cbiAqXG4gKiBAY2F0ZWdvcnkgVXRpbHNcbiAqIEBwYXJhbSBhcnJheSAtIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0gZm4gLSBGdW5jdGlvbiB0byBjYWxsLlxuICogQHJldHVybnMgVGhlIG9yaWdpbmFsIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBkb21FYWNoKGFycmF5LCBmbikge1xuICAgIGNvbnN0IGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICBmbihhcnJheVtpXSwgaSk7XG4gICAgcmV0dXJuIGFycmF5O1xufVxudmFyIENoYXJhY3RlckNvZGVzO1xuKGZ1bmN0aW9uIChDaGFyYWN0ZXJDb2Rlcykge1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiTG93ZXJBXCJdID0gOTddID0gXCJMb3dlckFcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIkxvd2VyWlwiXSA9IDEyMl0gPSBcIkxvd2VyWlwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiVXBwZXJBXCJdID0gNjVdID0gXCJVcHBlckFcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIlVwcGVyWlwiXSA9IDkwXSA9IFwiVXBwZXJaXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJFeGNsYW1hdGlvblwiXSA9IDMzXSA9IFwiRXhjbGFtYXRpb25cIjtcbn0pKENoYXJhY3RlckNvZGVzIHx8IChDaGFyYWN0ZXJDb2RlcyA9IHt9KSk7XG4vKipcbiAqIENoZWNrIGlmIHN0cmluZyBpcyBIVE1MLlxuICpcbiAqIFRlc3RzIGZvciBhIGA8YCB3aXRoaW4gYSBzdHJpbmcsIGltbWVkaWF0ZSBmb2xsb3dlZCBieSBhIGxldHRlciBhbmRcbiAqIGV2ZW50dWFsbHkgZm9sbG93ZWQgYnkgYSBgPmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjYXRlZ29yeSBVdGlsc1xuICogQHBhcmFtIHN0ciAtIFRoZSBzdHJpbmcgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBJbmRpY2F0ZXMgaWYgYHN0cmAgaXMgSFRNTC5cbiAqL1xuZnVuY3Rpb24gaXNIdG1sKHN0cikge1xuICAgIGNvbnN0IHRhZ1N0YXJ0ID0gc3RyLmluZGV4T2YoJzwnKTtcbiAgICBpZiAodGFnU3RhcnQgPCAwIHx8IHRhZ1N0YXJ0ID4gc3RyLmxlbmd0aCAtIDMpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCB0YWdDaGFyID0gc3RyLmNoYXJDb2RlQXQodGFnU3RhcnQgKyAxKTtcbiAgICByZXR1cm4gKCgodGFnQ2hhciA+PSBDaGFyYWN0ZXJDb2Rlcy5Mb3dlckEgJiYgdGFnQ2hhciA8PSBDaGFyYWN0ZXJDb2Rlcy5Mb3dlclopIHx8XG4gICAgICAgICh0YWdDaGFyID49IENoYXJhY3RlckNvZGVzLlVwcGVyQSAmJiB0YWdDaGFyIDw9IENoYXJhY3RlckNvZGVzLlVwcGVyWikgfHxcbiAgICAgICAgdGFnQ2hhciA9PT0gQ2hhcmFjdGVyQ29kZXMuRXhjbGFtYXRpb24pICYmXG4gICAgICAgIHN0ci5pbmNsdWRlcygnPicsIHRhZ1N0YXJ0ICsgMikpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/cheerio/dist/commonjs/utils.js\n");

/***/ })

};
;